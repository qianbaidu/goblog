# ************************************************************
# Sequel Pro SQL dump
# Version 4541
#
# http://www.sequelpro.com/
# https://github.com/sequelpro/sequelpro
#
# Host: 127.0.0.1 (MySQL 5.6.29)
# Database: qipajun
# Generation Time: 2017-03-26 09:45:50 +0000
# ************************************************************


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


# Dump of table duosutewp_posts
# ------------------------------------------------------------

DROP TABLE IF EXISTS `duosutewp_posts`;

CREATE TABLE `duosutewp_posts` (
  `ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `post_author` bigint(20) unsigned NOT NULL DEFAULT '0',
  `post_date` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_date_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content` longtext COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_title` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_excerpt` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_status` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'publish',
  `comment_status` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'open',
  `ping_status` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'open',
  `post_password` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `post_name` varchar(200) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `to_ping` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `pinged` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_modified` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_modified_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content_filtered` longtext COLLATE utf8mb4_unicode_ci NOT NULL,
  `post_parent` bigint(20) unsigned NOT NULL DEFAULT '0',
  `guid` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `menu_order` int(11) NOT NULL DEFAULT '0',
  `post_type` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'post',
  `post_mime_type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `comment_count` bigint(20) NOT NULL DEFAULT '0',
  PRIMARY KEY (`ID`),
  KEY `post_name` (`post_name`(191)),
  KEY `type_status_date` (`post_type`,`post_status`,`post_date`,`ID`),
  KEY `post_parent` (`post_parent`),
  KEY `post_author` (`post_author`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

LOCK TABLES `duosutewp_posts` WRITE;
/*!40000 ALTER TABLE `duosutewp_posts` DISABLE KEYS */;

INSERT INTO `duosutewp_posts` (`ID`, `post_author`, `post_date`, `post_date_gmt`, `post_content`, `post_title`, `post_excerpt`, `post_status`, `comment_status`, `ping_status`, `post_password`, `post_name`, `to_ping`, `pinged`, `post_modified`, `post_modified_gmt`, `post_content_filtered`, `post_parent`, `guid`, `menu_order`, `post_type`, `post_mime_type`, `comment_count`)
VALUES
	(1,1,'2017-03-26 13:51:36','2017-03-26 05:51:36','<h2>nginx 配置文件加入配置代码</h2>\n\n<ul>\n<li>找到conf文件\n> - 通常默认配置在 <code>/etc/nginx/conf.d</code> 如果不在可以尝试<code>nginx -t</code> 测试一下 按提示路径找到 进入目录 <code>conf.d</code> 找到域名对应配置文件\n\n<ul>\n<li>加入代码\n找到域名对应nginx配置文件 在 location /{ //加入代码 }\n*.conf配置文件代码</li>\n</ul></li>\n</ul>\n\n<pre><code>     location / {\n\n            if (-f $request_filename/index.html){\n                rewrite (.*) $1/index.html break;\n            }\n            if (-f $request_filename/index.php){\n                rewrite (.*) $1/index.php;\n            }\n            if (!-f $request_filename){\n                rewrite (.*) /index.php;\n            }\n}\n</code></pre>\n\n<ul>\n<li>测试、加载nginx配置\n> - <code>nginx -t</code> 测试  权限不够加sudo 如果看到失败 先把提示问题解决。成功后执行下步\n> - <code>sudo nginx -s reload</code> 重新加载nginx配置文件 \n重新加载配置文件成功后 开始配置WordPress后台伪静态规则。</li>\n</ul>\n\n<h2>配置WordPress后台伪静态规则</h2>\n\n<blockquote>\n  <code>设置</code> - <code>固定连接</code> -  选择设置规则样式 也可以自定义结构 比如 <code>/%category%/%post_id%.html</code> 就是 <code>域名/栏目/文章id.html</code>样式路径了\n</blockquote>\n\n相关阅读文档地址:https://codex.wordpress.org/zh-cn:%E4%BD%BF%E7%94%A8%E5%9B%BA%E5%AE%9A%E9%93%BE%E6%8E%A5','Linux上如何配置WordPress伪静态','','publish','closed','open','','linux%e4%b8%8a%e5%a6%82%e4%bd%95%e9%85%8d%e7%bd%aewordpress%e4%bc%aa%e9%9d%99%e6%80%81','','','2017-03-26 13:51:36','2017-03-26 05:51:36','## nginx 配置文件加入配置代码\n- 找到conf文件\n > - 通常默认配置在 `/etc/nginx/conf.d` 如果不在可以尝试`nginx -t` 测试一下 按提示路径找到 进入目录 `conf.d` 找到域名对应配置文件\n -  加入代码\n找到域名对应nginx配置文件 在 location /{ //加入代码 }\n*.conf配置文件代码\n```\n     location / {\n\n            if (-f $request_filename/index.html){\n                rewrite (.*) $1/index.html break;\n            }\n            if (-f $request_filename/index.php){\n                rewrite (.*) $1/index.php;\n            }\n            if (!-f $request_filename){\n                rewrite (.*) /index.php;\n            }\n}\n```\n- 测试、加载nginx配置\n> - `nginx -t` 测试  权限不够加sudo 如果看到失败 先把提示问题解决。成功后执行下步\n> - `sudo nginx -s reload` 重新加载nginx配置文件 \n重新加载配置文件成功后 开始配置WordPress后台伪静态规则。\n\n##  配置WordPress后台伪静态规则\n> `设置` - `固定连接` -  选择设置规则样式 也可以自定义结构 比如 `/%category%/%post_id%.html` 就是 `域名/栏目/文章id.html`样式路径了\n\n相关阅读文档地址:https://codex.wordpress.org/zh-cn:%E4%BD%BF%E7%94%A8%E5%9B%BA%E5%AE%9A%E9%93%BE%E6%8E%A5',0,'http://localhost/qipajun/?p=1',0,'post','',0),
	(3,1,'2017-03-26 13:51:36','2017-03-26 05:51:36','<blockquote>\n  之前博客转移过一次，数据丢失了一部分，之后就未写过博客了。\n      今天把数据都清空了，重头写起。\n</blockquote>\n\n<h2>良久不写了 为何又要重写？</h2>\n\n<ul>\n<li>用文字的方式记录自己的历程\n时间虽恍如昨日，可是有些经历的事情，却已越发模糊。\n该记录的知识点，走过的坑，实际操作中的问题，及时记录下来，方便以后忘记了好回顾。记录中总结，总结中成长。</li>\n<li>发现一款爱不释手的编辑器\n使用MarkEditor 写东西以后，发现确实非常舒服，而且自带<code>FilesHook</code>  对程序员来说简不要太直贴心。\n通过FilesHook 配置好发布脚本，写完直接点下同步直接发布到博客，或者执行其他脚本都ok，非常方便。</li>\n</ul>\n\n<h2>写些什么？</h2>\n\n更多的可是技术上的东西，自己学习的新东西有意思的东西，踩过的坑，或实践中体会、感想等。以博客的形式监督自己时常学习、总结，帮助自己技术不断进步。\n\n<h2>博文发布、 MarkEditor如何配置发布WordPress博客 ？</h2>\n\n之前用为知笔记的时候，windows端有试过发布到博客功能，文章写好直接发布到博客，哎 ，一看挺不错，后来研究了下什么原理。其实WordPress 自带了发布api，所以可以直接调用，通过流的方式将文章读取经过处理后入库。\n所以我用php写了一段脚本\n\n<pre><code>    public function xmlrpcPost($cateogry,$title,$content){\n        $params = array(\n            \'post_type\'     =&gt; \'post\',\n            \'post_status\'   =&gt; \'publish\',  //inherit 、 draft 、 publish\n            \'post_title\'    =&gt;  $title,  //标题\n            \'post_author\'   =&gt;  1,\n//            \'post_excerpt\'  =&gt; \'简介\',\n            \'post_content\'  =&gt; $content,  //\'内容.\'\n            \'terms_names\'   =&gt; array(\n//                \'post_tag\' =&gt; [\'testTag\', \'firstpost\'],  // 标签\n                \'category\' =&gt; $cateogry,\n            )\n        );\n\n        $client = new IXR_Client($this-&gt;xmlrpcUrl);\n        $client -&gt; debug = false;  //optional but useful\n        $res = $client -&gt; query(\'wp.newPost\',1, $this-&gt;user, $this-&gt;passwd, $params);\n        return $res;\n    }\n</code></pre>\n\n前面需要引入一下  WordPress自带的类\n\n<pre><code>require(\'../wp-includes/class-IXR.php\');  \n</code></pre>\n\n本地提示\n\n<pre><code>Fatal error: Call to undefined function apply_filters() in wp-includes/class-IXR.php on line 283\n</code></pre>\n\n找到方法引入一下 解决问题\n\n<pre><code>require(\'../wp-content/upgrade/wordpress-4.7.2-xQtxgj/wordpress/wp-includes/plugin.php\');\n</code></pre>\n\n脚本写完，FilesHook 配置下调用，写完文章点下同步就自动同步到博客发布了，在也不用自己登陆wordpress超卡超慢的后台操作了，专心写作就OK了。\n\n<h3>其他问配置题解决</h3>\n\n<blockquote>\n  <ul>\n  <li>MarkEditor 写的文档如果有图片 自动保存在目录制定文件中，发布后图片为经过特出处理，直接采用的是scp hook脚本发布。</li>\n  <li>文章发布不重复 脚本中解决。</li>\n  <li>Markdown 语法解析插件for WordPress <code>WP Markdown Editor</code></li>\n  </ul>\n</blockquote>','重新开始写博客','','publish','closed','open','','%e9%87%8d%e6%96%b0%e5%bc%80%e5%a7%8b%e5%86%99%e5%8d%9a%e5%ae%a2','','','2017-03-26 13:51:36','2017-03-26 05:51:36','>  之前博客转移过一次，数据丢失了一部分，之后就未写过博客了。\n    今天把数据都清空了，重头写起。\n## 良久不写了 为何又要重写？\n- 用文字的方式记录自己的历程\n时间虽恍如昨日，可是有些经历的事情，却已越发模糊。\n该记录的知识点，走过的坑，实际操作中的问题，及时记录下来，方便以后忘记了好回顾。记录中总结，总结中成长。\n- 发现一款爱不释手的编辑器\n使用MarkEditor 写东西以后，发现确实非常舒服，而且自带`FilesHook`  对程序员来说简不要太直贴心。\n通过FilesHook 配置好发布脚本，写完直接点下同步直接发布到博客，或者执行其他脚本都ok，非常方便。\n## 写些什么？\n更多的可是技术上的东西，自己学习的新东西有意思的东西，踩过的坑，或实践中体会、感想等。以博客的形式监督自己时常学习、总结，帮助自己技术不断进步。\n## 博文发布、 MarkEditor如何配置发布WordPress博客 ？\n之前用为知笔记的时候，windows端有试过发布到博客功能，文章写好直接发布到博客，哎 ，一看挺不错，后来研究了下什么原理。其实WordPress 自带了发布api，所以可以直接调用，通过流的方式将文章读取经过处理后入库。\n所以我用php写了一段脚本\n```\n    public function xmlrpcPost($cateogry,$title,$content){\n        $params = array(\n            &#039;post_type&#039;     =&gt; &#039;post&#039;,\n            &#039;post_status&#039;   =&gt; &#039;publish&#039;,  //inherit 、 draft 、 publish\n            &#039;post_title&#039;    =&gt;  $title,  //标题\n            &#039;post_author&#039;   =&gt;  1,\n//            &#039;post_excerpt&#039;  =&gt; &#039;简介&#039;,\n            &#039;post_content&#039;  =&gt; $content,  //&#039;内容.&#039;\n            &#039;terms_names&#039;   =&gt; array(\n//                &#039;post_tag&#039; =&gt; [&#039;testTag&#039;, &#039;firstpost&#039;],  // 标签\n                &#039;category&#039; =&gt; $cateogry,\n            )\n        );\n\n        $client = new IXR_Client($this-&gt;xmlrpcUrl);\n        $client -&gt; debug = false;  //optional but useful\n        $res = $client -&gt; query(&#039;wp.newPost&#039;,1, $this-&gt;user, $this-&gt;passwd, $params);\n        return $res;\n    }\n```\n前面需要引入一下  WordPress自带的类\n```\nrequire(&#039;../wp-includes/class-IXR.php&#039;);  \n```\n本地提示 \n```\nFatal error: Call to undefined function apply_filters() in wp-includes/class-IXR.php on line 283\n```\n 找到方法引入一下 解决问题\n```\nrequire(&#039;../wp-content/upgrade/wordpress-4.7.2-xQtxgj/wordpress/wp-includes/plugin.php&#039;);\n```\n脚本写完，FilesHook 配置下调用，写完文章点下同步就自动同步到博客发布了，在也不用自己登陆wordpress超卡超慢的后台操作了，专心写作就OK了。\n\n### 其他问配置题解决\n> -  MarkEditor 写的文档如果有图片 自动保存在目录制定文件中，发布后图片为经过特出处理，直接采用的是scp hook脚本发布。\n> - 文章发布不重复 脚本中解决。\n> - Markdown 语法解析插件for WordPress `WP Markdown Editor`',0,'http://localhost/qipajun/?p=3',0,'post','',0),
	(5,1,'2017-03-26 13:51:36','2017-03-26 05:51:36','<h1>mysql字符串类型</h1>\n\n<img src=\"./_image/2017-03-02-10-26-19.jpg\" alt=\"\" />\n\n<h2>char 和varchar 类型</h2>\n\nchar和varchar很相似，都用来保存mysql中较短的字符串。二者的主要区别在于存储方式的不同:\n- char 列的长度固定 (创建时声明的长度)  长度:0~255\n- varchar 可变长度字符串 长度可以指定0~255(5.0.3版本以前) 或者65535(5.0.3以后)','mysql字符串类型','','publish','closed','open','','mysql%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b','','','2017-03-26 13:51:36','2017-03-26 05:51:36','# mysql字符串类型\n\n![](./_image/2017-03-02-10-26-19.jpg)\n## char 和varchar 类型\nchar和varchar很相似，都用来保存mysql中较短的字符串。二者的主要区别在于存储方式的不同:\n- char 列的长度固定 (创建时声明的长度)  长度:0~255\n- varchar 可变长度字符串 长度可以指定0~255(5.0.3版本以前) 或者65535(5.0.3以后)',0,'http://localhost/qipajun/?p=5',0,'post','',0),
	(7,1,'2017-03-26 13:51:37','2017-03-26 05:51:37','#mysql常用函数\n\n<pre><code class=\"table\">函数 | 功能 \nabs(x) | 返回x的绝对值\nceil(x) | x向上取整\nfloor(x) | 向下取整\nmod(x,y) | 返回x/y的模\nrand() | 返回0到1的随机值\nround(x,y) | 返回四舍五入值\ntruncate(x,y) | 返回x截断y位小数的结果\n</code></pre>\n\n###ABS 返回数值的绝对值\n\n<pre><code>mysql&gt; select abs(-0.8),abs(0.8);\n+-+\n| abs(-0.8) | abs(0.8) |\n+-+\n|       0.8 |      0.8 |\n+-+\n1 row in set (0.01 sec)\n</code></pre>\n\n###CEIL 返回向上取整值\n\n<pre><code>mysql&gt; select ceil(-0.8),ceil(0.8);\n++--+\n|          0 |         1 |\n++--+--+\n| mod(15,10) | mod(1,11) | mod(null,10) |\n++--+--+\n1 row in set (0.00 sec)\n</code></pre>\n\n###RAND() 返回0到1的随机值\n\n<pre><code>mysql&gt; select  rand(),rand();\n+--++\n| 0.2072962515124085 | 0.21381375492905616 |\n+--+--+--+--+--+--+\n| round(1.2345,2) | truncate(1.2345,2) |\n+--+--+\n1 row in set (0.00 sec)\n</code></pre>','mysql数值函数','','publish','closed','open','','mysql%e6%95%b0%e5%80%bc%e5%87%bd%e6%95%b0','','','2017-03-26 13:51:37','2017-03-26 05:51:37','#mysql常用函数\n```table\n函数 | 功能 \nabs(x) | 返回x的绝对值\nceil(x) | x向上取整\nfloor(x) | 向下取整\nmod(x,y) | 返回x/y的模\nrand() | 返回0到1的随机值\nround(x,y) | 返回四舍五入值\ntruncate(x,y) | 返回x截断y位小数的结果\n```\n###ABS 返回数值的绝对值\n```\nmysql&gt; select abs(-0.8),abs(0.8);\n+-+\n| abs(-0.8) | abs(0.8) |\n+-+\n|       0.8 |      0.8 |\n+-+\n1 row in set (0.01 sec)\n```\n###CEIL 返回向上取整值\n```\nmysql&gt; select ceil(-0.8),ceil(0.8);\n++--+\n|          0 |         1 |\n++--+--+\n| mod(15,10) | mod(1,11) | mod(null,10) |\n++--+--+\n1 row in set (0.00 sec)\n```\n###RAND() 返回0到1的随机值\n```\nmysql&gt; select  rand(),rand();\n+--++\n| 0.2072962515124085 | 0.21381375492905616 |\n+--+--+--+--+--+--+\n| round(1.2345,2) | truncate(1.2345,2) |\n+--+--+\n1 row in set (0.00 sec)\n```',0,'http://localhost/qipajun/?p=7',0,'post','',0),
	(9,1,'2017-03-26 13:51:37','2017-03-26 05:51:37','#字符串函数\n\n<pre><code class=\"table\">函数 | 功能\nconcat(s1,s2..sn)  |  链接字符串\ninsert(str,x,y,instr) | 将字符串str从第x位开始，y个字符长的zi串替换为字符串instr\nlower(str) | 字符串转小写\nupper(str)  | 字符串转大写\nleft(str,x) | 返回字符串str最左边的x个字符\nright(str,x) | 返回字符串最右边的x个字符\nlpad(str,n,pad) | 用字符串pad 对str最左边进行填充，直到长度为n隔天字符长度\nrpad(str,n,pad) | 用字符串pad对str嘴右边进行填充，直到长度为n个字符长度\nltrim(str) | 去掉字符串str左侧的空格\nrtrim(str) | 去掉字符串str行尾的空格\nrepeat(str,x) | 返回str重复x次的结果\nreplace(str,a,b) | 替换字符串a为b\nstrcmp(s1,s2) |  比较字符串s1,s2\ntrim(str) | 去掉字符串行位和航头的空格\nsubstring(str,x,y) | 返回字符串str x位置起y个字符串长度\n</code></pre>\n\n###CONCAT(STR,STR1..STRN)\nmysql> select concat(\'aa\',\'bb\'),concat(\'dd\',null);\n+-+-+\n| concat(\'aa\',\'bb\') | concat(\'dd\',null) |\n+-+-+\n| aabb              | NULL              |\n+-+-+\n1 row in set (0.00 sec)\n\n<pre><code>###INSERT(STR,X,Y,INSTR)\n</code></pre>\n\nmysql> select insert(\'beijing2008you\',12,3,\'me\');\n++\n| insert(\'beijing2008you\',12,3,\'me\') |\n++\n| beijing2008me                      |\n++\n1 row in set (0.00 sec)\n\n###LOWER(STR)\n字符串转小写\n\n<pre><code>mysql&gt; select lower(\'AAAAa\');\n+-+\n| aaaaa          |\n+--+--+--+++++++-+\n| replace(\'beijing2008\',2008,2010) |\n+-+\n1 row in set (0.00 sec)\n</code></pre>\n\n###STRCMP\n比较字符串ASCLL码值大小\n(相等返回0，丹玉返回1，小于返回-1)\n\n<pre><code>mysql&gt; select strcmp(\'a\',\'b\'),strcmp(\'b\',\'b\'),strcmp(\'c\',\'b\');\n+--+--+--+\n|              -1 |               0 |               1 |\n+--+++\n| substr(\'beijing2008\',8,4) | substring(\'beijing2008\',1,7) |\n+++\n1 row in set (0.00 sec)\n</code></pre>\n\n#mysql常用函数\n\n<pre><code class=\"table\">函数 | 功能 \nabs(x) | 返回x的绝对值\nceil(x) | x向上取整\nfloor(x) | 向下取整\nmod(x,y) | 返回x/y的模\nrand() | 返回0到1的随机值\nround(x,y) | 返回四舍五入值\ntruncate(x,y) | 返回x截断y位小数的结果\n</code></pre>\n\n###ABS 返回数值的绝对值\n\n<pre><code>mysql&gt; select abs(-0.8),abs(0.8);\n+-+\n| abs(-0.8) | abs(0.8) |\n+-+\n|       0.8 |      0.8 |\n+-+\n1 row in set (0.01 sec)\n</code></pre>\n\n###CEIL 返回向上取整值\n\n<pre><code>mysql&gt; select ceil(-0.8),ceil(0.8);\n++--+\n|          0 |         1 |\n++--+--+\n| mod(15,10) | mod(1,11) | mod(null,10) |\n++--+--+\n1 row in set (0.00 sec)\n</code></pre>\n\n###RAND() 返回0到1的随机值\n\n<pre><code>mysql&gt; select  rand(),rand();\n+--++\n| 0.2072962515124085 | 0.21381375492905616 |\n+--+--+--+--+--+--+\n| round(1.2345,2) | truncate(1.2345,2) |\n+--+--+\n1 row in set (0.00 sec)\n</code></pre>\n\n#mysql中常用日期时间函数\n\n<pre><code class=\"table\">函数 | 功能\nCURDATE() | 返回当前日期\nCURTIME() | 返回当前日期\nNOW() | 返回但钱的时间和日期\nUNIX_TIMESTAMP(date) | 返回日期date的unix时间戳\nFROM_UNIXTIME(UNIXTIME) | 从时间戳转日期\nWEEK(DATE) / YEAR(DATE) | 返回周 年\nHOUR(TIME) MINUTE(TIME) | 返回小时 分钟\nMONTHNAME(DATE) | 返回月份\n</code></pre>\n\n###CURDATE()函数 \n返回当前日期，只包含年与日\n\n<pre><code>mysql&gt; select curdate();\n++\n| curdate()  |\n++\n| 2017-01-11 |\n++\n1 row in set (0.00 sec)\n</code></pre>\n\n###CURTIME() \n返回当前时间只包含时分秒\n\n<pre><code>mysql&gt; select curtime();\n+--+\n| 03:21:02  |\n++\n| now()               |\n++\n1 row in set (0.00 sec)\n</code></pre>\n\n###UNIX_TIMESTAMP(DATE) \n返回日期date的unix时间戳\n\n<pre><code>mysql&gt; select unix_timestamp(now());\n+--+\n|            1484104996 |\n++\n| from_unixtime(1484104996) |\n++\n1 row in set (0.00 sec)\n</code></pre>\n\n###WEEK(DATE) / YEAR(DATE) \n返回制定时间星期日期/年份\n\n<pre><code>mysql&gt; select week(now()),year(now());\n+-+-+\n| week(now()) | year(now()) |\n+-+-+\n|           2 |        2017 |\n+-+-+\n1 row in set (0.00 sec)\n</code></pre>\n\n###HOUR(TIME) MINUTE(TIME)<br />\n时间转小时/分钟\n\n<pre><code>mysql&gt; select hour(curtime()),minute(curdate());\n+--+-+\n|               3 |                 0 |\n+--+\n| version() |\n+--+\n1 row in set (0.00 sec)\n</code></pre>\n\n###USER()\n返回当前用户名\n\n<pre><code>mysql&gt; select user();\n+-+\n| root@localhost |\n+--+\n| inet_ntoa(3232235777) |\n+--+\n1 row in set (0.00 sec)\n</code></pre>','mysql日期和时间函数','','publish','closed','open','','mysql%e6%97%a5%e6%9c%9f%e5%92%8c%e6%97%b6%e9%97%b4%e5%87%bd%e6%95%b0','','','2017-03-26 13:51:37','2017-03-26 05:51:37','#字符串函数\n```table\n函数 | 功能\nconcat(s1,s2..sn)  |  链接字符串\ninsert(str,x,y,instr) | 将字符串str从第x位开始，y个字符长的zi串替换为字符串instr\nlower(str) | 字符串转小写\nupper(str)  | 字符串转大写\nleft(str,x) | 返回字符串str最左边的x个字符\nright(str,x) | 返回字符串最右边的x个字符\nlpad(str,n,pad) | 用字符串pad 对str最左边进行填充，直到长度为n隔天字符长度\nrpad(str,n,pad) | 用字符串pad对str嘴右边进行填充，直到长度为n个字符长度\nltrim(str) | 去掉字符串str左侧的空格\nrtrim(str) | 去掉字符串str行尾的空格\nrepeat(str,x) | 返回str重复x次的结果\nreplace(str,a,b) | 替换字符串a为b\nstrcmp(s1,s2) |  比较字符串s1,s2\ntrim(str) | 去掉字符串行位和航头的空格\nsubstring(str,x,y) | 返回字符串str x位置起y个字符串长度\n```\n###CONCAT(STR,STR1..STRN)\nmysql> select concat(\'aa\',\'bb\'),concat(\'dd\',null);\n+-+-+\n| concat(\'aa\',\'bb\') | concat(\'dd\',null) |\n+-+-+\n| aabb              | NULL              |\n+-+-+\n1 row in set (0.00 sec)\n```\n###INSERT(STR,X,Y,INSTR)\n```\nmysql> select insert(\'beijing2008you\',12,3,\'me\');\n++\n| insert(\'beijing2008you\',12,3,\'me\') |\n++\n| beijing2008me                      |\n++\n1 row in set (0.00 sec)\n\n###LOWER(STR)\n字符串转小写\n```\nmysql&gt; select lower(&#039;AAAAa&#039;);\n+-+\n| aaaaa          |\n+--+--+--+++++++-+\n| replace(&#039;beijing2008&#039;,2008,2010) |\n+-+\n1 row in set (0.00 sec)\n```\n###STRCMP\n比较字符串ASCLL码值大小\n(相等返回0，丹玉返回1，小于返回-1)\n```\nmysql&gt; select strcmp(&#039;a&#039;,&#039;b&#039;),strcmp(&#039;b&#039;,&#039;b&#039;),strcmp(&#039;c&#039;,&#039;b&#039;);\n+--+--+--+\n|              -1 |               0 |               1 |\n+--+++\n| substr(&#039;beijing2008&#039;,8,4) | substring(&#039;beijing2008&#039;,1,7) |\n+++\n1 row in set (0.00 sec)\n```\n#mysql常用函数\n```table\n函数 | 功能 \nabs(x) | 返回x的绝对值\nceil(x) | x向上取整\nfloor(x) | 向下取整\nmod(x,y) | 返回x/y的模\nrand() | 返回0到1的随机值\nround(x,y) | 返回四舍五入值\ntruncate(x,y) | 返回x截断y位小数的结果\n```\n###ABS 返回数值的绝对值\n```\nmysql&gt; select abs(-0.8),abs(0.8);\n+-+\n| abs(-0.8) | abs(0.8) |\n+-+\n|       0.8 |      0.8 |\n+-+\n1 row in set (0.01 sec)\n```\n###CEIL 返回向上取整值\n```\nmysql&gt; select ceil(-0.8),ceil(0.8);\n++--+\n|          0 |         1 |\n++--+--+\n| mod(15,10) | mod(1,11) | mod(null,10) |\n++--+--+\n1 row in set (0.00 sec)\n```\n###RAND() 返回0到1的随机值\n```\nmysql&gt; select  rand(),rand();\n+--++\n| 0.2072962515124085 | 0.21381375492905616 |\n+--+--+--+--+--+--+\n| round(1.2345,2) | truncate(1.2345,2) |\n+--+--+\n1 row in set (0.00 sec)\n```\n\n#mysql中常用日期时间函数\n```table\n函数 | 功能\nCURDATE() | 返回当前日期\nCURTIME() | 返回当前日期\nNOW() | 返回但钱的时间和日期\nUNIX_TIMESTAMP(date) | 返回日期date的unix时间戳\nFROM_UNIXTIME(UNIXTIME) | 从时间戳转日期\nWEEK(DATE) / YEAR(DATE) | 返回周 年\nHOUR(TIME) MINUTE(TIME) | 返回小时 分钟\nMONTHNAME(DATE) | 返回月份\n```\n\n\n###CURDATE()函数 \n返回当前日期，只包含年与日\n```\nmysql&gt; select curdate();\n++\n| curdate()  |\n++\n| 2017-01-11 |\n++\n1 row in set (0.00 sec)\n```\n###CURTIME() \n返回当前时间只包含时分秒\n```\nmysql&gt; select curtime();\n+--+\n| 03:21:02  |\n++\n| now()               |\n++\n1 row in set (0.00 sec)\n```\n###UNIX_TIMESTAMP(DATE) \n返回日期date的unix时间戳\n```\nmysql&gt; select unix_timestamp(now());\n+--+\n|            1484104996 |\n++\n| from_unixtime(1484104996) |\n++\n1 row in set (0.00 sec)\n```\n\n###WEEK(DATE) / YEAR(DATE) \n返回制定时间星期日期/年份\n```\nmysql&gt; select week(now()),year(now());\n+-+-+\n| week(now()) | year(now()) |\n+-+-+\n|           2 |        2017 |\n+-+-+\n1 row in set (0.00 sec)\n```\n###HOUR(TIME) MINUTE(TIME)  \n时间转小时/分钟\n```\nmysql&gt; select hour(curtime()),minute(curdate());\n+--+-+\n|               3 |                 0 |\n+--+\n| version() |\n+--+\n1 row in set (0.00 sec)\n```\n###USER()\n返回当前用户名\n```\nmysql&gt; select user();\n+-+\n| root@localhost |\n+--+\n| inet_ntoa(3232235777) |\n+--+\n1 row in set (0.00 sec)\n```',0,'http://localhost/qipajun/?p=9',0,'post','',0),
	(11,1,'2017-03-26 13:51:37','2017-03-26 05:51:37','#设计索引的原则\n- 搜索的索引列，不一定是索要选择的列\n\n<blockquote>\n  <blockquote>\n    最适合索引是出现在where子句中的列，或链接子句中指定的列，而不是出现在select关键字后的选择列表中的列。\n  </blockquote>\n</blockquote>\n\n<ul>\n<li>使用唯一索引\n\n<blockquote>\n  <blockquote>\n    索引的列的基数越大，索引的效果越好\n    比如 性别  M 和  F 对此索引没有多大用处,因为不管搜索那个值，都会得出大约一半的行\n  </blockquote>\n</blockquote></li>\n<li>使用短索引\n\n<blockquote>\n  <blockquote>\n    如果对字符串列进行索引，应该制定一个前缀长度，只要有可能就应该这样做。较小的索引设计的磁盘IO较少，较短的值比较起来更快。\n  </blockquote>\n</blockquote></li>\n<li>利用最左前缀\n\n<blockquote>\n  <blockquote>\n    在创建一个n列的索引时，实际是创建了MYSQl可利用的n个索引。多列索引可起几个索引的作用，因为可以利用索引中最左边的列集来匹配行。这样的列集成为最左前缀\n  </blockquote>\n</blockquote></li>\n<li>不要过度索引\n\n<blockquote>\n  <blockquote>\n    每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容是，缩影必须进行更新，有时可能需要重构，因此，索引越多，所花费的时间越长。\n  </blockquote>\n</blockquote></li>\n<li>对于innodb存储引擎的表\n\n<blockquote>\n  <blockquote>\n    记录默认会按照一定的顺序保存，\n    如果有明确定义的主键，则按照主键保存。\n    如果没有主键，但是有唯一索引，那么就按照唯一索引的顺序保存。\n    如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个顺序保存。\n    按照主键或者内部列进行的访问时最快的，所以innodb表尽量自己制定主键，当表中同时几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询效率。\n  </blockquote>\n</blockquote></li>\n</ul>\n\n<blockquote>\n  <blockquote>\n    另外，innoDB表的普通索引都会保存主键的键值，所以主键要尽可能的选择较短的数据类型，可以有效减少索引的磁盘占用，提高索引的缓存效果。\n  </blockquote>\n</blockquote>','索引设计原则','','publish','closed','open','','%e7%b4%a2%e5%bc%95%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99','','','2017-03-26 13:51:37','2017-03-26 05:51:37','#设计索引的原则\n- 搜索的索引列，不一定是索要选择的列\n>> 最适合索引是出现在where子句中的列，或链接子句中指定的列，而不是出现在select关键字后的选择列表中的列。\n\n- 使用唯一索引\n>>索引的列的基数越大，索引的效果越好\n    比如 性别  M 和  F 对此索引没有多大用处,因为不管搜索那个值，都会得出大约一半的行\n    \n- 使用短索引\n>>如果对字符串列进行索引，应该制定一个前缀长度，只要有可能就应该这样做。较小的索引设计的磁盘IO较少，较短的值比较起来更快。\n\n- 利用最左前缀\n>>在创建一个n列的索引时，实际是创建了MYSQl可利用的n个索引。多列索引可起几个索引的作用，因为可以利用索引中最左边的列集来匹配行。这样的列集成为最左前缀\n\n- 不要过度索引\n>> 每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容是，缩影必须进行更新，有时可能需要重构，因此，索引越多，所花费的时间越长。\n\n- 对于innodb存储引擎的表\n>>记录默认会按照一定的顺序保存，\n如果有明确定义的主键，则按照主键保存。\n如果没有主键，但是有唯一索引，那么就按照唯一索引的顺序保存。\n如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个顺序保存。\n按照主键或者内部列进行的访问时最快的，所以innodb表尽量自己制定主键，当表中同时几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询效率。\n\n\n>>另外，innoDB表的普通索引都会保存主键的键值，所以主键要尽可能的选择较短的数据类型，可以有效减少索引的磁盘占用，提高索引的缓存效果。',0,'http://localhost/qipajun/?p=11',0,'post','',0),
	(13,1,'2017-03-26 13:51:38','2017-03-26 05:51:38','#通过explain分析低效率sql\n- 可以通过explain 或 desc 命令获取mysql如何执行select语句的信息。\n\n##解释:\n- select_type : 标示select 的类型\n\n<blockquote>\n  simple : 简单表，即不适用表连接或子查询\n  primary : 主查询，即外层的查询\n  union : union中的第二个或者后面的查询语句\n  subquery : 子查询中的第一个select等\n  - table : 输出结果集的表\n  - type :  标示表的连接类型，性能由好到差的连接类型为:\n   system : 表中仅有一行，即常量表\n   const : 单标中最多有一个匹配行 例如primary key 或者 unique index\n  eq_ref : 对于前面的每一行，在此表中查询一条记录，简单来说，就是多表连接中使用primary index 或者unique index \n  ref : 与eq_ref类似，区别在于不是使用primary key 或者unique index ，而是使用普通的索引\n  ref_or_null : 与ref类似，区别在于条件中包含对null的查询\n  index_merge : 索引合并优化\n  unique_subquery : in的后面是一个查询主键字段的查询\n  index_subquery : 与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询\n  rang : 单表中的范围查询\n  index : 对于前面的每一行，都通过查询索引来得到数据\n  all 对于前面每一行，都通过全表扫描来得到数据\n  - possible——keys : 表是查询是，肯能使用的索引\n  -  key : 标示实际使用的索引\n  - key_len : 索引字段的长度\n  - rows : 扫描行的数量\n  - extra : 执行情况的说明和描述\n</blockquote>\n\n<h2>索引存储分类</h2>\n\n<ul>\n<li>MyIASM 存储引擎的表的数据和索引是自动分开存储的，给独立一个文件；</li>\n<li>InnoDB存储引擎的表的数据和索引是在同一个表空间里面，但可以有多个文件组件。</li>\n<li>mysql中索引的存储类型目前只有(BTREE 和HASH);</li>\n<li>MyISAM 和InnoDB 都支持BTREE</li>\n<li>MEMORY/HEAP 存储引擎可以支持HASH和BTREE索引</li>\n</ul>','通过explain分析低效率sql','','publish','closed','open','','%e9%80%9a%e8%bf%87explain%e5%88%86%e6%9e%90%e4%bd%8e%e6%95%88%e7%8e%87sql','','','2017-03-26 13:51:38','2017-03-26 05:51:38','#通过explain分析低效率sql\n- 可以通过explain 或 desc 命令获取mysql如何执行select语句的信息。\n\n\n##解释:\n- select_type : 标示select 的类型\n>simple : 简单表，即不适用表连接或子查询\n>primary : 主查询，即外层的查询\n> union : union中的第二个或者后面的查询语句\n> subquery : 子查询中的第一个select等\n- table : 输出结果集的表\n- type :  标示表的连接类型，性能由好到差的连接类型为:\n>  system : 表中仅有一行，即常量表\n>  const : 单标中最多有一个匹配行 例如primary key 或者 unique index\n> eq_ref : 对于前面的每一行，在此表中查询一条记录，简单来说，就是多表连接中使用primary index 或者unique index \n> ref : 与eq_ref类似，区别在于不是使用primary key 或者unique index ，而是使用普通的索引\n> ref_or_null : 与ref类似，区别在于条件中包含对null的查询\n> index_merge : 索引合并优化\n> unique_subquery : in的后面是一个查询主键字段的查询\n> index_subquery : 与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询\n> rang : 单表中的范围查询\n> index : 对于前面的每一行，都通过查询索引来得到数据\n> all 对于前面每一行，都通过全表扫描来得到数据\n- possible——keys : 表是查询是，肯能使用的索引\n-  key : 标示实际使用的索引\n- key_len : 索引字段的长度\n- rows : 扫描行的数量\n- extra : 执行情况的说明和描述\n## 索引存储分类\n- MyIASM 存储引擎的表的数据和索引是自动分开存储的，给独立一个文件；\n- InnoDB存储引擎的表的数据和索引是在同一个表空间里面，但可以有多个文件组件。\n- mysql中索引的存储类型目前只有(BTREE 和HASH);\n- MyISAM 和InnoDB 都支持BTREE\n- MEMORY/HEAP 存储引擎可以支持HASH和BTREE索引',0,'http://localhost/qipajun/?p=13',0,'post','',0),
	(15,1,'2017-03-26 13:51:38','2017-03-26 05:51:38','<ul>\n<li>php自身并不支持多继承，但是可以用过Trait实现多继承。</li>\n<li>Trait和Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。</li>\n<li>代码实例</li>\n</ul>\n\n<pre><code>trait ezcReflectionReturnInfo {\n\n    public function __construct()\n    {\n        echo \'ezcReflectionReturnInfo\';\n    }\n\n    function getReturnType() {\n        echo \'getReturnType\';\n    }\n    function getReturnDescription() {\n        echo \'getReturnDescription\';\n    }\n}\n\nclass ezcReflectionMethod extends ReflectionMethod {\n    use ezcReflectionReturnInfo;\n    /* ... */\n\n}\n\nclass ezcReflectionFunction extends ReflectionFunction {\n    use ezcReflectionReturnInfo;\n    /* ... */\n}\n\n$a = new ezcReflectionMethod();\n$b = new ezcReflectionFunction();\n</code></pre>\n\n<ul>\n<li>优先级\n> -   从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。\n例:</li>\n</ul>\n\n<pre><code>&lt;?php\nclass Base {\n    public function sayHello() {\n        echo \'Hello \';\n    }\n}\n\ntrait SayWorld {\n    public function sayHello() {\n        parent::sayHello();\n        echo \'World!\';\n    }\n}\n\nclass MyHelloWorld extends Base {\n    use SayWorld;\n}\n\n$o = new MyHelloWorld();\n$o-&gt;sayHello();  //Hello World!\n?&gt;\n</code></pre>\n\n覆盖:\n\n<pre><code>&lt;?php\ntrait HelloWorld {\n    public function sayHello() {\n        echo \'Hello World!\';\n    }\n}\n\nclass TheWorldIsNotEnough {\n    use HelloWorld;\n    public function sayHello() {\n        echo \'Hello Universe!\';\n    }\n}\n\n$o = new TheWorldIsNotEnough();\n$o-&gt;sayHello();\n?&gt;\n</code></pre>\n\n<ul>\n<li>冲突解决\n> - 如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。\n> -  为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。\n>  -  as 操作符可以将其中一个冲突的方法以另一个名称来引入。</li>\n</ul>','php多继承','','publish','closed','open','','php%e5%a4%9a%e7%bb%a7%e6%89%bf','','','2017-03-26 13:51:38','2017-03-26 05:51:38','- php自身并不支持多继承，但是可以用过Trait实现多继承。\n- Trait和Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。\n- 代码实例\n```\ntrait ezcReflectionReturnInfo {\n\n    public function __construct()\n    {\n        echo &#039;ezcReflectionReturnInfo&#039;;\n    }\n\n    function getReturnType() {\n        echo &#039;getReturnType&#039;;\n    }\n    function getReturnDescription() {\n        echo &#039;getReturnDescription&#039;;\n    }\n}\n\nclass ezcReflectionMethod extends ReflectionMethod {\n    use ezcReflectionReturnInfo;\n    /* ... */\n\n}\n\nclass ezcReflectionFunction extends ReflectionFunction {\n    use ezcReflectionReturnInfo;\n    /* ... */\n}\n\n$a = new ezcReflectionMethod();\n$b = new ezcReflectionFunction();\n```\n- 优先级\n> -   从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。\n例:\n```\n&lt;?php\nclass Base {\n    public function sayHello() {\n        echo &#039;Hello &#039;;\n    }\n}\n\ntrait SayWorld {\n    public function sayHello() {\n        parent::sayHello();\n        echo &#039;World!&#039;;\n    }\n}\n\nclass MyHelloWorld extends Base {\n    use SayWorld;\n}\n\n$o = new MyHelloWorld();\n$o-&gt;sayHello();  //Hello World!\n?&gt;\n```\n覆盖:\n```\n&lt;?php\ntrait HelloWorld {\n    public function sayHello() {\n        echo &#039;Hello World!&#039;;\n    }\n}\n\nclass TheWorldIsNotEnough {\n    use HelloWorld;\n    public function sayHello() {\n        echo &#039;Hello Universe!&#039;;\n    }\n}\n\n$o = new TheWorldIsNotEnough();\n$o-&gt;sayHello();\n?&gt;\n```\n\n- 冲突解决\n> - 如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。\n> -  为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。\n>  -  as 操作符可以将其中一个冲突的方法以另一个名称来引入。',0,'http://localhost/qipajun/?p=15',0,'post','',0),
	(17,1,'2017-03-26 13:51:39','2017-03-26 05:51:39','<h2>golang go map 声明、赋值、循环</h2>\n\n<ul>\n<li>声明格式</li>\n</ul>\n\n<pre><code>var map1 map[keytype]valuetype\n</code></pre>\n\n<blockquote>\n  未初始化的map值是nil\n   在声明的时候不需要知道 map 的长度，map 是可以动态增长的。\n  - 声明与赋值\n</blockquote>\n\n<pre><code>var mapLit map[string]int\n    //var mapCreated map[string]float32\n    var mapAssigned map[string]int\n\n    mapLit = map[string]int{\"one\": 1, \"two\": 2}\n    mapCreated := make(map[string]float32)\n    mapAssigned = mapLit\n\n    mapCreated[\"key1\"] = 4.5\n    mapCreated[\"key2\"] = 3.14159\n    mapAssigned[\"two\"] = 3\n\n    fmt.Print(mapAssigned)\n</code></pre>\n\n<ul>\n<li>make 操作</li>\n</ul>\n\n<pre><code>    map1 := make(map[string][]string)\n    map2 := make(map[int]*[]int)\n\n    map1[\"aa\"] = []string{\"a\",\"b\",\"cc\"}\n    map1[\"bb\"] = []string{\"a\",\"b\",\"cc\"}\n\n    fmt.Println(map1)\n    fmt.Println(map2)\n    //值读取\n    k,v := map1[\"aa\"]\n    if v == false {\n        panic(\"键值不存在\")\n    }\n    fmt.Println(k,v)\n\n    delete(map1,\"aa\")\n    fmt.Println(map1)\n</code></pre>\n\n<ul>\n<li>map 循环</li>\n</ul>\n\n<pre><code>    barVal := map[string]int{\"alpha\": 34, \"bravo\": 56, \"charlie\": 23,\n        \"delta\": 87, \"echo\": 56, \"foxtrot\": 12,\n        \"golf\": 34, \"hotel\": 16, \"indio\": 87,\n        \"juliet\": 65, \"kili\": 43, \"lima\": 98}\n\n    newMap := make([]string,len(barVal))\n    i := 0\n    for k,_ := range barVal{\n        newMap[i] = k\n        i ++\n    }\n\n    newMap2 := make(map[int]string,len(barVal))\n    for k,v := range barVal{\n        newMap2[v] = k\n    }\n    fmt.Print(newMap2)\n    sort.Strings(newMap2)\n    fmt.Println(newMap)\n    sort.Strings(newMap)\n    fmt.Println(newMap)\n</code></pre>','go map','','publish','closed','open','','go-map','','','2017-03-26 13:51:39','2017-03-26 05:51:39','##  golang go map 声明、赋值、循环\n- 声明格式\n```\nvar map1 map[keytype]valuetype\n```\n>  未初始化的map值是nil\n>  在声明的时候不需要知道 map 的长度，map 是可以动态增长的。\n- 声明与赋值\n```\nvar mapLit map[string]int\n	//var mapCreated map[string]float32\n	var mapAssigned map[string]int\n\n	mapLit = map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2}\n	mapCreated := make(map[string]float32)\n	mapAssigned = mapLit\n\n	mapCreated[&quot;key1&quot;] = 4.5\n	mapCreated[&quot;key2&quot;] = 3.14159\n	mapAssigned[&quot;two&quot;] = 3\n\n	fmt.Print(mapAssigned)\n```\n\n- make 操作\n```\n	map1 := make(map[string][]string)\n	map2 := make(map[int]*[]int)\n\n	map1[&quot;aa&quot;] = []string{&quot;a&quot;,&quot;b&quot;,&quot;cc&quot;}\n	map1[&quot;bb&quot;] = []string{&quot;a&quot;,&quot;b&quot;,&quot;cc&quot;}\n\n	fmt.Println(map1)\n	fmt.Println(map2)\n    //值读取\n	k,v := map1[&quot;aa&quot;]\n	if v == false {\n		panic(&quot;键值不存在&quot;)\n	}\n	fmt.Println(k,v)\n\n	delete(map1,&quot;aa&quot;)\n	fmt.Println(map1)\n```\n- map 循环\n```\n	barVal := map[string]int{&quot;alpha&quot;: 34, &quot;bravo&quot;: 56, &quot;charlie&quot;: 23,\n		&quot;delta&quot;: 87, &quot;echo&quot;: 56, &quot;foxtrot&quot;: 12,\n		&quot;golf&quot;: 34, &quot;hotel&quot;: 16, &quot;indio&quot;: 87,\n		&quot;juliet&quot;: 65, &quot;kili&quot;: 43, &quot;lima&quot;: 98}\n\n	newMap := make([]string,len(barVal))\n	i := 0\n	for k,_ := range barVal{\n		newMap[i] = k\n		i ++\n	}\n\n	newMap2 := make(map[int]string,len(barVal))\n	for k,v := range barVal{\n		newMap2[v] = k\n	}\n	fmt.Print(newMap2)\n	sort.Strings(newMap2)\n	fmt.Println(newMap)\n	sort.Strings(newMap)\n	fmt.Println(newMap)\n```',0,'http://localhost/qipajun/?p=17',0,'post','',0),
	(19,1,'2017-03-26 13:51:39','2017-03-26 05:51:39','<h1>go array</h1>\n\n<h2>go 数组声明与初始化</h2>\n\n<ul>\n<li>数组声明</li>\n</ul>\n\n<pre><code>    var arr [5]int\n    var arr1 = new([5]int)\n</code></pre>\n\n<ul>\n<li>初始化赋值</li>\n</ul>\n\n<pre><code>var arr3 = [5]int{1,2,3,3,5}\nvar arr2 = [...]string{\"a\",\"b\",\"c\"}\n</code></pre>\n\n<ul>\n<li>声明赋值</li>\n</ul>\n\n<pre><code>    a := [2]int{1} //长度2 只赋一个值\n    a[1] = 3\n    fmt.Println(a) //[1 3]\n\n    b := [5]int{4:1}\n    fmt.Println(b) //[0 0 0 0 1]\n\n    c := [...]int{9:1} //不定长\n    fmt.Println(c)  //[0 0 0 0 0 0 0 0 0 1]\n\n    d := [10]int{}\n    d[1] = 2\n    fmt.Println(d)\n\n    e := new([10]int)\n    e[1] = 2\n    fmt.Println(e)\n</code></pre>\n\n<h1>go slice</h1>\n\n<ul>\n<li>切片是一个长度可变的数组</li>\n<li>优点 因为切片是引用，所以他们不需要使用额外的内存并且比使用数组更有效，所以在go中切片比数组更常使用.</li>\n<li>声明</li>\n</ul>\n\n<pre><code>    //var slice []type = array[strat:end]\n    //var slice1 []type = arr1[:]  //那么 slice1 就等于完整的 arr1 数组  arr1[0:len(arr1)\n    //arr1[2:] 和 arr1[2:len(arr1)] //相同，都包含了数组从第三个到最后的所有元素。\n    //arr1[:3] 和 arr1[0:3] //相同，包含了从第一个到第三个元素（不包括第三个\n    //slice1 = slice1[:len(slice1)-1] //去掉最后一个元素\n\n</code></pre>\n\n<ul>\n<li>初始化</li>\n</ul>\n\n<pre><code>    s := [3]int{1,2,3}\n    s1 := []int{1,2,3}\n    fmt.Print(s,s1)\n</code></pre>\n\n<ul>\n<li>数组初始化  slice 切片数组</li>\n</ul>\n\n<pre><code>    var arr [6]int\n    var slice []int = arr[2:5]\n    fmt.Println(slice)\n    //遍历数组\n    for i:=0;i&lt;len(arr);i++{\n        arr[i] = i\n    }\n    fmt.Println(arr)\n    // slice 是应用类型  改变arr  slice也就变了\n    for i:=0;i&lt;len(slice);i++{\n        fmt.Println(slice[i])\n    }\n</code></pre>\n\n<pre><code>    b := []byte{\'g\',\'o\',\'i\',\'a\',\'q\',\'l\'}\n    fmt.Print(string(b[0:5]))\n\n    //切片传递\n    var arr = [5]int{0,1,2,3,4}\n    num := sum(arr[:])\n    fmt.Println(num)\n</code></pre>\n\n<ul>\n<li>make 创建切片</li>\n</ul>\n\n<pre><code>    // 语法 var slice []type = make([]type,len)\n    //var slice []int = make([]int ,10,100)\n    //fmt.Println(slice)\n    //fmt.Println(len(slice))\n    //fmt.Println(cap(slice))\n</code></pre>\n\n<ul>\n<li>make 和 new 的区别\n>  都在堆上分配内存，但运行行为不同，适用于不同的类型\n> new(t) 分配内存 初始化0 并且返回*t的内存地址,这种方法返回一个指向类型为t，值为0 的地址的指针，使用与值类型 如数组和结构体\n> new函数分配内存\n> make(t) 返回一个类型为t的初始值 只使用与3中内建的引用类型 : 切片、map channel\n> make函数初始化</li>\n</ul>\n\n<pre><code>//s := make([]byte,5);\n    //fmt.Println(len(s)) //5\n    //s1 := s[2:4]\n    //fmt.Println(len(s1),cap(s1))  // 2  3\n\n    //引用类型\n    //s1 := []byte{\'p\', \'o\', \'e\', \'m\'}\n    //s2 := s1[2:]\n    ////fmt.Println(s2)\n    //s2[1] = \'t\'\n    //fmt.Println(string(s1))\n    //fmt.Println(string(s2))\n\n    //var ar = [10]int{0,1,2,3,4,5,6,7,8,9}\n    //var a = ar[5:7]\n    //fmt.Println(a)\n    //a = a[0:4]\n    //fmt.Println(a) //引用类型 值取决于 切片数组而不是依据上次切片\n\n    //fmt.Println(len(ar),cap(ar))\n    //r := ar[2:2] //len 0  cap 取决与截取后剩余多少个\n    //r1 := ar[2:2+1] //len 1 cap 取决与从开始截取位置到截取后剩余多少个\n    //fmt.Println(len(r),cap(r))\n    //fmt.Println(len(r1),cap(r1))\n\n\n    //赋值 与追加\n    //a := []int{1,2,3}\n    //a1 := make([]int,10)\n    //n := copy(a1,a) //将 a 拷贝给a1\n    //fmt.Println(n)\n    //fmt.Print(a1)\n\n\n    //s := \"\\u00ff\\u754c\"\n    //for i, c := range s {\n    //  fmt.Printf(\"%d:%c \", i, c)\n    //}\n\n\n    //str1 := \"asSASA ddd dsjkdsjs dk\"\n    //fmt.Println(len(str1))\n    //fmt.Println(utf8.RuneCountInString(str1))\n    //str2 := \"asSASA ddd dsjkdsjsこん dk\"\n    //fmt.Println(len(str2))\n    //fmt.Println(utf8.RuneCountInString(str2))\n    //\n    ////var b []byte\n    ////var s string\n    ////b = append(b, s...)\n    ////fmt.Println(b)\n    //\n    //s := \"hello\"\n    //c := []byte(s)\n    //c[0] = \'c\'\n    //s2 := string(c) // s2 == \"cello\"\n    //\n    //fmt.Print(s2)\n</code></pre>','go array go slice','','publish','closed','open','','go-array-go-slice','','','2017-03-26 13:51:39','2017-03-26 05:51:39','# go array\n## go 数组声明与初始化 \n- 数组声明\n```\n    var arr [5]int\n	var arr1 = new([5]int)\n```\n- 初始化赋值\n```\nvar arr3 = [5]int{1,2,3,3,5}\nvar arr2 = [...]string{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}\n```\n- 声明赋值\n```\n    a := [2]int{1} //长度2 只赋一个值\n	a[1] = 3\n	fmt.Println(a) //[1 3]\n\n	b := [5]int{4:1}\n	fmt.Println(b) //[0 0 0 0 1]\n\n	c := [...]int{9:1} //不定长\n	fmt.Println(c)	//[0 0 0 0 0 0 0 0 0 1]\n\n	d := [10]int{}\n	d[1] = 2\n	fmt.Println(d)\n\n	e := new([10]int)\n	e[1] = 2\n	fmt.Println(e)\n```\n	\n\n# go slice\n- 切片是一个长度可变的数组\n- 优点 因为切片是引用，所以他们不需要使用额外的内存并且比使用数组更有效，所以在go中切片比数组更常使用.\n-  声明\n```\n    //var slice []type = array[strat:end]\n	//var slice1 []type = arr1[:]  //那么 slice1 就等于完整的 arr1 数组  arr1[0:len(arr1)\n	//arr1[2:] 和 arr1[2:len(arr1)] //相同，都包含了数组从第三个到最后的所有元素。\n	//arr1[:3] 和 arr1[0:3] //相同，包含了从第一个到第三个元素（不包括第三个\n	//slice1 = slice1[:len(slice1)-1] //去掉最后一个元素\n\n```\n- 初始化\n```\n    s := [3]int{1,2,3}\n	s1 := []int{1,2,3}\n	fmt.Print(s,s1)\n```\n- 数组初始化  slice 切片数组\n```\n    var arr [6]int\n	var slice []int = arr[2:5]\n	fmt.Println(slice)\n    //遍历数组\n	for i:=0;i&lt;len(arr);i++{\n		arr[i] = i\n	}\n	fmt.Println(arr)\n	// slice 是应用类型  改变arr  slice也就变了\n	for i:=0;i&lt;len(slice);i++{\n		fmt.Println(slice[i])\n	}\n```\n\n```\n    b := []byte{&#039;g&#039;,&#039;o&#039;,&#039;i&#039;,&#039;a&#039;,&#039;q&#039;,&#039;l&#039;}\n	fmt.Print(string(b[0:5]))\n\n	//切片传递\n	var arr = [5]int{0,1,2,3,4}\n	num := sum(arr[:])\n	fmt.Println(num)\n```\n- make 创建切片\n```\n	// 语法 var slice []type = make([]type,len)\n	//var slice []int = make([]int ,10,100)\n	//fmt.Println(slice)\n	//fmt.Println(len(slice))\n	//fmt.Println(cap(slice))\n```\n- make 和 new 的区别\n>  都在堆上分配内存，但运行行为不同，适用于不同的类型\n> new(t) 分配内存 初始化0 并且返回*t的内存地址,这种方法返回一个指向类型为t，值为0 的地址的指针，使用与值类型 如数组和结构体\n> new函数分配内存\n> make(t) 返回一个类型为t的初始值 只使用与3中内建的引用类型 : 切片、map channel\n> make函数初始化\n\n```\n//s := make([]byte,5);\n	//fmt.Println(len(s)) //5\n	//s1 := s[2:4]\n	//fmt.Println(len(s1),cap(s1))  // 2  3\n\n	//引用类型\n	//s1 := []byte{&#039;p&#039;, &#039;o&#039;, &#039;e&#039;, &#039;m&#039;}\n	//s2 := s1[2:]\n	////fmt.Println(s2)\n	//s2[1] = &#039;t&#039;\n	//fmt.Println(string(s1))\n	//fmt.Println(string(s2))\n\n	//var ar = [10]int{0,1,2,3,4,5,6,7,8,9}\n	//var a = ar[5:7]\n	//fmt.Println(a)\n	//a = a[0:4]\n	//fmt.Println(a) //引用类型 值取决于 切片数组而不是依据上次切片\n\n	//fmt.Println(len(ar),cap(ar))\n	//r := ar[2:2] //len 0  cap 取决与截取后剩余多少个\n	//r1 := ar[2:2+1] //len 1 cap 取决与从开始截取位置到截取后剩余多少个\n	//fmt.Println(len(r),cap(r))\n	//fmt.Println(len(r1),cap(r1))\n\n\n	//赋值 与追加\n	//a := []int{1,2,3}\n	//a1 := make([]int,10)\n	//n := copy(a1,a) //将 a 拷贝给a1\n	//fmt.Println(n)\n	//fmt.Print(a1)\n\n\n	//s := &quot;\\u00ff\\u754c&quot;\n	//for i, c := range s {\n	//	fmt.Printf(&quot;%d:%c &quot;, i, c)\n	//}\n\n\n	//str1 := &quot;asSASA ddd dsjkdsjs dk&quot;\n	//fmt.Println(len(str1))\n	//fmt.Println(utf8.RuneCountInString(str1))\n	//str2 := &quot;asSASA ddd dsjkdsjsこん dk&quot;\n	//fmt.Println(len(str2))\n	//fmt.Println(utf8.RuneCountInString(str2))\n	//\n	////var b []byte\n	////var s string\n	////b = append(b, s...)\n	////fmt.Println(b)\n	//\n	//s := &quot;hello&quot;\n	//c := []byte(s)\n	//c[0] = &#039;c&#039;\n	//s2 := string(c) // s2 == &quot;cello&quot;\n	//\n	//fmt.Print(s2)\n```',0,'http://localhost/qipajun/?p=19',0,'post','',0),
	(21,1,'2017-03-26 13:51:39','2017-03-26 05:51:39','','2017-02-13','','publish','closed','open','','2017-02-13','','','2017-03-26 13:51:39','2017-03-26 05:51:39','',0,'http://localhost/qipajun/?p=21',0,'post','',0),
	(23,1,'2017-03-26 13:51:40','2017-03-26 05:51:40','<blockquote>\n  php 内置函数方法使用\n</blockquote>\n\n<ul>\n<li>reset</li>\n<li>strip_tags </li>\n<li>ReflectionClass::getConstructor</li>\n<li>ReflectionClass</li>\n<li>newInstanceArgs</li>\n<li>is_callable()</li>\n</ul>\n\n<h3>reset</h3>\n\n<ul>\n<li>输出数组中的当前元素和下一个元素的值，然后把数组的内部指针重置到数组中的第一个元素：</li>\n<li>代码示例</li>\n</ul>\n\n<pre><code>&lt;?php\n$people = array(\"Bill\", \"Steve\", \"Mark\", \"David\");\necho current($people) . \"&lt;br&gt;\";  //Bill\necho next($people) . \"&lt;br&gt;\";    //Steve\necho reset($people);  //Bill\n?&gt;\n</code></pre>\n\n<h3>strip_tags</h3>\n\n<ul>\n<li>剥去字符串中的 HTML 标签：</li>\n<li>代码示例</li>\n</ul>\n\n<pre><code>&lt;?php\necho strip_tags(\"Hello &lt;b&gt;world!&lt;/b&gt;\");  //Hello world!\n?&gt;\n</code></pre>\n\n<h3>ReflectionClass::getConstructor</h3>\n\n<ul>\n<li>获取类的构造函数</li>\n<li>代码示例</li>\n</ul>\n\n<pre><code>&lt;?php\n$class = new ReflectionClass(\'ReflectionClass\');\n$constructor = $class-&gt;getConstructor();\nvar_dump($constructor);\n?&gt;\n</code></pre>\n\n<ul>\n<li>输出</li>\n</ul>\n\n<pre><code>object(ReflectionMethod)#2 (2) {\n  [\"name\"]=&gt;\n  string(11) \"__construct\"\n  [\"class\"]=&gt;\n  string(15) \"ReflectionClass\"\n}\n</code></pre>\n\n<h3>ReflectionClass</h3>\n\n<ul>\n<li>映射类\n\n<ul>\n<li>代码实例</li>\n</ul></li>\n</ul>\n\n<pre><code>class Hello {        //定义一个类\n    static function index() {\n        echo  \'hello world\';\n    }\n}\n$class=new ReflectionClass(\'Hello\');    //建立 fuc这个类的反射类\nvar_dump($class);\n</code></pre>\n\n<ul>\n<li>输出</li>\n</ul>\n\n<pre><code>object(ReflectionClass)#1 (1) {\n  [\"name\"]=&gt;\n  string(5) \"Hello\"\n}\n\n</code></pre>\n\n<h3>newInstanceArgs</h3>\n\n<ul>\n<li>从给出的参数创建一个新的类实例。</li>\n<li>code </li>\n</ul>\n\n<pre><code>&lt;?php\n$class = new ReflectionClass(\'ReflectionFunction\');\n$instance = $class-&gt;newInstanceArgs(array(\'substr\'));\nvar_dump($instance);\n?&gt;\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>如果类的构造函数不是 public 的将导致产生一个 ReflectionException。</li>\n  <li>当 args 指定了一个或多个参数，而类不具有构造函数时,将导致一个 ReflectionException。</li>\n  </ul>\n</blockquote>\n\n<h3>is_callable()</h3>\n\n<ul>\n<li>检测函数是否可以调用 是否合法结构</li>\n<li>code </li>\n</ul>\n\n<pre><code>class test {\n    static function a() {\n        return \"test\";\n    }\n}\n\nclass abc {\n    public function a($Object,$funcName){\n        if (!is_callable(array($Object,$funcName))){\n            echo(\"Error\");\n        }else {\n            echo(\"OK\");\n        }\n    }\n}\n\n$abc=new abc();\n$abc-&gt;a(\"test\",\"aa\"); //test类下没有aa方法，会输出error\n$abc-&gt;a(\"test\",\"a\");  //test类下有a方法,会输出ok\n</code></pre>','php内置函数方法使用','','publish','closed','open','','php%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0%e6%96%b9%e6%b3%95%e4%bd%bf%e7%94%a8','','','2017-03-26 13:51:40','2017-03-26 05:51:40','> php 内置函数方法使用\n\n- reset\n-   strip_tags \n-  ReflectionClass::getConstructor\n- ReflectionClass\n-  newInstanceArgs\n- is_callable()\n### reset\n- 输出数组中的当前元素和下一个元素的值，然后把数组的内部指针重置到数组中的第一个元素：\n-  代码示例\n```\n&lt;?php\n$people = array(&quot;Bill&quot;, &quot;Steve&quot;, &quot;Mark&quot;, &quot;David&quot;);\necho current($people) . &quot;&lt;br&gt;&quot;;  //Bill\necho next($people) . &quot;&lt;br&gt;&quot;;    //Steve\necho reset($people);  //Bill\n?&gt;\n```\n### strip_tags\n-  剥去字符串中的 HTML 标签：\n-  代码示例\n```\n&lt;?php\necho strip_tags(&quot;Hello &lt;b&gt;world!&lt;/b&gt;&quot;);  //Hello world!\n?&gt;\n```\n### ReflectionClass::getConstructor\n-  获取类的构造函数\n- 代码示例\n```\n&lt;?php\n$class = new ReflectionClass(&#039;ReflectionClass&#039;);\n$constructor = $class-&gt;getConstructor();\nvar_dump($constructor);\n?&gt;\n```\n-  输出\n```\nobject(ReflectionMethod)#2 (2) {\n  [&quot;name&quot;]=&gt;\n  string(11) &quot;__construct&quot;\n  [&quot;class&quot;]=&gt;\n  string(15) &quot;ReflectionClass&quot;\n}\n```\n### ReflectionClass\n - 映射类\n- 代码实例\n```\nclass Hello {        //定义一个类\n    static function index() {\n        echo  &#039;hello world&#039;;\n    }\n}\n$class=new ReflectionClass(&#039;Hello&#039;);    //建立 fuc这个类的反射类\nvar_dump($class);\n```\n-  输出\n```\nobject(ReflectionClass)#1 (1) {\n  [&quot;name&quot;]=&gt;\n  string(5) &quot;Hello&quot;\n}\n\n```\n### newInstanceArgs\n- 从给出的参数创建一个新的类实例。\n- code \n```\n&lt;?php\n$class = new ReflectionClass(&#039;ReflectionFunction&#039;);\n$instance = $class-&gt;newInstanceArgs(array(&#039;substr&#039;));\nvar_dump($instance);\n?&gt;\n```\n> - 如果类的构造函数不是 public 的将导致产生一个 ReflectionException。\n> - 当 args 指定了一个或多个参数，而类不具有构造函数时,将导致一个 ReflectionException。\n\n### is_callable()\n-  检测函数是否可以调用 是否合法结构\n-  code \n```\nclass test {\n    static function a() {\n        return &quot;test&quot;;\n    }\n}\n\nclass abc {\n    public function a($Object,$funcName){\n        if (!is_callable(array($Object,$funcName))){\n            echo(&quot;Error&quot;);\n        }else {\n            echo(&quot;OK&quot;);\n        }\n    }\n}\n\n$abc=new abc();\n$abc-&gt;a(&quot;test&quot;,&quot;aa&quot;); //test类下没有aa方法，会输出error\n$abc-&gt;a(&quot;test&quot;,&quot;a&quot;);  //test类下有a方法,会输出ok\n```',0,'http://localhost/qipajun/?p=23',0,'post','',0),
	(25,1,'2017-03-26 13:51:40','2017-03-26 05:51:40','<blockquote>\n  php 内置函数方法使用(2)\n</blockquote>\n\n<ul>\n<li>fastcgi_finish_request</li>\n<li>putenv</li>\n<li>parse_ini_file()</li>\n<li>spl_autoload_unregister</li>\n<li>class_alias</li>\n</ul>\n\n<h2>使用fastcgi_finish_request提高页面响应速度</h2>\n\n<pre><code>当PHP运行在FastCGI模式时,PHP FPM提供了一个名为fastcgi_finish_request的方法.按照文档上的说法,此方法可以提高请求的处理速度,如果有些处理可以在页面生成完后再进行,就可以使用这个方法.\n</code></pre>\n\n<pre><code>    &lt;?php\n\n    echo \'例子：\';\n    fastcgi_finish_request(); /* 响应完成, 关闭连接 */\n\n    /* 记录日志 */\n    file_put_contents(\'log.txt\', \'依然可以输入日志\');\n    ?&gt;\n</code></pre>\n\n<pre><code>    &lt;?php\n\n    echo \'例子：\';\n\n    file_put_contents(\'log.txt\', date(\'Y-m-d H:i:s\') . \" 上传视频\\n\", FILE_APPEND);\n\n    fastcgi_finish_request();\n\n    sleep(1);\n    file_put_contents(\'log.txt\', date(\'Y-m-d H:i:s\') . \" 转换格式\\n\", FILE_APPEND);\n\n    sleep(1);\n    file_put_contents(\'log.txt\', date(\'Y-m-d H:i:s\') . \" 提取图片\\n\", FILE_APPEND);\n\n    ?&gt;\n</code></pre>\n\n<pre><code>    if (!function_exists(\"fastcgi_finish_request\")) {\n          function fastcgi_finish_request()  {\n          }\n    }\n</code></pre>\n\n<h2>putenv</h2>\n\nputenv — 设置环境变量的值\n\n添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。\n\n设置特定的环境变量也有可能是一个潜在的安全漏洞。 safe_mode_allowed_env_vars 包含了一个以逗号分隔的前缀列表。 在安全模式下，用户可以仅能修改用该指令设定的前缀名称的指令。 默认情况下，用户仅能够修改以 PHP_ 开头的环境变量（例如 PHP_FOO=BAR）。 注意：如果此指令是空的，PHP允许用户设定任意环境变量！\n\nsafe_mode_protected_env_vars 指令包含了逗号分隔的环境变量列表，使用户最终无法通过 putenv() 修改。 即使 safe_mode_allowed_env_vars 设置允许修改，这些变量也会被保护。\n\n<h2>parse_ini_file() 函数</h2>\n\nparse_ini_file() 函数解析一个配置文件，并以数组的形式返回其中的设置。\n\n<pre><code>\"test.ini\" 的内容：\n[names]\nme = Robert\nyou = Peter\n\n[urls]\nfirst = \"http://www.example.com\"\nsecond = \"http://www.w3school.com.cn\"\n</code></pre>\n\nPHP 代码：\n\n<pre><code>&lt;?php\nprint_r(parse_ini_file(\"test.ini\"));\n?&gt;\n</code></pre>\n\n输出:\n\n<pre><code>Array\n(\n[me] =&gt; Robert\n[you] =&gt; Peter\n[first] =&gt; http://www.example.com\n[second] =&gt; http://www.w3school.com.cn\n)\n</code></pre>\n\nphp代码\n\n<pre><code>&lt;?php\nprint_r(parse_ini_file(\"test.ini\",true));\n?&gt;\n</code></pre>\n\n输出:\n\n<pre><code>Array\n(\n[names] =&gt; Array\n  (\n  [me] =&gt; Robert\n  [you] =&gt; Peter\n  )\n[urls] =&gt; Array\n  (\n  [first] =&gt; http://www.example.com\n  [second] =&gt; http://www.w3school.com.cn\n  )\n)\n</code></pre>\n\n<h2>spl_autoload_unregister 注销已注册的__autoload()函数</h2>\n\n<pre><code> 从spl提供的自动装载函数栈中注销某一函数。如果该函数栈处于激活状态，并且在给定函数注销后该栈变为空，则该函数栈将会变为无效。\n\n如果该函数注销后使得自动装载函数栈无效，即使存在有__autoload函数它也不会自动激活\n</code></pre>\n\n<h2>class_alias — 为一个类创建别名</h2>\n\n<pre><code>bool class_alias ( string $original , string $alias [, bool $autoload = TRUE ] )\n</code></pre>\n\n基于用户定义的类 original 创建别名 alias。 这个别名类和原有的类完全相同。\n实例\n\n<pre><code>class foo { }\n\nclass_alias(\'foo\', \'bar\'); //给类创建别名\n\n$a = new foo;\n$b = new bar;\n\n// the objects are the same\nvar_dump($a == $b, $a === $b);  //true\nvar_dump($a instanceof $b);     //false\n\n// the classes are the same\nvar_dump($a instanceof foo);       //true\nvar_dump($a instanceof bar);       //true\n\nvar_dump($b instanceof foo);        //true\nvar_dump($b instanceof bar);        //true\n</code></pre>','php内置函数方法使用(2)','','publish','closed','open','','php%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0%e6%96%b9%e6%b3%95%e4%bd%bf%e7%94%a82','','','2017-03-26 13:51:40','2017-03-26 05:51:40','> php 内置函数方法使用(2)\n\n- fastcgi_finish_request\n- putenv\n- parse_ini_file()\n- spl_autoload_unregister\n- class_alias\n\n## 使用fastcgi_finish_request提高页面响应速度 \n    当PHP运行在FastCGI模式时,PHP FPM提供了一个名为fastcgi_finish_request的方法.按照文档上的说法,此方法可以提高请求的处理速度,如果有些处理可以在页面生成完后再进行,就可以使用这个方法.\n```\n    &lt;?php\n     \n    echo &#039;例子：&#039;;\n    fastcgi_finish_request(); /* 响应完成, 关闭连接 */\n     \n    /* 记录日志 */\n    file_put_contents(&#039;log.txt&#039;, &#039;依然可以输入日志&#039;);\n    ?&gt;\n```\n\n```\n    &lt;?php\n     \n    echo &#039;例子：&#039;;\n     \n    file_put_contents(&#039;log.txt&#039;, date(&#039;Y-m-d H:i:s&#039;) . &quot; 上传视频\\n&quot;, FILE_APPEND);\n     \n    fastcgi_finish_request();\n     \n    sleep(1);\n    file_put_contents(&#039;log.txt&#039;, date(&#039;Y-m-d H:i:s&#039;) . &quot; 转换格式\\n&quot;, FILE_APPEND);\n     \n    sleep(1);\n    file_put_contents(&#039;log.txt&#039;, date(&#039;Y-m-d H:i:s&#039;) . &quot; 提取图片\\n&quot;, FILE_APPEND);\n     \n    ?&gt;\n```\n\n```\n    if (!function_exists(&quot;fastcgi_finish_request&quot;)) {\n          function fastcgi_finish_request()  {\n          }\n    }\n```\n\n## putenv\nputenv — 设置环境变量的值\n\n 添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。\n\n设置特定的环境变量也有可能是一个潜在的安全漏洞。 safe_mode_allowed_env_vars 包含了一个以逗号分隔的前缀列表。 在安全模式下，用户可以仅能修改用该指令设定的前缀名称的指令。 默认情况下，用户仅能够修改以 PHP_ 开头的环境变量（例如 PHP_FOO=BAR）。 注意：如果此指令是空的，PHP允许用户设定任意环境变量！\n\nsafe_mode_protected_env_vars 指令包含了逗号分隔的环境变量列表，使用户最终无法通过 putenv() 修改。 即使 safe_mode_allowed_env_vars 设置允许修改，这些变量也会被保护。 \n\n## parse_ini_file() 函数\nparse_ini_file() 函数解析一个配置文件，并以数组的形式返回其中的设置。\n```\n&quot;test.ini&quot; 的内容：\n[names]\nme = Robert\nyou = Peter\n\n[urls]\nfirst = &quot;http://www.example.com&quot;\nsecond = &quot;http://www.w3school.com.cn&quot;\n```\nPHP 代码：\n```\n&lt;?php\nprint_r(parse_ini_file(&quot;test.ini&quot;));\n?&gt;\n```\n输出:\n```\nArray\n(\n[me] =&gt; Robert\n[you] =&gt; Peter\n[first] =&gt; http://www.example.com\n[second] =&gt; http://www.w3school.com.cn\n)\n```\nphp代码\n```\n&lt;?php\nprint_r(parse_ini_file(&quot;test.ini&quot;,true));\n?&gt;\n```\n输出:\n```\nArray\n(\n[names] =&gt; Array\n  (\n  [me] =&gt; Robert\n  [you] =&gt; Peter\n  )\n[urls] =&gt; Array\n  (\n  [first] =&gt; http://www.example.com\n  [second] =&gt; http://www.w3school.com.cn\n  )\n)\n```\n\n## spl_autoload_unregister 注销已注册的__autoload()函数\n     从spl提供的自动装载函数栈中注销某一函数。如果该函数栈处于激活状态，并且在给定函数注销后该栈变为空，则该函数栈将会变为无效。\n\n    如果该函数注销后使得自动装载函数栈无效，即使存在有__autoload函数它也不会自动激活\n##  class_alias — 为一个类创建别名\n```\nbool class_alias ( string $original , string $alias [, bool $autoload = TRUE ] )\n```\n基于用户定义的类 original 创建别名 alias。 这个别名类和原有的类完全相同。\n实例\n```\nclass foo { }\n\nclass_alias(&#039;foo&#039;, &#039;bar&#039;); //给类创建别名\n\n$a = new foo;\n$b = new bar;\n\n// the objects are the same\nvar_dump($a == $b, $a === $b);  //true\nvar_dump($a instanceof $b);     //false\n\n// the classes are the same\nvar_dump($a instanceof foo);       //true\nvar_dump($a instanceof bar);       //true\n\nvar_dump($b instanceof foo);        //true\nvar_dump($b instanceof bar);        //true\n```',0,'http://localhost/qipajun/?p=25',0,'post','',0),
	(27,1,'2017-03-26 13:51:40','2017-03-26 05:51:40','<h1>thinkphp框架浅析(一) :   url路由解析到类映射实例化加载原理剖析</h1>\n\n<ul>\n<li>源码解读通过thinkphp test控制器test方法 探究thinkphp运行处理流程</li>\n<li>路径: thinkphp_5.0.7_core/application/index/controller/test.php</li>\n</ul>\n\n<pre><code>&lt;?php\nnamespace app\\index\\controller;\nuse think\\Controller;\nclass Test extends Controller\n{\n\n    public function __construct()\n    {\n        parent::__construct();\n    }\n\n    public function index()\n    {\n        echo \'test/index\';\n    }\n\n    public function test(){\n        return \'hello word\';\n    }\n}\n</code></pre>\n\n<code>基于最新版thinkphp_5.0.7_core</code>\n\n<blockquote>\n  <ul>\n  <li>url访问<code>http://localhost/thinkphp_5.0.7_core/public/index.php/test/test</code> 入口文件 <code>index.php</code></li>\n  </ul>\n</blockquote>\n\n<pre><code>require __DIR__ . \'/../thinkphp/start.php\';\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>加载基础文件</li>\n  </ul>\n</blockquote>\n\n<pre><code>require __DIR__ . \'/base.php\';\n// 这一步定义系统常量 环境变量 加载自动加载 、错误异常处理类 配置文件等\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>加载完 集训执行 start.php 应用执行</li>\n  </ul>\n</blockquote>\n\n<pre><code>App::run()-&gt;send();\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>App::run() \n  进入run方法以后首先是一个try catch\n  try中先是 初始化应用 <code>self::initCommon();</code> 、绑定默认路由参数 </li>\n  <li>> 设置或获取当前的过滤规则 <code>$request-&gt;filter($config[\'default_filter\']);</code>  </li>\n  <li>>  语言设置 </li>\n  <li>>  url调度  </li>\n  <li>> url 路由检测 <code>self::routeCheck($request, $config);</code>  </li>\n  <li>> 通过  <code>$request-&gt;path();</code>  获取请求路径信息  返回<code>test/test</code></li>\n  <li>> 路由检测  （根据路由定义返回不同的URL调度） <code>Route::check($request, $path, $depr, $config[\'url_domain_deploy\']);</code></li>\n  <li>> 路由无效或未配置下执行 (解析模块/控制器/操作/参数... 支持控制器自动搜索) \n  <code>Route::parseUrl($path, $depr, $config[\'controller_auto_search\']);</code>\n  此处默认返回格式</li>\n  </ul>\n</blockquote>\n\n<pre><code>array (size=2)\n  \'type\' =&gt; string \'module\' (length=6)\n  \'module\' =&gt; \n    array (size=3)\n      0 =&gt; string \'index\' (length=5)\n      1 =&gt; string \'test\' (length=4)\n      2 =&gt; string \'test\' (length=4)\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>返回run方法接着执行 </li>\n  <li>记录当前调度信息 <code>$request-&gt;dispatch($dispatch);</code></li>\n  <li>记录路由和请求信息<code>Log::record</code></li>\n  <li>监听app_begin <code>Hook::listen</code> </li>\n  <li>请求缓存检查</li>\n  <li>根据<code>$dispatch[\'type\']</code> 获取内容 这里默认是<code>module</code>  执行\n  <code>$data = self::module($dispatch[\'module\'], $config, isset($dispatch[\'convert\']) ? $dispatch[\'convert\'] : null);</code></li>\n  <li>model 方法中 <code>Loader::controller</code> 进入执行  组合class命名空间路径  这里$class = <code>\'app\\index\\controller\\Test\'</code></li>\n  <li><code>App::invokeClass($class);</code></li>\n  <li>反射实例化类 </li>\n  </ul>\n</blockquote>\n\n<pre><code>        $reflect     = new \\ReflectionClass($class);   //反射类\n        $constructor = $reflect-&gt;getConstructor(); //初始构造方法\n        if ($constructor) {\n            $args = self::bindParams($constructor, $vars);\n        } else {\n            $args = [];\n        }\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>获取内容方法 \n  <code>$reflect-&gt;newInstanceArgs($args);</code> //这里就返回了 控制器输出的内容 <code>hello wolrd</code></li>\n  <li><code>$data = self::module</code>  module绑定发调用控制器空 返回的就是方法<code>index/test/test</code>返回的内容了  </li>\n  <li>response 处理 </li>\n  <li>监听app_end\n  返回 response\n  app send 方法将内容返回给用户 <code>App::run()-&gt;send();</code></li>\n  </ul>\n</blockquote>','thinkphp框架源码浅析(一)','','publish','closed','open','','thinkphp%e6%a1%86%e6%9e%b6%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90%e4%b8%80','','','2017-03-26 13:51:40','2017-03-26 05:51:40','# thinkphp框架浅析(一) :   url路由解析到类映射实例化加载原理剖析\n- 源码解读通过thinkphp test控制器test方法 探究thinkphp运行处理流程\n- 路径: thinkphp_5.0.7_core/application/index/controller/test.php\n```\n&lt;?php\nnamespace app\\index\\controller;\nuse think\\Controller;\nclass Test extends Controller\n{\n\n    public function __construct()\n    {\n        parent::__construct();\n    }\n\n    public function index()\n    {\n        echo &#039;test/index&#039;;\n    }\n\n    public function test(){\n        return &#039;hello word&#039;;\n    }\n}\n```\n  `基于最新版thinkphp_5.0.7_core`\n> - url访问`http://localhost/thinkphp_5.0.7_core/public/index.php/test/test` 入口文件 `index.php`\n```\nrequire __DIR__ . &#039;/../thinkphp/start.php&#039;;\n```\n> -  加载基础文件\n```\nrequire __DIR__ . &#039;/base.php&#039;;\n// 这一步定义系统常量 环境变量 加载自动加载 、错误异常处理类 配置文件等\n```\n> - 加载完 集训执行 start.php 应用执行\n```\nApp::run()-&gt;send();\n```\n> - App::run() \n进入run方法以后首先是一个try catch\ntry中先是 初始化应用 `self::initCommon(); ` 、绑定默认路由参数 \n> -  > 设置或获取当前的过滤规则 ` $request->filter($config[\'default_filter\']);`  \n> -  >  语言设置 \n> -  >  url调度  \n> -  > url 路由检测 `self::routeCheck($request, $config);`  \n> -  > 通过  `$request->path();`  获取请求路径信息  返回`test/test`\n> - > 路由检测  （根据路由定义返回不同的URL调度） `Route::check($request, $path, $depr, $config[\'url_domain_deploy\']);`\n> - > 路由无效或未配置下执行 (解析模块/控制器/操作/参数... 支持控制器自动搜索) \n`Route::parseUrl($path, $depr, $config[\'controller_auto_search\']);`\n此处默认返回格式\n```\narray (size=2)\n  &#039;type&#039; =&gt; string &#039;module&#039; (length=6)\n  &#039;module&#039; =&gt; \n    array (size=3)\n      0 =&gt; string &#039;index&#039; (length=5)\n      1 =&gt; string &#039;test&#039; (length=4)\n      2 =&gt; string &#039;test&#039; (length=4)\n```\n> - 返回run方法接着执行 \n> - 记录当前调度信息 `$request->dispatch($dispatch); `\n> - 记录路由和请求信息`Log::record`\n> -  监听app_begin `Hook::listen` \n> - 请求缓存检查\n> - 根据`$dispatch[\'type\']` 获取内容 这里默认是`module`  执行\n`$data = self::module($dispatch[\'module\'], $config, isset($dispatch[\'convert\']) ? $dispatch[\'convert\'] : null);`\n> - model 方法中 `Loader::controller` 进入执行  组合class命名空间路径  这里$class = `\'app\\index\\controller\\Test\'`\n> - `App::invokeClass($class);`\n> -  反射实例化类 \n```\n        $reflect     = new \\ReflectionClass($class);   //反射类\n        $constructor = $reflect-&gt;getConstructor(); //初始构造方法\n        if ($constructor) {\n            $args = self::bindParams($constructor, $vars);\n        } else {\n            $args = [];\n        }\n```\n> - 获取内容方法 \n`$reflect->newInstanceArgs($args);` //这里就返回了 控制器输出的内容 `hello wolrd`\n > - ` $data = self::module`  module绑定发调用控制器空 返回的就是方法`index/test/test`返回的内容了  \n > - response 处理 \n > - 监听app_end\n >  返回 response\n >  app send 方法将内容返回给用户 `App::run()->send();`',0,'http://localhost/qipajun/?p=27',0,'post','',0),
	(29,1,'2017-03-26 13:51:41','2017-03-26 05:51:41','<h1>REDIS SortedSet</h1>\n\n<h3>ZADD</h3>\n\n<ul>\n<li>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li>\n<li>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</li>\n<li>score 值可以是整数值或双精度浮点数。</li>\n<li>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</li>\n<li>当 key 存在但不是有序集类型时，返回一个错误。</li>\n</ul>\n\n<pre><code># 添加单个元素\n\nredis&gt; ZADD page_rank 10 google.com\n(integer) 1\n\n\n# 添加多个元素\n\nredis&gt; ZADD page_rank 9 baidu.com 8 bing.com\n(integer) 2\n\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES\n1) \"bing.com\"\n2) \"8\"\n3) \"baidu.com\"\n4) \"9\"\n5) \"google.com\"\n6) \"10\"\n\n\n# 添加已存在元素，且 score 值不变\n\nredis&gt; ZADD page_rank 10 google.com\n(integer) 0\n\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变\n1) \"bing.com\"\n2) \"8\"\n3) \"baidu.com\"\n4) \"9\"\n5) \"google.com\"\n6) \"10\"\n\n\n# 添加已存在元素，但是改变 score 值\n\nredis&gt; ZADD page_rank 6 bing.com\n(integer) 0\n\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变\n1) \"bing.com\"\n2) \"6\"\n3) \"baidu.com\"\n4) \"9\"\n5) \"google.com\"\n6) \"10\"\n</code></pre>\n\n<h3>ZCARD</h3>\n\n<ul>\n<li>返回有续集key的基数</li>\n</ul>\n\n<pre><code>redis &gt; ZADD salary 2000 tom    # 添加一个成员\n(integer) 1\n\nredis &gt; ZCARD salary\n(integer) 1\n\nredis &gt; ZADD salary 5000 jack   # 再添加一个成员\n(integer) 1\n\nredis &gt; ZCARD salary\n(integer) 2\n\nredis &gt; EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作\n(integer) 0\n\nredis &gt; ZCARD non_exists_key\n(integer) 0\n</code></pre>\n\n<h3>ZCOUNT</h3>\n\n<ul>\n<li>返回游戏集key中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量</li>\n<li>返回score 值在 min 和 max 之间的成员的数量。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; zadd salary 2000 \"jack\"\n(integer) 1\n127.0.0.1:6379&gt; zadd salary 2500 \"peter\"\n(integer) 1\n127.0.0.1:6379&gt; zadd salary 5000 \"tom\"\n(integer) 1\n127.0.0.1:6379&gt; zcount salary 2000 5000\n(integer) 3\n127.0.0.1:6379&gt; zcount salary 3000 5000\n(integer) 1\n</code></pre>\n\n<h3>ZINCRBY</h3>\n\n<ul>\n<li>为有序集 key 的成员 member 的 score 值加上增量 increment</li>\n<li>可以传递负数</li>\n<li>key不存在时 ZINCRBY key increment member 等同于 ZADD key increment member</li>\n<li>当 key 不是有序集类型时，返回一个错误</li>\n<li>score 值可以是整数值或双精度浮点数</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt;  ZSCORE salary tom\n\"5000\"\n127.0.0.1:6379&gt; ZINCRBY salary 2000 tom\n\"7000\"\n</code></pre>\n\n<h3>ZRANGE</h3>\n\n<ul>\n<li>返回有序集 key 中，指定区间内的成员</li>\n<li>其中成员的位置按 score 值递增(从小到大)来排序</li>\n<li>具有相同 score 值的成员按字典序(lexicographical order )来排列</li>\n<li>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES //显示整个有序集成员\n1) \"jack\"\n2) \"2000\"\n3) \"peter\"\n4) \"2500\"\n5) \"tom\"\n6) \"7000\"\n127.0.0.1:6379&gt; ZRANGE salary 1 2 WITHSCORES //显示有序集下标区间1至2的成员\n1) \"peter\"\n2) \"2500\"\n3) \"tom\"\n4) \"7000\"\n127.0.0.1:6379&gt; ZRANGE salary 0 200000 WITHSCORES  //测试超出最大下标情况\n1) \"jack\"\n2) \"2000\"\n3) \"peter\"\n4) \"2500\"\n5) \"tom\"\n6) \"7000\"\n127.0.0.1:6379&gt;  ZRANGE salary 200000 3000000 WITHSCORES //测试不再区间的集合情况\n(empty list or set)\n</code></pre>\n\n<h3>ZRANGEBYSCORE</h3>\n\n<ul>\n<li>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</li>\n<li>具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</li>\n<li>可使用limit参数  像SQL中的 SELECT LIMIT offset, count  注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间</li>\n<li>可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回</li>\n<li></li>\n</ul>\n\n<pre><code>redis&gt; ZADD salary 2500 jack                        # 测试数据\n(integer) 0\nredis&gt; ZADD salary 5000 tom\n(integer) 0\nredis&gt; ZADD salary 12000 peter\n(integer) 0\n\nredis&gt; ZRANGEBYSCORE salary -inf +inf               # 显示整个有序集\n1) \"jack\"\n2) \"tom\"\n3) \"peter\"\n\nredis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    # 显示整个有序集及成员的 score 值\n1) \"jack\"\n2) \"2500\"\n3) \"tom\"\n4) \"5000\"\n5) \"peter\"\n6) \"12000\"\n\nredis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    # 显示工资 &lt;=5000 的所有成员\n1) \"jack\"\n2) \"2500\"\n3) \"tom\"\n4) \"5000\"\n\nredis&gt; ZRANGEBYSCORE salary (5000 400000            # 显示工资大于 5000 小于等于 400000 的成员\n1) \"peter\"\nindexnext\n</code></pre>\n\n<h3>ZRANK</h3>\n\n<ul>\n<li>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</li>\n<li>排名以 0 为底，也就是说， score 值最小的成员排名为 0 </li>\n<li>使用 ZREVRANK 命令可以获得成员按 score 值递减(从大到小)排列的排名</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES   # 显示所有成员及其 score 值\n1) \"jack\"\n2) \"2500\"\n3) \"tom\"\n4) \"5000\"\n5) \"peter\"\n6) \"12000\"\n127.0.0.1:6379&gt; ZRANK salary tom    # 显示 tom 的薪水排名，第二 下表0开始计算\n(integer) 1\n127.0.0.1:6379&gt; ZRANK salary jack\n(integer) 0\n127.0.0.1:6379&gt; zrank salary peter\n(integer) 2\n</code></pre>\n\n<h3>ZREM</h3>\n\n<ul>\n<li>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略</li>\n<li>当 key 存在但不是有序集类型时，返回一个错误</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; zadd page_rank 8 \"bing.com\"\n(integer) 1\n127.0.0.1:6379&gt; zadd page_rank 9 \"google.com\"\n(integer) 1\n127.0.0.1:6379&gt; zadd page_rank 10 \"baidu.com\"\n(integer) 1\n127.0.0.1:6379&gt; ZREM page_rank google.com   #移除单个元素\n(integer) 1\n127.0.0.1:6379&gt; ZRANGE page_rank 0 -1 WITHSCORES\n1) \"bing.com\"\n2) \"8\"\n3) \"baidu.com\"\n4) \"10\"\n127.0.0.1:6379&gt;  ZREM page_rank baidu.com bing.com  #移除多个元素\n(integer) 2\n127.0.0.1:6379&gt; ZRANGE page_rank 0 -1 WITHSCORES \n(empty list or set)\n127.0.0.1:6379&gt; ZREM page_rank non-exists-element   # 移除不存在元素\n(integer) 0\n</code></pre>\n\n<h3>ZREMRANGEBYRANK</h3>\n\n<ul>\n<li>移除有序集 key 中，指定排名(rank)区间内的所有成员</li>\n<li>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; ZADD salary 2000 jack\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 5000 tom\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 3500 peter\n(integer) 1\n127.0.0.1:6379&gt; ZREMRANGEBYRANK salary 0 1 # 移除下标 0 至 1 区间内的成员\n(integer) 2\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES # 有序集只剩下一个成员\n1) \"tom\"\n2) \"5000\"\n</code></pre>\n\n<h3>ZREMRANGEBYSCORE</h3>\n\n<ul>\n<li>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES  # 显示有序集内所有成员及其 score 值\n1) \"tom\"\n2) \"2000\"\n3) \"peter\"\n4) \"3500\"\n5) \"jack\"\n6) \"5000\"\n127.0.0.1:6379&gt; ZREMRANGEBYSCORE salary 1500 3500 # 移除所有薪水在 1500 到 3500 内的员工\n(integer) 2\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES # 剩下的有序集成员\n1) \"jack\"\n2) \"5000\"\n</code></pre>\n\n<h3>ZREVRANGE</h3>\n\n<ul>\n<li>返回有序集 key 中，指定区间内的成员</li>\n<li>其中成员的位置按 score 值递减(从大到小)来排列</li>\n<li>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES  # 递增排列\n1) \"tom\"\n2) \"2000\"\n3) \"peter\"\n4) \"3500\"\n5) \"jack\"\n6) \"5000\"\n127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 WITHSCORES # 递减排列\n1) \"jack\"\n2) \"5000\"\n3) \"peter\"\n4) \"3500\"\n5) \"tom\"\n6) \"2000\"\n</code></pre>\n\n<h3>ZREVRANGEBYSCORE</h3>\n\n<ul>\n<li>返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列</li>\n<li>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; ZADD salary 10086 jack\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 5000 tom\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 7500 peter\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 3500 joe\n(integer) 1\n127.0.0.1:6379&gt; ZREVRANGEBYSCORE salary +inf -inf # 逆序排列所有成员\n1) \"jack\"\n2) \"peter\"\n3) \"tom\"\n4) \"joe\"\n127.0.0.1:6379&gt; ZREVRANGEBYSCORE salary 10000 2000 # 逆序排列薪水介于 10000 和 2000 之间的成员\n1) \"peter\"\n2) \"tom\"\n3) \"joe\"\n</code></pre>\n\n<h3>ZREVRANK</h3>\n\n<ul>\n<li>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES\n1) \"joe\"\n2) \"3500\"\n3) \"tom\"\n4) \"5000\"\n5) \"peter\"\n6) \"7500\"\n7) \"jack\"\n8) \"10086\"\n127.0.0.1:6379&gt; ZREVRANK salary peter # peter 的工资排第二 下标从0开始\n(integer) 1\n127.0.0.1:6379&gt; ZREVRANK salary tom\n(integer) 2\n</code></pre>\n\n<h3>ZSCORE</h3>\n\n<ul>\n<li>返回有序集 key 中，成员 member 的 score 值</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES # 测试数据\n1) \"joe\"\n2) \"3500\"\n3) \"tom\"\n4) \"5000\"\n5) \"peter\"\n6) \"7500\"\n7) \"jack\"\n8) \"10086\"\n127.0.0.1:6379&gt; ZSCORE salary peter  # 注意返回值是字符串\n\"7500\"\n</code></pre>','redis SortedSet','','publish','closed','open','','redis-sortedset','','','2017-03-26 13:51:41','2017-03-26 05:51:41','# REDIS SortedSet \n### ZADD\n- 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。\n- 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。\n- score 值可以是整数值或双精度浮点数。\n- 如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。\n- 当 key 存在但不是有序集类型时，返回一个错误。\n```\n# 添加单个元素\n\nredis&gt; ZADD page_rank 10 google.com\n(integer) 1\n\n\n# 添加多个元素\n\nredis&gt; ZADD page_rank 9 baidu.com 8 bing.com\n(integer) 2\n\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES\n1) &quot;bing.com&quot;\n2) &quot;8&quot;\n3) &quot;baidu.com&quot;\n4) &quot;9&quot;\n5) &quot;google.com&quot;\n6) &quot;10&quot;\n\n\n# 添加已存在元素，且 score 值不变\n\nredis&gt; ZADD page_rank 10 google.com\n(integer) 0\n\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变\n1) &quot;bing.com&quot;\n2) &quot;8&quot;\n3) &quot;baidu.com&quot;\n4) &quot;9&quot;\n5) &quot;google.com&quot;\n6) &quot;10&quot;\n\n\n# 添加已存在元素，但是改变 score 值\n\nredis&gt; ZADD page_rank 6 bing.com\n(integer) 0\n\nredis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变\n1) &quot;bing.com&quot;\n2) &quot;6&quot;\n3) &quot;baidu.com&quot;\n4) &quot;9&quot;\n5) &quot;google.com&quot;\n6) &quot;10&quot;\n```\n### ZCARD\n- 返回有续集key的基数\n```\nredis &gt; ZADD salary 2000 tom    # 添加一个成员\n(integer) 1\n\nredis &gt; ZCARD salary\n(integer) 1\n\nredis &gt; ZADD salary 5000 jack   # 再添加一个成员\n(integer) 1\n\nredis &gt; ZCARD salary\n(integer) 2\n\nredis &gt; EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作\n(integer) 0\n\nredis &gt; ZCARD non_exists_key\n(integer) 0\n```\n\n### ZCOUNT\n- 返回游戏集key中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量\n- 返回score 值在 min 和 max 之间的成员的数量。\n```\n127.0.0.1:6379&gt; zadd salary 2000 &quot;jack&quot;\n(integer) 1\n127.0.0.1:6379&gt; zadd salary 2500 &quot;peter&quot;\n(integer) 1\n127.0.0.1:6379&gt; zadd salary 5000 &quot;tom&quot;\n(integer) 1\n127.0.0.1:6379&gt; zcount salary 2000 5000\n(integer) 3\n127.0.0.1:6379&gt; zcount salary 3000 5000\n(integer) 1\n```\n### ZINCRBY\n- 为有序集 key 的成员 member 的 score 值加上增量 increment\n- 可以传递负数\n- key不存在时 ZINCRBY key increment member 等同于 ZADD key increment member\n- 当 key 不是有序集类型时，返回一个错误\n- score 值可以是整数值或双精度浮点数\n```\n127.0.0.1:6379&gt;  ZSCORE salary tom\n&quot;5000&quot;\n127.0.0.1:6379&gt; ZINCRBY salary 2000 tom\n&quot;7000&quot;\n```\n### ZRANGE\n- 返回有序集 key 中，指定区间内的成员\n- 其中成员的位置按 score 值递增(从小到大)来排序\n- 具有相同 score 值的成员按字典序(lexicographical order )来排列\n- 如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE 命令\n\n```\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES //显示整个有序集成员\n1) &quot;jack&quot;\n2) &quot;2000&quot;\n3) &quot;peter&quot;\n4) &quot;2500&quot;\n5) &quot;tom&quot;\n6) &quot;7000&quot;\n127.0.0.1:6379&gt; ZRANGE salary 1 2 WITHSCORES //显示有序集下标区间1至2的成员\n1) &quot;peter&quot;\n2) &quot;2500&quot;\n3) &quot;tom&quot;\n4) &quot;7000&quot;\n127.0.0.1:6379&gt; ZRANGE salary 0 200000 WITHSCORES  //测试超出最大下标情况\n1) &quot;jack&quot;\n2) &quot;2000&quot;\n3) &quot;peter&quot;\n4) &quot;2500&quot;\n5) &quot;tom&quot;\n6) &quot;7000&quot;\n127.0.0.1:6379&gt;  ZRANGE salary 200000 3000000 WITHSCORES //测试不再区间的集合情况\n(empty list or set)\n```\n### ZRANGEBYSCORE\n- 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。\n- 具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。\n- 可使用limit参数  像SQL中的 SELECT LIMIT offset, count  注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间\n- 可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回\n- \n```\nredis&gt; ZADD salary 2500 jack                        # 测试数据\n(integer) 0\nredis&gt; ZADD salary 5000 tom\n(integer) 0\nredis&gt; ZADD salary 12000 peter\n(integer) 0\n\nredis&gt; ZRANGEBYSCORE salary -inf +inf               # 显示整个有序集\n1) &quot;jack&quot;\n2) &quot;tom&quot;\n3) &quot;peter&quot;\n\nredis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    # 显示整个有序集及成员的 score 值\n1) &quot;jack&quot;\n2) &quot;2500&quot;\n3) &quot;tom&quot;\n4) &quot;5000&quot;\n5) &quot;peter&quot;\n6) &quot;12000&quot;\n\nredis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    # 显示工资 &lt;=5000 的所有成员\n1) &quot;jack&quot;\n2) &quot;2500&quot;\n3) &quot;tom&quot;\n4) &quot;5000&quot;\n\nredis&gt; ZRANGEBYSCORE salary (5000 400000            # 显示工资大于 5000 小于等于 400000 的成员\n1) &quot;peter&quot;\nindexnext\n```\n### ZRANK\n- 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。\n- 排名以 0 为底，也就是说， score 值最小的成员排名为 0 \n- 使用 ZREVRANK 命令可以获得成员按 score 值递减(从大到小)排列的排名\n\n```\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES   # 显示所有成员及其 score 值\n1) &quot;jack&quot;\n2) &quot;2500&quot;\n3) &quot;tom&quot;\n4) &quot;5000&quot;\n5) &quot;peter&quot;\n6) &quot;12000&quot;\n127.0.0.1:6379&gt; ZRANK salary tom    # 显示 tom 的薪水排名，第二 下表0开始计算\n(integer) 1\n127.0.0.1:6379&gt; ZRANK salary jack\n(integer) 0\n127.0.0.1:6379&gt; zrank salary peter\n(integer) 2\n```\n### ZREM\n- 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略\n- 当 key 存在但不是有序集类型时，返回一个错误\n```\n127.0.0.1:6379&gt; zadd page_rank 8 &quot;bing.com&quot;\n(integer) 1\n127.0.0.1:6379&gt; zadd page_rank 9 &quot;google.com&quot;\n(integer) 1\n127.0.0.1:6379&gt; zadd page_rank 10 &quot;baidu.com&quot;\n(integer) 1\n127.0.0.1:6379&gt; ZREM page_rank google.com   #移除单个元素\n(integer) 1\n127.0.0.1:6379&gt; ZRANGE page_rank 0 -1 WITHSCORES\n1) &quot;bing.com&quot;\n2) &quot;8&quot;\n3) &quot;baidu.com&quot;\n4) &quot;10&quot;\n127.0.0.1:6379&gt;  ZREM page_rank baidu.com bing.com  #移除多个元素\n(integer) 2\n127.0.0.1:6379&gt; ZRANGE page_rank 0 -1 WITHSCORES \n(empty list or set)\n127.0.0.1:6379&gt; ZREM page_rank non-exists-element   # 移除不存在元素\n(integer) 0\n```\n### ZREMRANGEBYRANK\n- 移除有序集 key 中，指定排名(rank)区间内的所有成员\n- 区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内\n```\n127.0.0.1:6379&gt; ZADD salary 2000 jack\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 5000 tom\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 3500 peter\n(integer) 1\n127.0.0.1:6379&gt; ZREMRANGEBYRANK salary 0 1 # 移除下标 0 至 1 区间内的成员\n(integer) 2\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES # 有序集只剩下一个成员\n1) &quot;tom&quot;\n2) &quot;5000&quot;\n```\n### ZREMRANGEBYSCORE\n- 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员\n```\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES  # 显示有序集内所有成员及其 score 值\n1) &quot;tom&quot;\n2) &quot;2000&quot;\n3) &quot;peter&quot;\n4) &quot;3500&quot;\n5) &quot;jack&quot;\n6) &quot;5000&quot;\n127.0.0.1:6379&gt; ZREMRANGEBYSCORE salary 1500 3500 # 移除所有薪水在 1500 到 3500 内的员工\n(integer) 2\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES # 剩下的有序集成员\n1) &quot;jack&quot;\n2) &quot;5000&quot;\n```\n### ZREVRANGE\n- 返回有序集 key 中，指定区间内的成员\n- 其中成员的位置按 score 值递减(从大到小)来排列\n- 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列\n```\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES  # 递增排列\n1) &quot;tom&quot;\n2) &quot;2000&quot;\n3) &quot;peter&quot;\n4) &quot;3500&quot;\n5) &quot;jack&quot;\n6) &quot;5000&quot;\n127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 WITHSCORES # 递减排列\n1) &quot;jack&quot;\n2) &quot;5000&quot;\n3) &quot;peter&quot;\n4) &quot;3500&quot;\n5) &quot;tom&quot;\n6) &quot;2000&quot;\n```\n### ZREVRANGEBYSCORE\n- 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列\n- 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列\n```\n127.0.0.1:6379&gt; ZADD salary 10086 jack\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 5000 tom\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 7500 peter\n(integer) 1\n127.0.0.1:6379&gt; ZADD salary 3500 joe\n(integer) 1\n127.0.0.1:6379&gt; ZREVRANGEBYSCORE salary +inf -inf # 逆序排列所有成员\n1) &quot;jack&quot;\n2) &quot;peter&quot;\n3) &quot;tom&quot;\n4) &quot;joe&quot;\n127.0.0.1:6379&gt; ZREVRANGEBYSCORE salary 10000 2000 # 逆序排列薪水介于 10000 和 2000 之间的成员\n1) &quot;peter&quot;\n2) &quot;tom&quot;\n3) &quot;joe&quot;\n```\n### ZREVRANK\n- 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序\n```\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES\n1) &quot;joe&quot;\n2) &quot;3500&quot;\n3) &quot;tom&quot;\n4) &quot;5000&quot;\n5) &quot;peter&quot;\n6) &quot;7500&quot;\n7) &quot;jack&quot;\n8) &quot;10086&quot;\n127.0.0.1:6379&gt; ZREVRANK salary peter # peter 的工资排第二 下标从0开始\n(integer) 1\n127.0.0.1:6379&gt; ZREVRANK salary tom\n(integer) 2\n```\n### ZSCORE\n- 返回有序集 key 中，成员 member 的 score 值\n```\n127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES # 测试数据\n1) &quot;joe&quot;\n2) &quot;3500&quot;\n3) &quot;tom&quot;\n4) &quot;5000&quot;\n5) &quot;peter&quot;\n6) &quot;7500&quot;\n7) &quot;jack&quot;\n8) &quot;10086&quot;\n127.0.0.1:6379&gt; ZSCORE salary peter  # 注意返回值是字符串\n&quot;7500&quot;\n```',0,'http://localhost/qipajun/?p=29',0,'post','',0),
	(31,1,'2017-03-26 13:51:41','2017-03-26 05:51:41','<h1>REDIS Sting</h1>\n\n<h3>APPEND</h3>\n\n<ul>\n<li>如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</li>\n<li>如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; EXISTS myphone\n(integer) 0\n# 对不存在的key进行append 等同直接set\n127.0.0.1:6379&gt; APPEND myphone \"nokia\"\n(integer) 5\n#对存在的keyappend 直接追加后边\n127.0.0.1:6379&gt; APPEND myphone \" - 1110\"\n(integer) 12\n127.0.0.1:6379&gt; GET myphone\n\"nokia - 1110\"\n</code></pre>\n\n<h3>APPEND timeseries</h3>\n\n<ul>\n<li>APPEND 可以为一系列定长(fixed-size)数据(sample)提供一种紧凑的表示方式，通常称之为时间序列。\n<code>APPEND timeseries \"fixed-size sample\"</code></li>\n<li>可以考虑使用 UNIX 时间戳作为时间序列的键名，这样一来，可以避免单个 key 因为保存过大的时间序列而占用大量内存，另一方面，也可以节省下大量命名空间。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; APPEND ts \"0043\"\n(integer) 4\n127.0.0.1:6379&gt; APPEND ts \"0035\"\n(integer) 8\n127.0.0.1:6379&gt;  GETRANGE ts 0 3\n\"0043\"\n127.0.0.1:6379&gt; GETRANGE ts 4 7\n\"0035\"\n</code></pre>\n\n<h3>DECR</h3>\n\n<ul>\n<li>将 key 中储存的数字值减一</li>\n<li>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。</li>\n<li>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</li>\n<li>值限制在 64 位(bit)有符号数字表示之内。</li>\n</ul>\n\n<pre><code>#对存在的数字值 key 进行 DECR\n127.0.0.1:6379&gt; SET failure_times 10\nOK\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 9\n\n# 对不存在的key进行DECR\n127.0.0.1:6379&gt; EXISTS count\n(integer) 0\n127.0.0.1:6379&gt; DECR count\n(integer) -1\n\n# 对存在但不是数值的 key 进行 DECR\n127.0.0.1:6379&gt; SET company YOUR_CODE_SUCKS.LLC\nOK\n127.0.0.1:6379&gt; DECR company\n(error) ERR value is not an integer or out of range\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 8\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 7\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 6\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 5\n</code></pre>\n\n<h3>DECRBY</h3>\n\n<ul>\n<li>将 key 所储存的值减去减量 decrement 。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET count 100\nOK\n127.0.0.1:6379&gt; DECRBY count 20\n(integer) 80\n# 不存在的key\n127.0.0.1:6379&gt; EXISTS pages\n(integer) 0\n127.0.0.1:6379&gt; DECRBY pages 10\n(integer) -10\n</code></pre>\n\n<h3>GET</h3>\n\n<ul>\n<li>返回key所关联的字符串值</li>\n</ul>\n\n<h3>GETBIT</h3>\n\n<ul>\n<li>对key所存储的字符串值，获取指定偏移量上的位(bit)</li>\n<li>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 </li>\n</ul>\n\n<pre><code>对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0\n127.0.0.1:6379&gt; EXISTS bit\n(integer) 0\n127.0.0.1:6379&gt; GETBIT bit 10086\n(integer) 0\n# 对已存在的 offset 进行 GETBIT\n127.0.0.1:6379&gt; SETBIT bit 10086 1\n(integer) 0\n127.0.0.1:6379&gt;  GETBIT bit 10086\n(integer) 1\n</code></pre>\n\n<h3>GETSET</h3>\n\n<ul>\n<li>将给定 key 的值设为 value ，并返回 key 的旧值(old value)</li>\n<li>当 key 存在但不是字符串类型时，返回一个错误</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; GETSET db mongodb\n(nil)\n127.0.0.1:6379&gt; GET db\n\"mongodb\"\n127.0.0.1:6379&gt; GETSET db redis\n\"mongodb\"\n127.0.0.1:6379&gt; GET db\n\"redis\"\n127.0.0.1:6379&gt;\n\n# \n127.0.0.1:6379&gt; INCR mycount\n(integer) 1\n127.0.0.1:6379&gt; GETSET mycount 0\n\"1\"\n127.0.0.1:6379&gt; GET mycount\n\"0\"\n</code></pre>\n\n<h3>INCR</h3>\n\n<ul>\n<li>将key中存储的数字增加一</li>\n</ul>\n\n<pre><code>\"0\"\n127.0.0.1:6379&gt; set age 20\nOK\n127.0.0.1:6379&gt; incr age\n(integer) 21\n127.0.0.1:6379&gt; get age\n\"21\"\n</code></pre>\n\n<h3>INCRBY</h3>\n\n<ul>\n<li>将key所存储的值增加增量</li>\n</ul>\n\n<pre><code>#key 存在且是数字\n127.0.0.1:6379&gt;  SET rank 50\nOK\n127.0.0.1:6379&gt; INCRBY rank 20\n(integer) 70\n#key不存在\n127.0.0.1:6379&gt;  GET rank\n\"70\"\n127.0.0.1:6379&gt; EXISTS counter\n(integer) 0\n127.0.0.1:6379&gt; INCRBY counter 30\n(integer) 30\n127.0.0.1:6379&gt; GET counter\n\"30\"\n#eky存在不是数字\n127.0.0.1:6379&gt; SET book \"long long ago...\"\nOK\n127.0.0.1:6379&gt;  INCRBY book 200\n(error) ERR value is not an integer or out of range\n</code></pre>\n\n<h3>INCRBYFLOAT</h3>\n\n<ul>\n<li>为 key 中所储存的值加上浮点数增量</li>\n</ul>\n\n<pre><code># 值和增量都不是指数符号\n127.0.0.1:6379&gt; SET mykey 10.50\nOK\n127.0.0.1:6379&gt; INCRBYFLOAT mykey 0.1\n\"10.6\"\n# 值和增量都是指数符号\n127.0.0.1:6379&gt; SET mykey 314e-2\nOK\n127.0.0.1:6379&gt; GET mykey\n\"314e-2\"\n127.0.0.1:6379&gt; INCRBYFLOAT mykey 0\n\"3.14\"\n# 可以对整数类型执行\n127.0.0.1:6379&gt; SET mykey 3\nOK\n127.0.0.1:6379&gt; INCRBYFLOAT mykey 1.1\n\"4.1\"\n# 后跟的 0 会被移除\n127.0.0.1:6379&gt; SET mykey 3.0\nOK\n127.0.0.1:6379&gt; GET mykey\n\"3.0\"\n127.0.0.1:6379&gt; INCRBYFLOAT mykey 1.000000000000000000000\n\"4\"\n127.0.0.1:6379&gt; GET mykey\n\"4\"\n</code></pre>\n\n<h3>MGET</h3>\n\n<ul>\n<li>返回所有(一个或多个)给定key的值</li>\n<li>如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET redis redis.com\nOK\n127.0.0.1:6379&gt; SET mongodb mongodb.org\nOK\n127.0.0.1:6379&gt; MGET redis mongodb\n1) \"redis.com\"\n2) \"mongodb.org\"\n127.0.0.1:6379&gt; MGET redis mongodb mysql # 不存在的 mysql 返回 nil\n1) \"redis.com\"\n2) \"mongodb.org\"\n3) (nil)\n</code></pre>\n\n<h3>MSET</h3>\n\n<ul>\n<li>同时设置一个或多个key-value对</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; MSET date \"2012.3.30\" time \"11:00 a.m.\" weather \"sunny\"\nOK\n127.0.0.1:6379&gt; MGET date time weather\n1) \"2012.3.30\"\n2) \"11:00 a.m.\"\n3) \"sunny\"\n</code></pre>\n\n<h3>MSETNX</h3>\n\n<ul>\n<li>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</li>\n<li>即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; MSETNX rmdbs \"MySQL\" nosql \"MongoDB\" key-value-store \"redis\"\n(integer) 1\n127.0.0.1:6379&gt; MGET rmdbs nosql key-value-store\n1) \"MySQL\"\n2) \"MongoDB\"\n3) \"redis\"\n</code></pre>\n\n<h3>PSETEX</h3>\n\n<ul>\n<li>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; PSETEX mykey 100000 \"Hello\"\nOK\n127.0.0.1:6379&gt; PTTL mykey\n(integer) 98648\n127.0.0.1:6379&gt; GET mykey\n\"Hello\"\n</code></pre>\n\n<h3>SET</h3>\n\n<ul>\n<li>将字符串值value关联到key</li>\n<li>如果key存在，覆盖操作，无视类型</li>\n<li>对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</li>\n</ul>\n\n<pre><code># 对不存在的键进行设置\n\nredis 127.0.0.1:6379&gt; SET key \"value\"\nOK\n\nredis 127.0.0.1:6379&gt; GET key\n\"value\"\n\n\n# 对已存在的键进行设置\n\nredis 127.0.0.1:6379&gt; SET key \"new-value\"\nOK\n\nredis 127.0.0.1:6379&gt; GET key\n\"new-value\"\n\n\n# 使用 EX 选项\n\nredis 127.0.0.1:6379&gt; SET key-with-expire-time \"hello\" EX 10086\nOK\n\nredis 127.0.0.1:6379&gt; GET key-with-expire-time\n\"hello\"\n\nredis 127.0.0.1:6379&gt; TTL key-with-expire-time\n(integer) 10069\n\n\n# 使用 PX 选项\n\nredis 127.0.0.1:6379&gt; SET key-with-pexpire-time \"moto\" PX 123321\nOK\n\nredis 127.0.0.1:6379&gt; GET key-with-pexpire-time\n\"moto\"\n\nredis 127.0.0.1:6379&gt; PTTL key-with-pexpire-time\n(integer) 111939\n\n\n# 使用 NX 选项\n\nredis 127.0.0.1:6379&gt; SET not-exists-key \"value\" NX\nOK      # 键不存在，设置成功\n\nredis 127.0.0.1:6379&gt; GET not-exists-key\n\"value\"\n\nredis 127.0.0.1:6379&gt; SET not-exists-key \"new-value\" NX\n(nil)   # 键已经存在，设置失败\n\nredis 127.0.0.1:6379&gt; GEt not-exists-key\n\"value\" # 维持原值不变\n\n\n# 使用 XX 选项\n\nredis 127.0.0.1:6379&gt; EXISTS exists-key\n(integer) 0\n\nredis 127.0.0.1:6379&gt; SET exists-key \"value\" XX\n(nil)   # 因为键不存在，设置失败\n\nredis 127.0.0.1:6379&gt; SET exists-key \"value\"\nOK      # 先给键设置一个值\n\nredis 127.0.0.1:6379&gt; SET exists-key \"new-value\" XX\nOK      # 设置新值成功\n\nredis 127.0.0.1:6379&gt; GET exists-key\n\"new-value\"\n\n\n# NX 或 XX 可以和 EX 或者 PX 组合使用\n\nredis 127.0.0.1:6379&gt; SET key-with-expire-and-NX \"hello\" EX 10086 NX\nOK\n\nredis 127.0.0.1:6379&gt; GET key-with-expire-and-NX\n\"hello\"\n\nredis 127.0.0.1:6379&gt; TTL key-with-expire-and-NX\n(integer) 10063\n\nredis 127.0.0.1:6379&gt; SET key-with-pexpire-and-XX \"old value\"\nOK\n\nredis 127.0.0.1:6379&gt; SET key-with-pexpire-and-XX \"new value\" PX 123321\nOK\n\nredis 127.0.0.1:6379&gt; GET key-with-pexpire-and-XX\n\"new value\"\n\nredis 127.0.0.1:6379&gt; PTTL key-with-pexpire-and-XX\n(integer) 112999\n\n\n# EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项\n\nredis 127.0.0.1:6379&gt; SET key \"value\" EX 1000 PX 5000000\nOK\n\nredis 127.0.0.1:6379&gt; TTL key\n(integer) 4993  # 这是 PX 参数设置的值\n\nredis 127.0.0.1:6379&gt; SET another-key \"value\" PX 5000000 EX 1000\nOK\n\nredis 127.0.0.1:6379&gt; TTL another-key\n(integer) 997   # 这是 EX 参数设置的值\n</code></pre>\n\n<h3>SETEX</h3>\n\n<ul>\n<li>将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)</li>\n<li>如果 key 已经存在， SETEX 命令将覆写旧值。\n> 等同  :\nSET key value\nEXPIRE key seconds  # 设置生存时间</li>\n</ul>\n\n<pre><code># 在 key 不存在时进行 SETEX\n\nredis&gt; SETEX cache_user_id 60 10086\nOK\n\nredis&gt; GET cache_user_id  # 值\n\"10086\"\n\nredis&gt; TTL cache_user_id  # 剩余生存时间\n(integer) 49\n\n\n# key 已经存在时，SETEX 覆盖旧值\n\nredis&gt; SET cd \"timeless\"\nOK\n\nredis&gt; SETEX cd 3000 \"goodbye my love\"\nOK\n\nredis&gt; GET cd\n\"goodbye my love\"\n\nredis&gt; TTL cd\n(integer) 2997\n</code></pre>\n\n<h3>SETNX</h3>\n\n<ul>\n<li>将key的值设为value，当且仅当key不存在。</li>\n<li>若key存在则setnx不做任何操作</li>\n</ul>\n\n<pre><code>redis&gt; EXISTS job                # job 不存在\n(integer) 0\n\nredis&gt; SETNX job \"programmer\"    # job 设置成功\n(integer) 1\n\nredis&gt; SETNX job \"code-farmer\"   # 尝试覆盖 job ，失败\n(integer) 0\n\nredis&gt; GET job                   # 没有被覆盖\n\"programmer\"\n</code></pre>\n\n<h3>STRLEN</h3>\n\n<ul>\n<li>返回key所存储的字符串长度</li>\n<li>若存储不是字符串，返回错误</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; set mykey \"www.qipajun.com\"\nOK\n127.0.0.1:6379&gt; strlen mykey\n(integer) 15\n</code></pre>','redis String','','publish','closed','open','','redis-string','','','2017-03-26 13:51:41','2017-03-26 05:51:41','# REDIS Sting \n### APPEND\n- 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。\n- 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。\n```\n127.0.0.1:6379&gt; EXISTS myphone\n(integer) 0\n# 对不存在的key进行append 等同直接set\n127.0.0.1:6379&gt; APPEND myphone &quot;nokia&quot;\n(integer) 5\n#对存在的keyappend 直接追加后边\n127.0.0.1:6379&gt; APPEND myphone &quot; - 1110&quot;\n(integer) 12\n127.0.0.1:6379&gt; GET myphone\n&quot;nokia - 1110&quot;\n```\n### APPEND timeseries\n- APPEND 可以为一系列定长(fixed-size)数据(sample)提供一种紧凑的表示方式，通常称之为时间序列。\n`APPEND timeseries \"fixed-size sample\"`\n- 可以考虑使用 UNIX 时间戳作为时间序列的键名，这样一来，可以避免单个 key 因为保存过大的时间序列而占用大量内存，另一方面，也可以节省下大量命名空间。\n```\n127.0.0.1:6379&gt; APPEND ts &quot;0043&quot;\n(integer) 4\n127.0.0.1:6379&gt; APPEND ts &quot;0035&quot;\n(integer) 8\n127.0.0.1:6379&gt;  GETRANGE ts 0 3\n&quot;0043&quot;\n127.0.0.1:6379&gt; GETRANGE ts 4 7\n&quot;0035&quot;\n```\n### DECR\n- 将 key 中储存的数字值减一\n- 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。\n- 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。\n- 值限制在 64 位(bit)有符号数字表示之内。\n\n```\n#对存在的数字值 key 进行 DECR\n127.0.0.1:6379&gt; SET failure_times 10\nOK\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 9\n\n# 对不存在的key进行DECR\n127.0.0.1:6379&gt; EXISTS count\n(integer) 0\n127.0.0.1:6379&gt; DECR count\n(integer) -1\n\n# 对存在但不是数值的 key 进行 DECR\n127.0.0.1:6379&gt; SET company YOUR_CODE_SUCKS.LLC\nOK\n127.0.0.1:6379&gt; DECR company\n(error) ERR value is not an integer or out of range\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 8\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 7\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 6\n127.0.0.1:6379&gt; DECR failure_times\n(integer) 5\n```\n### DECRBY\n- 将 key 所储存的值减去减量 decrement 。\n```\n127.0.0.1:6379&gt; SET count 100\nOK\n127.0.0.1:6379&gt; DECRBY count 20\n(integer) 80\n# 不存在的key\n127.0.0.1:6379&gt; EXISTS pages\n(integer) 0\n127.0.0.1:6379&gt; DECRBY pages 10\n(integer) -10\n```\n### GET\n- 返回key所关联的字符串值\n### GETBIT\n- 对key所存储的字符串值，获取指定偏移量上的位(bit)\n- 当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 \n```\n对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0\n127.0.0.1:6379&gt; EXISTS bit\n(integer) 0\n127.0.0.1:6379&gt; GETBIT bit 10086\n(integer) 0\n# 对已存在的 offset 进行 GETBIT\n127.0.0.1:6379&gt; SETBIT bit 10086 1\n(integer) 0\n127.0.0.1:6379&gt;  GETBIT bit 10086\n(integer) 1\n```\n### GETSET\n- 将给定 key 的值设为 value ，并返回 key 的旧值(old value)\n- 当 key 存在但不是字符串类型时，返回一个错误\n```\n127.0.0.1:6379&gt; GETSET db mongodb\n(nil)\n127.0.0.1:6379&gt; GET db\n&quot;mongodb&quot;\n127.0.0.1:6379&gt; GETSET db redis\n&quot;mongodb&quot;\n127.0.0.1:6379&gt; GET db\n&quot;redis&quot;\n127.0.0.1:6379&gt;\n\n# \n127.0.0.1:6379&gt; INCR mycount\n(integer) 1\n127.0.0.1:6379&gt; GETSET mycount 0\n&quot;1&quot;\n127.0.0.1:6379&gt; GET mycount\n&quot;0&quot;\n```\n### INCR\n- 将key中存储的数字增加一\n```\n&quot;0&quot;\n127.0.0.1:6379&gt; set age 20\nOK\n127.0.0.1:6379&gt; incr age\n(integer) 21\n127.0.0.1:6379&gt; get age\n&quot;21&quot;\n```\n### INCRBY\n- 将key所存储的值增加增量\n```\n#key 存在且是数字\n127.0.0.1:6379&gt;  SET rank 50\nOK\n127.0.0.1:6379&gt; INCRBY rank 20\n(integer) 70\n#key不存在\n127.0.0.1:6379&gt;  GET rank\n&quot;70&quot;\n127.0.0.1:6379&gt; EXISTS counter\n(integer) 0\n127.0.0.1:6379&gt; INCRBY counter 30\n(integer) 30\n127.0.0.1:6379&gt; GET counter\n&quot;30&quot;\n#eky存在不是数字\n127.0.0.1:6379&gt; SET book &quot;long long ago...&quot;\nOK\n127.0.0.1:6379&gt;  INCRBY book 200\n(error) ERR value is not an integer or out of range\n```\n### INCRBYFLOAT\n- 为 key 中所储存的值加上浮点数增量\n```\n# 值和增量都不是指数符号\n127.0.0.1:6379&gt; SET mykey 10.50\nOK\n127.0.0.1:6379&gt; INCRBYFLOAT mykey 0.1\n&quot;10.6&quot;\n# 值和增量都是指数符号\n127.0.0.1:6379&gt; SET mykey 314e-2\nOK\n127.0.0.1:6379&gt; GET mykey\n&quot;314e-2&quot;\n127.0.0.1:6379&gt; INCRBYFLOAT mykey 0\n&quot;3.14&quot;\n# 可以对整数类型执行\n127.0.0.1:6379&gt; SET mykey 3\nOK\n127.0.0.1:6379&gt; INCRBYFLOAT mykey 1.1\n&quot;4.1&quot;\n# 后跟的 0 会被移除\n127.0.0.1:6379&gt; SET mykey 3.0\nOK\n127.0.0.1:6379&gt; GET mykey\n&quot;3.0&quot;\n127.0.0.1:6379&gt; INCRBYFLOAT mykey 1.000000000000000000000\n&quot;4&quot;\n127.0.0.1:6379&gt; GET mykey\n&quot;4&quot;\n```\n### MGET\n- 返回所有(一个或多个)给定key的值\n- 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。\n```\n127.0.0.1:6379&gt; SET redis redis.com\nOK\n127.0.0.1:6379&gt; SET mongodb mongodb.org\nOK\n127.0.0.1:6379&gt; MGET redis mongodb\n1) &quot;redis.com&quot;\n2) &quot;mongodb.org&quot;\n127.0.0.1:6379&gt; MGET redis mongodb mysql # 不存在的 mysql 返回 nil\n1) &quot;redis.com&quot;\n2) &quot;mongodb.org&quot;\n3) (nil)\n```\n### MSET\n- 同时设置一个或多个key-value对\n```\n127.0.0.1:6379&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;\nOK\n127.0.0.1:6379&gt; MGET date time weather\n1) &quot;2012.3.30&quot;\n2) &quot;11:00 a.m.&quot;\n3) &quot;sunny&quot;\n```\n### MSETNX\n- 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。\n- 即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作。\n```\n127.0.0.1:6379&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;\n(integer) 1\n127.0.0.1:6379&gt; MGET rmdbs nosql key-value-store\n1) &quot;MySQL&quot;\n2) &quot;MongoDB&quot;\n3) &quot;redis&quot;\n```\n### PSETEX\n- 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。\n```\n127.0.0.1:6379&gt; PSETEX mykey 100000 &quot;Hello&quot;\nOK\n127.0.0.1:6379&gt; PTTL mykey\n(integer) 98648\n127.0.0.1:6379&gt; GET mykey\n&quot;Hello&quot;\n```\n### SET\n- 将字符串值value关联到key\n- 如果key存在，覆盖操作，无视类型\n- 对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。\n```\n# 对不存在的键进行设置\n\nredis 127.0.0.1:6379&gt; SET key &quot;value&quot;\nOK\n\nredis 127.0.0.1:6379&gt; GET key\n&quot;value&quot;\n\n\n# 对已存在的键进行设置\n\nredis 127.0.0.1:6379&gt; SET key &quot;new-value&quot;\nOK\n\nredis 127.0.0.1:6379&gt; GET key\n&quot;new-value&quot;\n\n\n# 使用 EX 选项\n\nredis 127.0.0.1:6379&gt; SET key-with-expire-time &quot;hello&quot; EX 10086\nOK\n\nredis 127.0.0.1:6379&gt; GET key-with-expire-time\n&quot;hello&quot;\n\nredis 127.0.0.1:6379&gt; TTL key-with-expire-time\n(integer) 10069\n\n\n# 使用 PX 选项\n\nredis 127.0.0.1:6379&gt; SET key-with-pexpire-time &quot;moto&quot; PX 123321\nOK\n\nredis 127.0.0.1:6379&gt; GET key-with-pexpire-time\n&quot;moto&quot;\n\nredis 127.0.0.1:6379&gt; PTTL key-with-pexpire-time\n(integer) 111939\n\n\n# 使用 NX 选项\n\nredis 127.0.0.1:6379&gt; SET not-exists-key &quot;value&quot; NX\nOK      # 键不存在，设置成功\n\nredis 127.0.0.1:6379&gt; GET not-exists-key\n&quot;value&quot;\n\nredis 127.0.0.1:6379&gt; SET not-exists-key &quot;new-value&quot; NX\n(nil)   # 键已经存在，设置失败\n\nredis 127.0.0.1:6379&gt; GEt not-exists-key\n&quot;value&quot; # 维持原值不变\n\n\n# 使用 XX 选项\n\nredis 127.0.0.1:6379&gt; EXISTS exists-key\n(integer) 0\n\nredis 127.0.0.1:6379&gt; SET exists-key &quot;value&quot; XX\n(nil)   # 因为键不存在，设置失败\n\nredis 127.0.0.1:6379&gt; SET exists-key &quot;value&quot;\nOK      # 先给键设置一个值\n\nredis 127.0.0.1:6379&gt; SET exists-key &quot;new-value&quot; XX\nOK      # 设置新值成功\n\nredis 127.0.0.1:6379&gt; GET exists-key\n&quot;new-value&quot;\n\n\n# NX 或 XX 可以和 EX 或者 PX 组合使用\n\nredis 127.0.0.1:6379&gt; SET key-with-expire-and-NX &quot;hello&quot; EX 10086 NX\nOK\n\nredis 127.0.0.1:6379&gt; GET key-with-expire-and-NX\n&quot;hello&quot;\n\nredis 127.0.0.1:6379&gt; TTL key-with-expire-and-NX\n(integer) 10063\n\nredis 127.0.0.1:6379&gt; SET key-with-pexpire-and-XX &quot;old value&quot;\nOK\n\nredis 127.0.0.1:6379&gt; SET key-with-pexpire-and-XX &quot;new value&quot; PX 123321\nOK\n\nredis 127.0.0.1:6379&gt; GET key-with-pexpire-and-XX\n&quot;new value&quot;\n\nredis 127.0.0.1:6379&gt; PTTL key-with-pexpire-and-XX\n(integer) 112999\n\n\n# EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项\n\nredis 127.0.0.1:6379&gt; SET key &quot;value&quot; EX 1000 PX 5000000\nOK\n\nredis 127.0.0.1:6379&gt; TTL key\n(integer) 4993  # 这是 PX 参数设置的值\n\nredis 127.0.0.1:6379&gt; SET another-key &quot;value&quot; PX 5000000 EX 1000\nOK\n\nredis 127.0.0.1:6379&gt; TTL another-key\n(integer) 997   # 这是 EX 参数设置的值\n```\n### SETEX\n- 将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)\n- 如果 key 已经存在， SETEX 命令将覆写旧值。\n> 等同  :\nSET key value\nEXPIRE key seconds  # 设置生存时间\n```\n# 在 key 不存在时进行 SETEX\n\nredis&gt; SETEX cache_user_id 60 10086\nOK\n\nredis&gt; GET cache_user_id  # 值\n&quot;10086&quot;\n\nredis&gt; TTL cache_user_id  # 剩余生存时间\n(integer) 49\n\n\n# key 已经存在时，SETEX 覆盖旧值\n\nredis&gt; SET cd &quot;timeless&quot;\nOK\n\nredis&gt; SETEX cd 3000 &quot;goodbye my love&quot;\nOK\n\nredis&gt; GET cd\n&quot;goodbye my love&quot;\n\nredis&gt; TTL cd\n(integer) 2997\n```\n### SETNX\n- 将key的值设为value，当且仅当key不存在。\n- 若key存在则setnx不做任何操作\n```\nredis&gt; EXISTS job                # job 不存在\n(integer) 0\n\nredis&gt; SETNX job &quot;programmer&quot;    # job 设置成功\n(integer) 1\n\nredis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败\n(integer) 0\n\nredis&gt; GET job                   # 没有被覆盖\n&quot;programmer&quot;\n```\n### STRLEN\n- 返回key所存储的字符串长度\n- 若存储不是字符串，返回错误\n```\n127.0.0.1:6379&gt; set mykey &quot;www.qipajun.com&quot;\nOK\n127.0.0.1:6379&gt; strlen mykey\n(integer) 15\n```',0,'http://localhost/qipajun/?p=31',0,'post','',0),
	(33,1,'2017-03-26 13:51:42','2017-03-26 05:51:42','<h1>REDIS - KEY</h1>\n\n<h3>DEL</h3>\n\n<ul>\n<li>删除key值</li>\n</ul>\n\n<pre><code>SET name zhangsan \nDEL name //删除key name\nEXISTS name //查看key是否存在\nDEL name age sex //一次删除多个key\n</code></pre>\n\n<h3>DUMP</h3>\n\n<ul>\n<li>序列化给定的key，返回被序列化的值，使用<code>RESTORE</code>命令可以讲这个值反序列化为redis键。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET greeting \"hello, dumping world!\"\nOK\n127.0.0.1:6379&gt; DUMP greeting\n\"\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde\"\n</code></pre>\n\n<h3>EXISTS</h3>\n\n<ul>\n<li>检查给定key是否存在。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET db \"redis\"\nOK\n127.0.0.1:6379&gt;  EXISTS db\n(integer) 1\n127.0.0.1:6379&gt; DEL db\n(integer) 1\n127.0.0.1:6379&gt; EXISTS db\n(integer) 0\n</code></pre>\n\n<h3>EXPIRE</h3>\n\n<ul>\n<li>为给定key设置生存时间，当key过期时(生存时间为0)，他会被自动删除</li>\n<li>设置key过期时间</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt;  EXPIRE cache_page 30\n(integer) 1\n127.0.0.1:6379&gt; TTL cache_page\n(integer) 26\n127.0.0.1:6379&gt; EXPIRE cache_page 30000\n(integer) 1\n127.0.0.1:6379&gt;  TTL cache_page\n(integer) 29996\n</code></pre>\n\n<ul>\n<li>对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间</li>\n<li>使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样</li>\n<li>PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key</li>\n</ul>\n\n<h3>EXPIREAT</h3>\n\n<ul>\n<li>EXPIREAT 的作用和 EXPIRE 类似，都用于为key设置生存时间。</li>\n<li>不同在于EXPIREAT接收unix时间错。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET cache www.google.com\nOK\n127.0.0.1:6379&gt; EXPIREAT cache 1489536000\n(integer) 1\n127.0.0.1:6379&gt; TTL cache\n(integer) 74223\n</code></pre>\n\n<h3>KEYS</h3>\n\n<ul>\n<li>查找所有符合给定模式pattern的key</li>\n<li>KEYS * 匹配数据库中所有 key </li>\n<li>KEYS h?llo 匹配 hello ， hallo 和 hxllo 等</li>\n<li>KEYS h*llo 匹配 hllo 和 heeeeello 等</li>\n<li>KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo </li>\n<li>特殊符号用 \\ 隔开</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; keys * //匹配所有\n1) \"two\"\n2) \"one\"\n3) \"four\"\n4) \"three\"\n127.0.0.1:6379&gt; KEYS *o*    //匹配带o的key\n1) \"two\"\n2) \"one\"\n3) \"four\"\n127.0.0.1:6379&gt; KEYS t??    //匹配t开头\n1) \"two\"\n127.0.0.1:6379&gt; KEYS t[w]* \n1) \"two\"\n</code></pre>\n\n<h3>MIGRATE</h3>\n\n<ul>\n<li>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</li>\n<li>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</li>\n<li>启动两个redis实例</li>\n</ul>\n\n<pre><code>redis-server &amp; //默认6379端口\nredis-server --port 7777 &amp; //777端口\n</code></pre>\n\n<ul>\n<li>链接6379端口 设置键值 </li>\n</ul>\n\n<pre><code>redis-cli //链接redis 默认端口\nflushall //清空\nSET greeting \"Hello from 6379 instance\" //设置一个key\nMIGRATE 127.0.0.1 7777 greeting 0 1000 //前移到7777端口实例上\nEXISTS greeting     //迁移成功后 key 被删除\n</code></pre>\n\n<ul>\n<li>使用另一个客户端，查看 7777 端口上的实例</li>\n</ul>\n\n<pre><code>redis-cli -p 7777\n127.0.0.1:7777&gt; keys *\n1) \"greeting\"\n127.0.0.1:7777&gt; get greeting\n\"Hello from 6379 instance\"\n</code></pre>\n\n<h3>MOVE</h3>\n\n<ul>\n<li>将当前数据库的key移动到给定的数据库db当中</li>\n<li>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET name \'zhangsan\'\nOK\n127.0.0.1:6379&gt; MOVE name 1\n(integer) 1\n127.0.0.1:6379&gt; keys *\n(empty list or set)\n127.0.0.1:6379&gt; exists name\n(integer) 0\n127.0.0.1:6379&gt; select 1\nOK\n127.0.0.1:6379[1]&gt; keys *\n1) \"name\"\n</code></pre>\n\n<ul>\n<li>如果存在则移动失败</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; move name 1\n(integer) 0\n</code></pre>\n\n<h3>OBJECT</h3>\n\n<ul>\n<li>命令允许从内部察看给定 key 的 Redis 对象</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt;  SET game \"COD\"\nOK\n127.0.0.1:6379&gt; OBJECT REFCOUNT game  //只有一个引用\n(integer) 1\n127.0.0.1:6379&gt; OBJECT IDLETIME game //等待一阵，然后查看空调转\n(integer) 12\n127.0.0.1:6379&gt; GET game //读取 让它处于激活状态\n\"COD\"\n127.0.0.1:6379&gt; OBJECT IDLETIME game // 不再处于空转\n(integer) 0\n127.0.0.1:6379&gt; OBJECT ENCODING game  //字符串的编码方式\n\"embstr\"\n127.0.0.1:6379&gt;  SET phone 15820123123 \nOK\n127.0.0.1:6379&gt; OBJECT ENCODING phone\n\"int\"\n127.0.0.1:6379&gt; SET age 20\nOK\n127.0.0.1:6379&gt; OBJECT ENCODING age  //短数字被编码为 int\n\"int\"\n</code></pre>\n\n<h3>PERSIST</h3>\n\n<ul>\n<li>移除给定key的生存时间，将这个key从带生存时间的key转成不带生存时间的key</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET mykey \"Hello\"\nOK\n127.0.0.1:6379&gt; EXPIRE mykey 100000\n(integer) 1\n127.0.0.1:6379&gt;  TTL mykey\n(integer) 99996\n127.0.0.1:6379&gt; PERSIST mykey\n(integer) 1\n127.0.0.1:6379&gt; TTL mykey\n(integer) -1\n</code></pre>\n\n<h3>PEXPIRE</h3>\n\n<ul>\n<li>和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET mykey \"Hello\"\nOK\n127.0.0.1:6379&gt; PEXPIRE mykey 150000\n(integer) 1\n127.0.0.1:6379&gt; TTL mykey //返回值以秒为单位\n(integer) 142\n127.0.0.1:6379&gt;  PTTL mykey     //可以给出准确的毫秒数\n(integer) 136021\n</code></pre>\n\n<h3>PEXPIREAT</h3>\n\n<ul>\n<li>这个命令和 EXPIREAT 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 EXPIREAT 那样，以秒为单位。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET mykey \"Hello\"\nOK\n127.0.0.1:6379&gt; PEXPIREAT mykey 1555555555005\n(integer) 1\n127.0.0.1:6379&gt; TTL mykey   // TTL返回秒\n(integer) 66082853\n127.0.0.1:6379&gt; PTTL mykey // PTTL 返回毫秒\n(integer) 66082847847\n127.0.0.1:6379&gt;\n</code></pre>\n\n<h3>PTTL</h3>\n\n<ul>\n<li>这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; PTTL mykey\n(integer) 66082847847\n</code></pre>\n\n<h3>RANDOMKEY</h3>\n\n<ul>\n<li>从当前数据库中随机返回(不删除)一个 key 。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; MSET fruit \"apple\" drink \"beer\" food \"cookies\"\nOK\n127.0.0.1:6379&gt; randomkey\n\"food\"\n127.0.0.1:6379&gt; randomkey\n\"drink\"\n127.0.0.1:6379&gt; keys *\n1) \"food\"\n2) \"drink\"\n3) \"fruit\"\n127.0.0.1:6379&gt; flushall\nOK\n127.0.0.1:6379&gt; randomkey\n(nil)\n</code></pre>\n\n<h3>RENAME</h3>\n\n<ul>\n<li>将key 改名为newkey</li>\n<li>当 key 和 newkey 相同，或者 key 不存在时，返回一个错误</li>\n<li>当 newkey 已经存在时， RENAME 命令将覆盖旧值</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET message \"hello world\"\nOK\n127.0.0.1:6379&gt; RENAME message greeting\nOK\n127.0.0.1:6379&gt; EXISTS message\n(integer) 0\n127.0.0.1:6379&gt;  EXISTS greeting\n(integer) 1\n//key 不存在 返回错误\n127.0.0.1:6379&gt; RENAME message greeting\n(error) ERR no such key\n//key存在将会覆盖\n127.0.0.1:6379&gt; SET greeting \"old value\"\nOK\n127.0.0.1:6379&gt; SET message \"new value\"\nOK\n127.0.0.1:6379&gt; RENAME message greeting\nOK\n127.0.0.1:6379&gt; get greeting\n\"new value\"\n</code></pre>\n\n<h3>RENAMENX</h3>\n\n<ul>\n<li>当且仅当 newkey 不存在时，将 key 改名为 newkey </li>\n<li>当 key 不存在时，返回一个错误</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET player \"MPlyaer\"\nOK\n127.0.0.1:6379&gt; EXISTS best_player\n(integer) 0\n# newkey 不存在，改名成功\n127.0.0.1:6379&gt; RENAMENX player best_player\n(integer) 1\n127.0.0.1:6379&gt;  SET animal \"bear\"\nOK\n127.0.0.1:6379&gt; SET favorite_animal \"butterfly\"\nOK\n# newkey存在时，失败\n127.0.0.1:6379&gt; RENAMENX animal favorite_animal\n(integer) 0\n127.0.0.1:6379&gt; get animal\n\"bear\"\n127.0.0.1:6379&gt; get favorite_animal\n\"butterfly\"\n</code></pre>\n\n<h3>RESTORE</h3>\n\n<ul>\n<li>反序列化给定的序列化值，并将它和给定的 key 关联</li>\n<li>RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET greeting \"hello, dumping world!\"\nOK\n127.0.0.1:6379&gt;  DUMP greeting\n\"\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde\"\n127.0.0.1:6379&gt; RESTORE greeting-again 0 \"\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde\"\nOK\n127.0.0.1:6379&gt; GET greeting-again\n\"hello, dumping world!\"\n127.0.0.1:6379&gt; RESTORE fake-message 0 \"hello moto moto blah blah\"  //使用错误的值进行反序列化\n(error) ERR DUMP payload version or checksum are wrong\n</code></pre>\n\n<h3>SORT</h3>\n\n<ul>\n<li>返回或保存给定列表、集合、有序集合 key 中经过排序的元素。</li>\n<li>排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较</li>\n<li>SORT key 返回键值从小到大排序的结果</li>\n<li>SORT key DESC 返回键值从大到小排序的结果</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; LPUSH today_cost 30 1.5 10 8\n(integer) 4\n127.0.0.1:6379&gt; SORT today_cost //排序\n1) \"1.5\"\n2) \"8\"\n3) \"10\"\n4) \"30\"\n127.0.0.1:6379&gt; SORT today_cost DESC //降序排列\n1) \"30\"\n2) \"10\"\n3) \"8\"\n4) \"1.5\"\n</code></pre>\n\n<h3>SORT - ALPHA</h3>\n\n<ul>\n<li>sort 默认排序对象为数字，当需要对字符串进行排序是，需要显示地在sort命令之后添加ALPHA修饰</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; LPUSH website \"www.baidu.com\"\n(integer) 1\n127.0.0.1:6379&gt; LPUSH website \"www.qipajun.com\"\n(integer) 2\n127.0.0.1:6379&gt; LPUSH website \"www.google.com\"\n(integer) 3\n\n127.0.0.1:6379&gt; SORT website ALPHA\n1) \"www.baidu.com\"\n2) \"www.google.com\"\n3) \"www.qipajun.com\"\n\n</code></pre>\n\n<h3>SORT - LIMIT</h3>\n\n<ul>\n<li>排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数</li>\n<li></li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; RPUSH rank 1 3 5 7 9\n(integer) 5\n127.0.0.1:6379&gt; RPUSH rank 2 4 6 8 10\n(integer) 10\n127.0.0.1:6379&gt; SORT rank LIMIT 0 5\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"4\"\n5) \"5\"\n127.0.0.1:6379&gt; SORT rank LIMIT 0 1\n1) \"1\"\n127.0.0.1:6379&gt; SORT rank LIMIT 0 2 DESC\n1) \"10\"\n2) \"9\"\n</code></pre>\n\n<h3>TTL</h3>\n\n<ul>\n<li>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)</li>\n<li>key 不存在返回-2； 没有剩余时间返回-1；负责返回剩余生存时间</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; FLUSHDB\nOK\n# 不存在的 key\n127.0.0.1:6379&gt; TTL key\n(integer) -2\n127.0.0.1:6379&gt; SET key value\nOK\n# key 存在，但没有设置剩余生存时间\n127.0.0.1:6379&gt; TTL key\n(integer) -1\n# 有剩余生存时间的 key\n127.0.0.1:6379&gt; EXPIRE key 10086\n(integer) 1\n127.0.0.1:6379&gt; TTL key\n(integer) 10081\n</code></pre>\n\n<h3>TYPE</h3>\n\n<ul>\n<li>返回key所存储的值得类型</li>\n<li>返回类型:\n> none (key不存在)\nstring (字符串)\nlist (列表)\nset (集合)\nzset (有序集)\nhash (哈希表)</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; SET weather \"sunny\"\nOK\n#字符串\n127.0.0.1:6379&gt; TYPE weather\nstring\n127.0.0.1:6379&gt; LPUSH book_list \"programming in scala\"\n(integer) 1\n#列表\n127.0.0.1:6379&gt; TYPE book_list\nlist\n127.0.0.1:6379&gt; SADD pat \"dog\"\n(integer) 1\n#结合\n127.0.0.1:6379&gt;  TYPE pat\nset\n</code></pre>\n\n<h3>SCAN</h3>\n\n<ul>\n<li>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：\n> -  SCAN 命令用于迭代当前数据库中的数据库键。\n> -  SSCAN 命令用于迭代集合键中的元素。\n> - HSCAN 命令用于迭代哈希键中的键值对。\n>-  ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。\n></li>\n</ul>','redis key','','publish','closed','open','','redis-key','','','2017-03-26 13:51:42','2017-03-26 05:51:42','# REDIS - KEY\n### DEL\n- 删除key值\n```\nSET name zhangsan \nDEL name //删除key name\nEXISTS name //查看key是否存在\nDEL name age sex //一次删除多个key\n```\n### DUMP\n- 序列化给定的key，返回被序列化的值，使用`RESTORE`命令可以讲这个值反序列化为redis键。\n```\n127.0.0.1:6379&gt; SET greeting &quot;hello, dumping world!&quot;\nOK\n127.0.0.1:6379&gt; DUMP greeting\n&quot;\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde&quot;\n```\n### EXISTS\n- 检查给定key是否存在。\n```\n127.0.0.1:6379&gt; SET db &quot;redis&quot;\nOK\n127.0.0.1:6379&gt;  EXISTS db\n(integer) 1\n127.0.0.1:6379&gt; DEL db\n(integer) 1\n127.0.0.1:6379&gt; EXISTS db\n(integer) 0\n```\n### EXPIRE\n- 为给定key设置生存时间，当key过期时(生存时间为0)，他会被自动删除\n- 设置key过期时间\n```\n127.0.0.1:6379&gt;  EXPIRE cache_page 30\n(integer) 1\n127.0.0.1:6379&gt; TTL cache_page\n(integer) 26\n127.0.0.1:6379&gt; EXPIRE cache_page 30000\n(integer) 1\n127.0.0.1:6379&gt;  TTL cache_page\n(integer) 29996\n```\n- 对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间\n- 使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样\n-  PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key\n\n### EXPIREAT\n- EXPIREAT 的作用和 EXPIRE 类似，都用于为key设置生存时间。\n- 不同在于EXPIREAT接收unix时间错。\n```\n127.0.0.1:6379&gt; SET cache www.google.com\nOK\n127.0.0.1:6379&gt; EXPIREAT cache 1489536000\n(integer) 1\n127.0.0.1:6379&gt; TTL cache\n(integer) 74223\n```\n\n### KEYS\n- 查找所有符合给定模式pattern的key\n- KEYS * 匹配数据库中所有 key \n- KEYS h?llo 匹配 hello ， hallo 和 hxllo 等\n- KEYS h*llo 匹配 hllo 和 heeeeello 等\n- KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo \n- 特殊符号用 \\ 隔开\n```\n127.0.0.1:6379&gt; keys * //匹配所有\n1) &quot;two&quot;\n2) &quot;one&quot;\n3) &quot;four&quot;\n4) &quot;three&quot;\n127.0.0.1:6379&gt; KEYS *o*    //匹配带o的key\n1) &quot;two&quot;\n2) &quot;one&quot;\n3) &quot;four&quot;\n127.0.0.1:6379&gt; KEYS t??    //匹配t开头\n1) &quot;two&quot;\n127.0.0.1:6379&gt; KEYS t[w]* \n1) &quot;two&quot;\n```\n### MIGRATE\n- 将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。\n- 这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。\n- 启动两个redis实例\n```\nredis-server &amp; //默认6379端口\nredis-server --port 7777 &amp; //777端口\n```\n- 链接6379端口 设置键值 \n```\nredis-cli //链接redis 默认端口\nflushall //清空\nSET greeting &quot;Hello from 6379 instance&quot; //设置一个key\nMIGRATE 127.0.0.1 7777 greeting 0 1000 //前移到7777端口实例上\nEXISTS greeting     //迁移成功后 key 被删除\n```\n- 使用另一个客户端，查看 7777 端口上的实例\n```\nredis-cli -p 7777\n127.0.0.1:7777&gt; keys *\n1) &quot;greeting&quot;\n127.0.0.1:7777&gt; get greeting\n&quot;Hello from 6379 instance&quot;\n```\n### MOVE\n- 将当前数据库的key移动到给定的数据库db当中\n- 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果\n```\n127.0.0.1:6379&gt; SET name &#039;zhangsan&#039;\nOK\n127.0.0.1:6379&gt; MOVE name 1\n(integer) 1\n127.0.0.1:6379&gt; keys *\n(empty list or set)\n127.0.0.1:6379&gt; exists name\n(integer) 0\n127.0.0.1:6379&gt; select 1\nOK\n127.0.0.1:6379[1]&gt; keys *\n1) &quot;name&quot;\n```\n- 如果存在则移动失败\n```\n127.0.0.1:6379&gt; move name 1\n(integer) 0\n```\n### OBJECT\n- 命令允许从内部察看给定 key 的 Redis 对象\n```\n127.0.0.1:6379&gt;  SET game &quot;COD&quot;\nOK\n127.0.0.1:6379&gt; OBJECT REFCOUNT game  //只有一个引用\n(integer) 1\n127.0.0.1:6379&gt; OBJECT IDLETIME game //等待一阵，然后查看空调转\n(integer) 12\n127.0.0.1:6379&gt; GET game //读取 让它处于激活状态\n&quot;COD&quot;\n127.0.0.1:6379&gt; OBJECT IDLETIME game // 不再处于空转\n(integer) 0\n127.0.0.1:6379&gt; OBJECT ENCODING game  //字符串的编码方式\n&quot;embstr&quot;\n127.0.0.1:6379&gt;  SET phone 15820123123 \nOK\n127.0.0.1:6379&gt; OBJECT ENCODING phone\n&quot;int&quot;\n127.0.0.1:6379&gt; SET age 20\nOK\n127.0.0.1:6379&gt; OBJECT ENCODING age  //短数字被编码为 int\n&quot;int&quot;\n```\n\n### PERSIST\n- 移除给定key的生存时间，将这个key从带生存时间的key转成不带生存时间的key\n```\n127.0.0.1:6379&gt; SET mykey &quot;Hello&quot;\nOK\n127.0.0.1:6379&gt; EXPIRE mykey 100000\n(integer) 1\n127.0.0.1:6379&gt;  TTL mykey\n(integer) 99996\n127.0.0.1:6379&gt; PERSIST mykey\n(integer) 1\n127.0.0.1:6379&gt; TTL mykey\n(integer) -1\n```\n### PEXPIRE\n- 和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。\n```\n127.0.0.1:6379&gt; SET mykey &quot;Hello&quot;\nOK\n127.0.0.1:6379&gt; PEXPIRE mykey 150000\n(integer) 1\n127.0.0.1:6379&gt; TTL mykey //返回值以秒为单位\n(integer) 142\n127.0.0.1:6379&gt;  PTTL mykey     //可以给出准确的毫秒数\n(integer) 136021\n```\n### PEXPIREAT\n- 这个命令和 EXPIREAT 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 EXPIREAT 那样，以秒为单位。\n```\n127.0.0.1:6379&gt; SET mykey &quot;Hello&quot;\nOK\n127.0.0.1:6379&gt; PEXPIREAT mykey 1555555555005\n(integer) 1\n127.0.0.1:6379&gt; TTL mykey   // TTL返回秒\n(integer) 66082853\n127.0.0.1:6379&gt; PTTL mykey // PTTL 返回毫秒\n(integer) 66082847847\n127.0.0.1:6379&gt;\n```\n### PTTL\n- 这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。\n```\n127.0.0.1:6379&gt; PTTL mykey\n(integer) 66082847847\n```\n### RANDOMKEY\n- 从当前数据库中随机返回(不删除)一个 key 。\n```\n127.0.0.1:6379&gt; MSET fruit &quot;apple&quot; drink &quot;beer&quot; food &quot;cookies&quot;\nOK\n127.0.0.1:6379&gt; randomkey\n&quot;food&quot;\n127.0.0.1:6379&gt; randomkey\n&quot;drink&quot;\n127.0.0.1:6379&gt; keys *\n1) &quot;food&quot;\n2) &quot;drink&quot;\n3) &quot;fruit&quot;\n127.0.0.1:6379&gt; flushall\nOK\n127.0.0.1:6379&gt; randomkey\n(nil)\n```\n### RENAME\n- 将key 改名为newkey\n- 当 key 和 newkey 相同，或者 key 不存在时，返回一个错误\n- 当 newkey 已经存在时， RENAME 命令将覆盖旧值\n```\n127.0.0.1:6379&gt; SET message &quot;hello world&quot;\nOK\n127.0.0.1:6379&gt; RENAME message greeting\nOK\n127.0.0.1:6379&gt; EXISTS message\n(integer) 0\n127.0.0.1:6379&gt;  EXISTS greeting\n(integer) 1\n//key 不存在 返回错误\n127.0.0.1:6379&gt; RENAME message greeting\n(error) ERR no such key\n//key存在将会覆盖\n127.0.0.1:6379&gt; SET greeting &quot;old value&quot;\nOK\n127.0.0.1:6379&gt; SET message &quot;new value&quot;\nOK\n127.0.0.1:6379&gt; RENAME message greeting\nOK\n127.0.0.1:6379&gt; get greeting\n&quot;new value&quot;\n```\n### RENAMENX\n- 当且仅当 newkey 不存在时，将 key 改名为 newkey \n- 当 key 不存在时，返回一个错误\n```\n127.0.0.1:6379&gt; SET player &quot;MPlyaer&quot;\nOK\n127.0.0.1:6379&gt; EXISTS best_player\n(integer) 0\n# newkey 不存在，改名成功\n127.0.0.1:6379&gt; RENAMENX player best_player\n(integer) 1\n127.0.0.1:6379&gt;  SET animal &quot;bear&quot;\nOK\n127.0.0.1:6379&gt; SET favorite_animal &quot;butterfly&quot;\nOK\n# newkey存在时，失败\n127.0.0.1:6379&gt; RENAMENX animal favorite_animal\n(integer) 0\n127.0.0.1:6379&gt; get animal\n&quot;bear&quot;\n127.0.0.1:6379&gt; get favorite_animal\n&quot;butterfly&quot;\n```\n### RESTORE\n- 反序列化给定的序列化值，并将它和给定的 key 关联\n- RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误\n```\n127.0.0.1:6379&gt; SET greeting &quot;hello, dumping world!&quot;\nOK\n127.0.0.1:6379&gt;  DUMP greeting\n&quot;\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde&quot;\n127.0.0.1:6379&gt; RESTORE greeting-again 0 &quot;\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde&quot;\nOK\n127.0.0.1:6379&gt; GET greeting-again\n&quot;hello, dumping world!&quot;\n127.0.0.1:6379&gt; RESTORE fake-message 0 &quot;hello moto moto blah blah&quot;  //使用错误的值进行反序列化\n(error) ERR DUMP payload version or checksum are wrong\n```\n### SORT\n- 返回或保存给定列表、集合、有序集合 key 中经过排序的元素。\n- 排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较\n- SORT key 返回键值从小到大排序的结果\n- SORT key DESC 返回键值从大到小排序的结果\n```\n127.0.0.1:6379&gt; LPUSH today_cost 30 1.5 10 8\n(integer) 4\n127.0.0.1:6379&gt; SORT today_cost //排序\n1) &quot;1.5&quot;\n2) &quot;8&quot;\n3) &quot;10&quot;\n4) &quot;30&quot;\n127.0.0.1:6379&gt; SORT today_cost DESC //降序排列\n1) &quot;30&quot;\n2) &quot;10&quot;\n3) &quot;8&quot;\n4) &quot;1.5&quot;\n```\n### SORT - ALPHA \n- sort 默认排序对象为数字，当需要对字符串进行排序是，需要显示地在sort命令之后添加ALPHA修饰\n```\n127.0.0.1:6379&gt; LPUSH website &quot;www.baidu.com&quot;\n(integer) 1\n127.0.0.1:6379&gt; LPUSH website &quot;www.qipajun.com&quot;\n(integer) 2\n127.0.0.1:6379&gt; LPUSH website &quot;www.google.com&quot;\n(integer) 3\n\n127.0.0.1:6379&gt; SORT website ALPHA\n1) &quot;www.baidu.com&quot;\n2) &quot;www.google.com&quot;\n3) &quot;www.qipajun.com&quot;\n\n```\n\n### SORT - LIMIT\n- 排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数\n- \n```\n127.0.0.1:6379&gt; RPUSH rank 1 3 5 7 9\n(integer) 5\n127.0.0.1:6379&gt; RPUSH rank 2 4 6 8 10\n(integer) 10\n127.0.0.1:6379&gt; SORT rank LIMIT 0 5\n1) &quot;1&quot;\n2) &quot;2&quot;\n3) &quot;3&quot;\n4) &quot;4&quot;\n5) &quot;5&quot;\n127.0.0.1:6379&gt; SORT rank LIMIT 0 1\n1) &quot;1&quot;\n127.0.0.1:6379&gt; SORT rank LIMIT 0 2 DESC\n1) &quot;10&quot;\n2) &quot;9&quot;\n```\n### TTL\n- 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)\n- key 不存在返回-2； 没有剩余时间返回-1；负责返回剩余生存时间\n```\n127.0.0.1:6379&gt; FLUSHDB\nOK\n# 不存在的 key\n127.0.0.1:6379&gt; TTL key\n(integer) -2\n127.0.0.1:6379&gt; SET key value\nOK\n# key 存在，但没有设置剩余生存时间\n127.0.0.1:6379&gt; TTL key\n(integer) -1\n# 有剩余生存时间的 key\n127.0.0.1:6379&gt; EXPIRE key 10086\n(integer) 1\n127.0.0.1:6379&gt; TTL key\n(integer) 10081\n```\n### TYPE\n- 返回key所存储的值得类型\n- 返回类型:\n> none (key不存在)\nstring (字符串)\nlist (列表)\nset (集合)\nzset (有序集)\nhash (哈希表)\n\n```\n127.0.0.1:6379&gt; SET weather &quot;sunny&quot;\nOK\n#字符串\n127.0.0.1:6379&gt; TYPE weather\nstring\n127.0.0.1:6379&gt; LPUSH book_list &quot;programming in scala&quot;\n(integer) 1\n#列表\n127.0.0.1:6379&gt; TYPE book_list\nlist\n127.0.0.1:6379&gt; SADD pat &quot;dog&quot;\n(integer) 1\n#结合\n127.0.0.1:6379&gt;  TYPE pat\nset\n```\n### SCAN\n- SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：\n> -  SCAN 命令用于迭代当前数据库中的数据库键。\n> -  SSCAN 命令用于迭代集合键中的元素。\n> - HSCAN 命令用于迭代哈希键中的键值对。\n>-  ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。\n>',0,'http://localhost/qipajun/?p=33',0,'post','',0),
	(35,1,'2017-03-26 13:51:42','2017-03-26 05:51:42','<h1>REDIS Hash</h1>\n\n<h3>HDEL</h3>\n\n<ul>\n<li>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略</li>\n</ul>\n\n<pre><code># 测试数据\n\nredis&gt; HGETALL abbr\n1) \"a\"\n2) \"apple\"\n3) \"b\"\n4) \"banana\"\n5) \"c\"\n6) \"cat\"\n7) \"d\"\n8) \"dog\"\n\n\n# 删除单个域\n\nredis&gt; HDEL abbr a\n(integer) 1\n\n\n# 删除不存在的域\n\nredis&gt; HDEL abbr not-exists-field\n(integer) 0\n\n\n# 删除多个域\n\nredis&gt; HDEL abbr b c\n(integer) 2\n\nredis&gt; HGETALL abbr\n1) \"d\"\n2) \"dog\"\n</code></pre>\n\n<h3>HEXISTS</h3>\n\n<ul>\n<li>查看哈希表 key 中，给定域 field 是否存在</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; HEXISTS phone myphone\n(integer) 0\n127.0.0.1:6379&gt; HSET phone myphone nokia-1110\n(integer) 1\n127.0.0.1:6379&gt; HEXISTS phone myphone\n(integer) 1\n</code></pre>\n\n<h3>HGET</h3>\n\n<ul>\n<li>返回哈希表 key 中给定域 field 的值</li>\n</ul>\n\n<pre><code>#存在\n127.0.0.1:6379&gt; HSET site redis redis.com\n(integer) 1\n127.0.0.1:6379&gt; HGET site redis\n\"redis.com\"\n#不存在\n127.0.0.1:6379&gt; HGET site mysql\n(nil)\n</code></pre>\n\n<h3>HGETALL</h3>\n\n<ul>\n<li>返回哈希表 key 中，所有的域和值</li>\n<li>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; HSET people jack \"Jack Sparrow\"\n(integer) 1\n127.0.0.1:6379&gt; HSET people gump \"Forrest Gump\"\n(integer) 1\n127.0.0.1:6379&gt; HGETALL people\n1) \"jack\"\n2) \"Jack Sparrow\"\n3) \"gump\"\n4) \"Forrest Gump\"\n</code></pre>\n\n<h3>HINCRBY</h3>\n\n<ul>\n<li>为哈希表 key 中的域 field 的值加上增量 increment</li>\n<li>增量也可以为负数，相当于对给定域进行减法操作</li>\n</ul>\n\n<pre><code># increment 为正数\n127.0.0.1:6379&gt; HEXISTS counter page_view # 对空域进行设置\n(integer) 0\n127.0.0.1:6379&gt; HINCRBY counter page_view 200\n(integer) 200\n127.0.0.1:6379&gt; HINCRBY counter page_view 200\n(integer) 400\n127.0.0.1:6379&gt; HINCRBY counter page_view\n(error) ERR wrong number of arguments for \'hincrby\' command\n127.0.0.1:6379&gt; HGET counter page_view\n\"400\"\n# increment 为负数\n127.0.0.1:6379&gt; HGET counter page_view\n\"400\"\n127.0.0.1:6379&gt;  HINCRBY counter page_view -50\n(integer) 350\n127.0.0.1:6379&gt; HGET counter page_view\n\"350\"\n# 尝试对字符串值的域执行HINCRBY命令\n127.0.0.1:6379&gt; HSET myhash string hello,world # 设定一个字符串值\n(integer) 1\n127.0.0.1:6379&gt; HGET myhash string\n\"hello,world\"\n127.0.0.1:6379&gt; HINCRBY myhash string 1 # 命令执行失败，错误\n(error) ERR hash value is not an integer\n127.0.0.1:6379&gt; HGET myhash string # 原值不变\n\"hello,world\"\n\n</code></pre>\n\n<h3>HINCRBYFLOAT</h3>\n\n<ul>\n<li>为哈希表 key 中的域 field 加上浮点数增量 increment </li>\n</ul>\n\n<pre><code># 值和增量都是普通小数\n127.0.0.1:6379&gt; HSET mykey field 10.50\n(integer) 1\n127.0.0.1:6379&gt; HINCRBYFLOAT mykey field 0.1\n\"10.6\"\n# 值和增量都是指数符号\n127.0.0.1:6379&gt; HSET mykey field 5.0e3\n(integer) 0\n127.0.0.1:6379&gt; HINCRBYFLOAT mykey field 2.0e2\n\"5200\"\n127.0.0.1:6379&gt; EXISTS price\n(integer) 0\n# 对不存在的键执行 HINCRBYFLOAT\n127.0.0.1:6379&gt; HINCRBYFLOAT price milk 3.5\n\"3.5\"\n127.0.0.1:6379&gt; HGETALL price\n1) \"milk\"\n2) \"3.5\"\n# 对不存在的域进行 HINCRBYFLOAT\n127.0.0.1:6379&gt; HGETALL price\n1) \"milk\"\n2) \"3.5\"\n127.0.0.1:6379&gt; HINCRBYFLOAT price coffee 4.5 # 新增 coffee 域\n\"4.5\"\n127.0.0.1:6379&gt; HGETALL price\n1) \"milk\"\n2) \"3.5\"\n3) \"coffee\"\n4) \"4.5\"\n</code></pre>\n\n<h3>HKEYS</h3>\n\n<ul>\n<li>返回哈希表 key 中的所有域</li>\n</ul>\n\n<pre><code># 哈希表非空\n127.0.0.1:6379&gt; HMSET website google www.google.com yahoo www.yahoo.com\nOK\n# 空哈希表/key不存在\n127.0.0.1:6379&gt; HKEYS website\n1) \"google\"\n2) \"yahoo\"\n127.0.0.1:6379&gt; EXISTS fake_key\n(integer) 0\n127.0.0.1:6379&gt; HKEYS fake_key\n(empty list or set)\n</code></pre>\n\n<h3>HLEN</h3>\n\n<ul>\n<li>返回哈希表 key 中域的数量</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; HSET db redis redis.com\n(integer) 1\n127.0.0.1:6379&gt; HSET db mysql mysql.com\n(integer) 1\n127.0.0.1:6379&gt; HLEN db\n(integer) 2\n127.0.0.1:6379&gt; HSET db mongodb mongodb.org\n(integer) 1\n127.0.0.1:6379&gt; HLEN db\n(integer) 3\n</code></pre>\n\n<h3>HMGET</h3>\n\n<ul>\n<li>返回哈希表 key 中，一个或多个给定域的值</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; HMSET pet dog \"doudou\" cat \"nounou\"\nOK\n127.0.0.1:6379&gt; HMGET pet dog cat fake_pet\n1) \"doudou\"\n2) \"nounou\"\n3) (nil)\n</code></pre>\n\n<h3>HMSET</h3>\n\n<ul>\n<li>同时将多个 field-value (域-值)对设置到哈希表 key 中</li>\n<li>此命令会覆盖哈希表中已存在的域。</li>\n<li>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; HMSET website google www.google.com yahoo www.yahoo.com\nOK\n127.0.0.1:6379&gt; HGET website google\n\"www.google.com\"\n127.0.0.1:6379&gt; HGET website yahoo\n\"www.yahoo.com\"\n</code></pre>\n\n<h3>HSET</h3>\n\n<ul>\n<li>将哈希表 key 中的域 field 的值设为 value </li>\n<li>如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作</li>\n<li>如果域 field 已经存在于哈希表中，旧值将被覆盖</li>\n</ul>\n\n<pre><code>127.0.0.1:6379&gt; HSET website google \"www.g.cn\"  # 设置一个新域\n(integer) 1\n127.0.0.1:6379&gt;  HSET website google \"www.google.com\"     # 覆盖一个旧域\n(integer) 0\n</code></pre>\n\n<h3>HSETNX</h3>\n\n<ul>\n<li>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</li>\n<li>若域 field 已经存在，该操作无效</li>\n<li>如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令</li>\n</ul>\n\n<pre><code>redis&gt; HSETNX nosql key-value-store redis\n(integer) 1\n\nredis&gt; HSETNX nosql key-value-store redis       # 操作无效，域 key-value-store 已存在\n(integer) 0\n</code></pre>\n\n<h3>HVALS</h3>\n\n<ul>\n<li>返回哈希表 key 中所有域的值</li>\n</ul>\n\n<pre><code># 非空哈希表\n127.0.0.1:6379&gt; HMSET website google www.google.com yahoo www.yahoo.com\nOK\n127.0.0.1:6379&gt; HVALS website\n1) \"www.google.com\"\n2) \"www.yahoo.com\"\n# 空哈希表/不存在的key\n127.0.0.1:6379&gt; EXISTS not_exists\n(integer) 0\n127.0.0.1:6379&gt; HVALS not_exists\n(empty list or set)\n</code></pre>','redis Hash','','publish','closed','open','','redis-hash','','','2017-03-26 13:51:42','2017-03-26 05:51:42','# REDIS Hash\n### HDEL\n- 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略\n```\n# 测试数据\n\nredis&gt; HGETALL abbr\n1) &quot;a&quot;\n2) &quot;apple&quot;\n3) &quot;b&quot;\n4) &quot;banana&quot;\n5) &quot;c&quot;\n6) &quot;cat&quot;\n7) &quot;d&quot;\n8) &quot;dog&quot;\n\n\n# 删除单个域\n\nredis&gt; HDEL abbr a\n(integer) 1\n\n\n# 删除不存在的域\n\nredis&gt; HDEL abbr not-exists-field\n(integer) 0\n\n\n# 删除多个域\n\nredis&gt; HDEL abbr b c\n(integer) 2\n\nredis&gt; HGETALL abbr\n1) &quot;d&quot;\n2) &quot;dog&quot;\n```\n### HEXISTS\n- 查看哈希表 key 中，给定域 field 是否存在\n```\n127.0.0.1:6379&gt; HEXISTS phone myphone\n(integer) 0\n127.0.0.1:6379&gt; HSET phone myphone nokia-1110\n(integer) 1\n127.0.0.1:6379&gt; HEXISTS phone myphone\n(integer) 1\n```\n\n### HGET\n- 返回哈希表 key 中给定域 field 的值\n```\n#存在\n127.0.0.1:6379&gt; HSET site redis redis.com\n(integer) 1\n127.0.0.1:6379&gt; HGET site redis\n&quot;redis.com&quot;\n#不存在\n127.0.0.1:6379&gt; HGET site mysql\n(nil)\n```\n### HGETALL\n- 返回哈希表 key 中，所有的域和值\n- 在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。\n```\n127.0.0.1:6379&gt; HSET people jack &quot;Jack Sparrow&quot;\n(integer) 1\n127.0.0.1:6379&gt; HSET people gump &quot;Forrest Gump&quot;\n(integer) 1\n127.0.0.1:6379&gt; HGETALL people\n1) &quot;jack&quot;\n2) &quot;Jack Sparrow&quot;\n3) &quot;gump&quot;\n4) &quot;Forrest Gump&quot;\n```\n### HINCRBY\n- 为哈希表 key 中的域 field 的值加上增量 increment\n- 增量也可以为负数，相当于对给定域进行减法操作\n```\n# increment 为正数\n127.0.0.1:6379&gt; HEXISTS counter page_view # 对空域进行设置\n(integer) 0\n127.0.0.1:6379&gt; HINCRBY counter page_view 200\n(integer) 200\n127.0.0.1:6379&gt; HINCRBY counter page_view 200\n(integer) 400\n127.0.0.1:6379&gt; HINCRBY counter page_view\n(error) ERR wrong number of arguments for &#039;hincrby&#039; command\n127.0.0.1:6379&gt; HGET counter page_view\n&quot;400&quot;\n# increment 为负数\n127.0.0.1:6379&gt; HGET counter page_view\n&quot;400&quot;\n127.0.0.1:6379&gt;  HINCRBY counter page_view -50\n(integer) 350\n127.0.0.1:6379&gt; HGET counter page_view\n&quot;350&quot;\n# 尝试对字符串值的域执行HINCRBY命令\n127.0.0.1:6379&gt; HSET myhash string hello,world # 设定一个字符串值\n(integer) 1\n127.0.0.1:6379&gt; HGET myhash string\n&quot;hello,world&quot;\n127.0.0.1:6379&gt; HINCRBY myhash string 1 # 命令执行失败，错误\n(error) ERR hash value is not an integer\n127.0.0.1:6379&gt; HGET myhash string # 原值不变\n&quot;hello,world&quot;\n\n```\n### HINCRBYFLOAT\n- 为哈希表 key 中的域 field 加上浮点数增量 increment \n```\n# 值和增量都是普通小数\n127.0.0.1:6379&gt; HSET mykey field 10.50\n(integer) 1\n127.0.0.1:6379&gt; HINCRBYFLOAT mykey field 0.1\n&quot;10.6&quot;\n# 值和增量都是指数符号\n127.0.0.1:6379&gt; HSET mykey field 5.0e3\n(integer) 0\n127.0.0.1:6379&gt; HINCRBYFLOAT mykey field 2.0e2\n&quot;5200&quot;\n127.0.0.1:6379&gt; EXISTS price\n(integer) 0\n# 对不存在的键执行 HINCRBYFLOAT\n127.0.0.1:6379&gt; HINCRBYFLOAT price milk 3.5\n&quot;3.5&quot;\n127.0.0.1:6379&gt; HGETALL price\n1) &quot;milk&quot;\n2) &quot;3.5&quot;\n# 对不存在的域进行 HINCRBYFLOAT\n127.0.0.1:6379&gt; HGETALL price\n1) &quot;milk&quot;\n2) &quot;3.5&quot;\n127.0.0.1:6379&gt; HINCRBYFLOAT price coffee 4.5 # 新增 coffee 域\n&quot;4.5&quot;\n127.0.0.1:6379&gt; HGETALL price\n1) &quot;milk&quot;\n2) &quot;3.5&quot;\n3) &quot;coffee&quot;\n4) &quot;4.5&quot;\n```\n### HKEYS\n- 返回哈希表 key 中的所有域\n```\n# 哈希表非空\n127.0.0.1:6379&gt; HMSET website google www.google.com yahoo www.yahoo.com\nOK\n# 空哈希表/key不存在\n127.0.0.1:6379&gt; HKEYS website\n1) &quot;google&quot;\n2) &quot;yahoo&quot;\n127.0.0.1:6379&gt; EXISTS fake_key\n(integer) 0\n127.0.0.1:6379&gt; HKEYS fake_key\n(empty list or set)\n```\n### HLEN\n- 返回哈希表 key 中域的数量\n```\n127.0.0.1:6379&gt; HSET db redis redis.com\n(integer) 1\n127.0.0.1:6379&gt; HSET db mysql mysql.com\n(integer) 1\n127.0.0.1:6379&gt; HLEN db\n(integer) 2\n127.0.0.1:6379&gt; HSET db mongodb mongodb.org\n(integer) 1\n127.0.0.1:6379&gt; HLEN db\n(integer) 3\n```\n### HMGET\n- 返回哈希表 key 中，一个或多个给定域的值\n```\n127.0.0.1:6379&gt; HMSET pet dog &quot;doudou&quot; cat &quot;nounou&quot;\nOK\n127.0.0.1:6379&gt; HMGET pet dog cat fake_pet\n1) &quot;doudou&quot;\n2) &quot;nounou&quot;\n3) (nil)\n```\n### HMSET\n- 同时将多个 field-value (域-值)对设置到哈希表 key 中\n- 此命令会覆盖哈希表中已存在的域。\n- 如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作\n```\n127.0.0.1:6379&gt; HMSET website google www.google.com yahoo www.yahoo.com\nOK\n127.0.0.1:6379&gt; HGET website google\n&quot;www.google.com&quot;\n127.0.0.1:6379&gt; HGET website yahoo\n&quot;www.yahoo.com&quot;\n```\n### HSET\n- 将哈希表 key 中的域 field 的值设为 value \n- 如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作\n- 如果域 field 已经存在于哈希表中，旧值将被覆盖\n```\n127.0.0.1:6379&gt; HSET website google &quot;www.g.cn&quot;  # 设置一个新域\n(integer) 1\n127.0.0.1:6379&gt;  HSET website google &quot;www.google.com&quot;     # 覆盖一个旧域\n(integer) 0\n```\n### HSETNX\n- 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在\n- 若域 field 已经存在，该操作无效\n- 如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令\n```\nredis&gt; HSETNX nosql key-value-store redis\n(integer) 1\n\nredis&gt; HSETNX nosql key-value-store redis       # 操作无效，域 key-value-store 已存在\n(integer) 0\n```\n### HVALS\n- 返回哈希表 key 中所有域的值\n```\n# 非空哈希表\n127.0.0.1:6379&gt; HMSET website google www.google.com yahoo www.yahoo.com\nOK\n127.0.0.1:6379&gt; HVALS website\n1) &quot;www.google.com&quot;\n2) &quot;www.yahoo.com&quot;\n# 空哈希表/不存在的key\n127.0.0.1:6379&gt; EXISTS not_exists\n(integer) 0\n127.0.0.1:6379&gt; HVALS not_exists\n(empty list or set)\n```',0,'http://localhost/qipajun/?p=35',0,'post','',0),
	(37,1,'2017-03-26 13:51:42','2017-03-26 05:51:42','<ul>\n<li>探究thinkphp URL路由流程\n主流程  : > URL访问  > 路由配置参数解析 > 路由匹配实例化</li>\n</ul>\n\n<h2>探究thinkphp如何实现路由访问？怎么实现?</h2>\n\n<blockquote>\n  <ul>\n  <li>index模块建立test控制器id()方法</li>\n  </ul>\n</blockquote>\n\n路径<code>thinkphp_5.0.7_core/application/index/controller/test.php</code>\n\n<pre><code>&lt;?php\nnamespace app\\index\\controller;\n\nuse think\\console\\command\\make\\Model;\nuse think\\Controller;\nuse think\\Route;\n\nclass Test extends Controller\n{\n    public function id()\n    {\n       $id = input(\'id\');\n       return  sprintf(\'current page id %s\',$id);\n    }\n}\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>配置路由</li>\n  </ul>\n</blockquote>\n\n<code>thinkphp_5.0.7_core/application/route.php</code> 加入\n\n<pre><code>    \'[test]\'     =&gt; [\n        \':id\'   =&gt; [\'test/id\', [\'method\' =&gt; \'get\'], [\'id\' =&gt; \'\\d+\']],\n    ],\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>访问</li>\n  </ul>\n</blockquote>\n\nURL:<code>http://localhost/thinkphp_5.0.7_core/public/index.php/test/1</code>\n\n<blockquote>\n  <ul>\n  <li>探究thinkphp框架源码如何将<code>test/1</code>转到 <code>test/id</code></p></li>\n  <li><p>代码解读</p></li>\n  </ul>\n  \n  <blockquote>\n    <ul>\n    <li>入口文件进入 </li>\n    <li>index.php -> <code>require __DIR__ . \'/../thinkphp/start.php\';</code></li>\n    <li>run()方法</li>\n    <li>源码<code>App::run()-&gt;send();</code> </li>\n    <li>先执行<code>App::run()</code></li>\n    <li>进入App.php run方法</li>\n    <li>初始化配置</li>\n    <li>读取多语言</li>\n    <li>应用调度 <code>$dispatch = self::$dispatch;</code> 这里默认返回NULL 所以会走URLlu有检测\n    <code>$dispatch = self::routeCheck($request, $config);</code></li>\n    </ul>\n    \n    <blockquote>\n      <ul>\n      <li>路由检测</li>\n      <li>读取路由配置是否开启</li>\n      <li>读取路由配置参数  <code>Route::import($rules);</code></li>\n      <li>路由检测（根据路由定义返回不同的URL调度）<code>Route::check</code></li>\n      </ul>\n      \n      <blockquote>\n        <p>路由检测 <code>check</code>\n        - 根据请求类型获取对应路由规则\n        - 检测部署域名\n        - URL绑定\n        - 如果解析到路由 就执行 路由规则检测 <code>self::checkRoute</code>\n        \n        <blockquote>\n          <blockquote>\n            路由规则检测\n            - 通过路由检测方法 最终发出路由解析完参数配置数组\n          </blockquote>\n        </blockquote>\n      </blockquote>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<pre><code>            // +-\n</code></pre>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <blockquote>\n        <blockquote>\n          <blockquote>\n            <ul>\n            <li>第一次进入 </li>\n            </ul>\n          </blockquote>\n        </blockquote>\n      </blockquote>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<pre><code>$rules = array(\'test\' =&gt; true);\n</code></pre>\n\n<ul>\n<li>执行 <code>$item = self::getRouteExpress($key);</code></li>\n<li>执行 <code>if (is_array($rule))</code></li>\n<li>自调一次</li>\n</ul>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <blockquote>\n        <blockquote>\n          <blockquote>\n            <ul>\n            <li>第二次进入 </li>\n            </ul>\n          </blockquote>\n        </blockquote>\n      </blockquote>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<pre><code>$rules =  array (size=1)\n            0 =&gt;\n            array (size=5)\n            \'rule\' =&gt; string \':id\' (length=3)\n            \'route\' =&gt; string \'test/id\' (length=7)\n            \'var\' =&gt;\n            array (size=1)\n            \'id\' =&gt; int 1\n            \'option\' =&gt;\n            array (size=1)\n            \'method\' =&gt; string \'get\' (length=3)\n            \'pattern\' =&gt;\n            array (size=1)\n            \'id\' =&gt; string \'\\d+\' (length=3)\n</code></pre>\n\n<ul>\n<li>路由规则检查 <code>self::checkRule</code> 返回路由 模块 控制器 方法\n>>>>>>>  路由匹配 <code>self::match</code></li>\n<li>解析路由规则  <code>self::parseRule</code></li>\n<li>解析URL地址  模块/控制器/方法 <code>self::parseModule($route)</code></li>\n<li>找到返回源了  </li>\n</ul>\n\n<pre><code>return [\'type\' =&gt; \'module\', \'module\' =&gt; [$module, $controller, $action], \'convert\' =&gt; false];\n</code></pre>\n\n<blockquote>\n  <blockquote>\n    ... \n    - 中间省略\n  </blockquote>\n  \n  后续步骤\n</blockquote>\n\n<ul>\n<li>后续组合路由配置参数 > 解析成命名空间格式 > 映射实例化 > 获取映射方法内容返回 \n> 最终执行 send()将内容发送给客户端</li>\n</ul>\n\n<h2>总结</h2>\n\n<blockquote>\n  <ul>\n  <li>流程简要回顾</li>\n  <li>进入run 方法执行 -> 相关项目加载 \n  -> 路由检测 <code>self::routeCheck</code> -> 读取路由配置文件 -> 路由检测 <code>Route::check</code> ->  路由规则检测 <code>self::checkRoute</code>  -> 进入第一次 <code>$rules</code> 不包含路由规则  -> 执行<code>self::getRouteExpress($key)</code> 加载路由规则 -> 自调一次 -> 第二次进入 包含规则信息 -> 执行<code>self::checkRule</code> -> 对路由规则参数组合 -> 返回模块、控制器、方法信息\n  -> 执行映射类 -> 返回方法内容 -> 返回用户请求</li>\n  <li>简单来说</li>\n  </ul>\n</blockquote>\n\n就是将请求地址中的参数解析 ->  与路由中配置 -> 进行匹配 -> 如果存在就返回配置中对应模块、控制器、方法，后续实例化方法返回给客户端。\n\n-','thinkphp源码浅析-2.路由','','publish','closed','open','','thinkphp%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90-2-%e8%b7%af%e7%94%b1','','','2017-03-26 13:51:42','2017-03-26 05:51:42','- 探究thinkphp URL路由流程\n主流程  : > URL访问  > 路由配置参数解析 > 路由匹配实例化\n## 探究thinkphp如何实现路由访问？怎么实现?\n> -  index模块建立test控制器id()方法\n\n路径`thinkphp_5.0.7_core/application/index/controller/test.php`\n```\n&lt;?php\nnamespace app\\index\\controller;\n\nuse think\\console\\command\\make\\Model;\nuse think\\Controller;\nuse think\\Route;\n\nclass Test extends Controller\n{\n    public function id()\n    {\n       $id = input(&#039;id&#039;);\n       return  sprintf(&#039;current page id %s&#039;,$id);\n    }\n}\n```\n\n> -  配置路由\n\n`thinkphp_5.0.7_core/application/route.php` 加入\n```\n    &#039;[test]&#039;     =&gt; [\n        &#039;:id&#039;   =&gt; [&#039;test/id&#039;, [&#039;method&#039; =&gt; &#039;get&#039;], [&#039;id&#039; =&gt; &#039;\\d+&#039;]],\n    ],\n```\n> -  访问\n\nURL:`http://localhost/thinkphp_5.0.7_core/public/index.php/test/1`\n> -  探究thinkphp框架源码如何将`test/1`转到 `test/id`\n\n> -  代码解读\n\n>> -  入口文件进入 \n- index.php -> `require __DIR__ . \'/../thinkphp/start.php\';`\n>> -  run()方法\n- 源码`App::run()->send();` \n- 先执行`App::run()`\n>> - 进入App.php run方法\n- 初始化配置\n- 读取多语言\n- 应用调度 `$dispatch = self::$dispatch;` 这里默认返回NULL 所以会走URLlu有检测\n `$dispatch = self::routeCheck($request, $config);`\n\n>>> - 路由检测\n- 读取路由配置是否开启\n- 读取路由配置参数  `Route::import($rules);`\n- 路由检测（根据路由定义返回不同的URL调度）`Route::check`\n\n>>>> 路由检测 `check`\n- 根据请求类型获取对应路由规则\n- 检测部署域名\n- URL绑定\n- 如果解析到路由 就执行 路由规则检测 `self::checkRoute`\n\n>>>>>>  路由规则检测\n- 通过路由检测方法 最终发出路由解析完参数配置数组\n```\n            // +-\n```\n\n\n>>>>>> -   第一次进入 \n```\n$rules = array(&#039;test&#039; =&gt; true);\n```\n- 执行 `$item = self::getRouteExpress($key);`\n- 执行 `if (is_array($rule)) `\n- 自调一次\n\n>>>>>> -   第二次进入 \n```\n$rules =  array (size=1)\n            0 =&gt;\n            array (size=5)\n            &#039;rule&#039; =&gt; string &#039;:id&#039; (length=3)\n            &#039;route&#039; =&gt; string &#039;test/id&#039; (length=7)\n            &#039;var&#039; =&gt;\n            array (size=1)\n            &#039;id&#039; =&gt; int 1\n            &#039;option&#039; =&gt;\n            array (size=1)\n            &#039;method&#039; =&gt; string &#039;get&#039; (length=3)\n            &#039;pattern&#039; =&gt;\n            array (size=1)\n            &#039;id&#039; =&gt; string &#039;\\d+&#039; (length=3)\n```\n- 路由规则检查 `self::checkRule` 返回路由 模块 控制器 方法\n>>>>>>>  路由匹配 `self::match`\n-   解析路由规则  `self::parseRule`\n- 解析URL地址  模块/控制器/方法 `self::parseModule($route)`\n- 找到返回源了  \n```\nreturn [&#039;type&#039; =&gt; &#039;module&#039;, &#039;module&#039; =&gt; [$module, $controller, $action], &#039;convert&#039; =&gt; false];\n```\n>> ... \n- 中间省略\n\n\n> 后续步骤\n\n- 后续组合路由配置参数 > 解析成命名空间格式 > 映射实例化 > 获取映射方法内容返回 \n> 最终执行 send()将内容发送给客户端\n\n\n## 总结\n> -  流程简要回顾\n- 进入run 方法执行 -> 相关项目加载 \n-> 路由检测 `self::routeCheck` -> 读取路由配置文件 -> 路由检测 `Route::check` ->  路由规则检测 `self::checkRoute`  -> 进入第一次 `$rules` 不包含路由规则  -> 执行`self::getRouteExpress($key)` 加载路由规则 -> 自调一次 -> 第二次进入 包含规则信息 -> 执行`self::checkRule` -> 对路由规则参数组合 -> 返回模块、控制器、方法信息\n-> 执行映射类 -> 返回方法内容 -> 返回用户请求\n>-   简单来说\n\n  就是将请求地址中的参数解析 ->  与路由中配置 -> 进行匹配 -> 如果存在就返回配置中对应模块、控制器、方法，后续实例化方法返回给客户端。\n\n\n\n\n\n\n\n\n\n\n-',0,'http://localhost/qipajun/?p=37',0,'post','',0),
	(39,1,'2017-03-26 13:51:43','2017-03-26 05:51:43','<h1>thinkphp源码浅析-3.视图层解析流程</h1>\n\n<h3>1、建立控制器方法</h3>\n\n<ul>\n<li>路径 <code>thinkphp_5.0.7_core/application/index/controller/test.php</code></li>\n<li>代码  建立一个测试方法</li>\n</ul>\n\n<pre><code>    public function test($name = \"\")\n    {\n        $this-&gt;assign(\'name\',$name);\n        $res =  view(\'test\');\n        return $res;\n        //$this-&gt;display();\n    }\n</code></pre>\n\n<h3>2、建立视图模板文件</h3>\n\n<ul>\n<li>路径 <code>thinkphp_5.0.7_core/application/index/view/test/test.html</code></li>\n<li>代码</li>\n</ul>\n\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;hr /&gt;\n项目更目录:__ROOT__\n&lt;h1&gt;{$name}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<h3>3、目标 :</h3>\n\n<blockquote>\n  <ul>\n  <li>同过test控制器test方法:接收参数name,并将变量<code>$name</code> 赋值给视图模板层输出，探究其中运行即解析流程。</li>\n  </ul>\n</blockquote>\n\n<h3>4、运行流程</h3>\n\n<ul>\n<li>4.1 入口文件<code>index.php</code> </li>\n</ul>\n\n<pre><code>// 定义应用目录\ndefine(\'APP_PATH\', __DIR__ . \'/../application/\');\n// 加载框架引导文件\nrequire __DIR__ . \'/../thinkphp/start.php\';\n</code></pre>\n\n<ul>\n<li><strong>4.2 start.php</strong></li>\n</ul>\n\n<pre><code>require __DIR__ . \'/base.php\';\n// 执行应用\nApp::run()-&gt;send();\n</code></pre>\n\n<ul>\n<li><strong>4.2.1 App::run() 应用主体运行</strong></li>\n<li>4.2.1.1 实例化Request </li>\n</ul>\n\n<pre><code>is_null($request) &amp;&amp; $request = Request::instance();\n</code></pre>\n\n<ul>\n<li>4.2.1.2 初始化公共配置</li>\n</ul>\n\n<pre><code>$config = self::initCommon();\n</code></pre>\n\n<ul>\n<li>4.2.1.3 默认路由绑定</li>\n</ul>\n\n<pre><code>if (defined(\'BIND_MODULE\')) {\n    // 模块/控制器绑定\n    BIND_MODULE &amp;&amp; Route::bind(BIND_MODULE);\n} elseif ($config[\'auto_bind_module\']) {\n    // 入口自动绑定\n    $name = pathinfo($request-&gt;baseFile(), PATHINFO_FILENAME);\n    if ($name &amp;&amp; \'index\' != $name &amp;&amp; is_dir(APP_PATH . $name)) {\n        Route::bind($name);\n    }\n}\n</code></pre>\n\n<ul>\n<li>4.2.1.4 请求过滤 </li>\n</ul>\n\n<pre><code>$request-&gt;filter($config[\'default_filter\']);\n</code></pre>\n\n<ul>\n<li>4.2.1.5 多语言设置与加载</li>\n</ul>\n\n<pre><code>if ($config[\'lang_switch_on\']) {\n    // 开启多语言机制 检测当前语言\n    Lang::detect();\n} else {\n    // 读取默认语言\n    Lang::range($config[\'default_lang\']);\n}\n$request-&gt;langset(Lang::range());\n// 加载系统语言包\nLang::load([\n    THINK_PATH . \'lang\' . DS . $request-&gt;langset() . EXT,\n    APP_PATH . \'lang\' . DS . $request-&gt;langset() . EXT,\n]);\n</code></pre>\n\n<ul>\n<li>4.2.1.6  应用调度路由解析</li>\n</ul>\n\n<pre><code>$dispatch = self::$dispatch;\nif (empty($dispatch)) {\n    // +-\n    // 进行URL路由检测\n    $dispatch = self::routeCheck($request, $config);\n}\n// 记录当前调度信息\n$request-&gt;dispatch($dispatch);\n// 记录路由和请求信息\nif (self::$debug) {\n    Log::record(\'[ ROUTE ] \' . var_export($dispatch, true), \'info\');\n    Log::record(\'[ HEADER ] \' . var_export($request-&gt;header(), true), \'info\');\n    Log::record(\'[ PARAM ] \' . var_export($request-&gt;param(), true), \'info\');\n}\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>self::routeCheck($request, $config) 开始路由 thinkphp具体路由实现步骤存这里开始 <a href=\"http://www.qipajun.com/php/166.html\"><code>源码浅析一、路由</code></a></li>\n  </ul>\n</blockquote>\n\n<ul>\n<li>4.2.1.7  监听app_begin</li>\n</ul>\n\n<pre><code>Hook::listen(\'app_begin\', $dispatch);\n</code></pre>\n\n<ul>\n<li>4.2.1.8 请求缓存检查</li>\n</ul>\n\n<pre><code>$request-&gt;cache($config[\'request_cache\'], $config[\'request_cache_expire\'], $config[\'request_cache_except\']);\n</code></pre>\n\n<ul>\n<li>4.2.1.9 根据调度类型执行方法 跳转页面、控制器/方法加载等</li>\n</ul>\n\n<pre><code>switch ($dispatch[\'type\']) {\n    case \'redirect\':\n        // 执行重定向跳转\n        $data = Response::create($dispatch[\'url\'], \'redirect\')-&gt;code($dispatch[\'status\']);\n        break;\n    case \'module\':\n        // 模块/控制器/操作\n        $data = self::module($dispatch[\'module\'], $config, isset($dispatch[\'convert\']) ? $dispatch[\'convert\'] : null);\n\n        break;\n    case \'controller\':\n        // 执行控制器操作\n        $vars = array_merge(Request::instance()-&gt;param(), $dispatch[\'var\']);\n        $data = Loader::action($dispatch[\'controller\'], $vars, $config[\'url_controller_layer\'], $config[\'controller_suffix\']);\n        break;\n    case \'method\':\n        // 执行回调方法\n        $vars = array_merge(Request::instance()-&gt;param(), $dispatch[\'var\']);\n        $data = self::invokeMethod($dispatch[\'method\'], $vars);\n        break;\n    case \'function\':\n        // 执行闭包\n        $data = self::invokeFunction($dispatch[\'function\']);\n        break;\n    case \'response\':\n        $data = $dispatch[\'response\'];\n        break;\n    default:\n        throw new \\InvalidArgumentException(\'dispatch type not support\');\n}\n} catch (HttpResponseException $exception) {\n$data = $exception-&gt;getResponse();\n}\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>这里类型为 <code>module</code>  执行对应映射控制器、方法返回方法执行内容</li>\n  <li>映射时 会初始化一个视图<code>instance</code> => 初始化构造方法->初始化模板引擎$this->engine((array) $engine);</li>\n  </ul>\n</blockquote>\n\n<pre><code>//path thinkphp_5.0.7_core/thinkphp/library/think/View.php\n\n/**\n * 初始化视图\n * @access public\n * @param array $engine  模板引擎参数\n * @param array $replace  字符串替换参数\n * @return object\n */\npublic static function instance($engine = [], $replace = [])\n{\n    if (is_null(self::$instance)) {\n        self::$instance = new self($engine, $replace);\n    }\n    return self::$instance;\n}\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>执行时 <code>$res =  view(\'test\');</code>  创建一个<code>Response</code>对象\n  代码 路径<code>thinkphp_5.0.7_core/thinkphp/helper.php</code></li>\n  </ul>\n</blockquote>\n\n<pre><code>if (!function_exists(\'view\')) {\n    /**\n     * 渲染模板输出\n     * @param string    $template 模板文件\n     * @param array     $vars 模板变量\n     * @param array     $replace 模板替换\n     * @param integer   $code 状态码\n     * @return \\think\\response\\View\n     */\n    function view($template = \'\', $vars = [], $replace = [], $code = 200)\n    {\n        return Response::create($template, \'view\', $code)-&gt;replace($replace)-&gt;assign($vars);\n    }\n}\n</code></pre>\n\n<ul>\n<li>4.2.1.10 清空类的实例化</li>\n</ul>\n\n<pre><code>Loader::clearInstance();\n</code></pre>\n\n<ul>\n<li>4.2.1.11 输出数据到客户端 </li>\n</ul>\n\n<pre><code>if ($data instanceof Response) {\n            $response = $data;\n        } elseif (!is_null($data)) {\n            // 默认自动识别响应输出类型\n            $isAjax   = $request-&gt;isAjax();\n            $type     = $isAjax ? Config::get(\'default_ajax_return\') : Config::get(\'default_return_type\');\n            $response = Response::create($data, $type);\n        } else {\n            $response = Response::create();\n        }\n</code></pre>\n\n<ul>\n<li>4.2.1.12 监听app_end</li>\n</ul>\n\n<pre><code>Hook::listen(\'app_end\', $response);\n</code></pre>\n\n<ul>\n<li>4.2.1.13 返回</li>\n</ul>\n\n<pre><code>return $response;\n</code></pre>\n\n<ul>\n<li><strong>4.2.2 <code>App::run()-&gt;send();</code> 发送数据到客户端</strong></li>\n<li>都数据返回给客户端了？那么内容标签解析呢？哪里执行的？这里说明下如果控制器使用的是<code>print</code>、<code>echo</code>等直接输出打印的，那么映射控制器方法的时候是会直接接收到内容，其它返回还需接收处理(模板标签替换也在这块执行)。接下来流程:接收处理数据->编辑header(状态码、信息头等) -> 输出内容->用户端接收响应。</li>\n<li><strong>4.2.2.1 输出数据处理</strong></li>\n</ul>\n\n<pre><code>$data = $this-&gt;getContent();  // 返回html页面内容\n</code></pre>\n\n<ul>\n<li><code>getContent()</code>代码</li>\n</ul>\n\n<pre><code>/**\n * 获取输出数据\n * @return mixed\n */\npublic function getContent()\n{\n    if (null == $this-&gt;content) {\n        // +-\n\n        $content = $this-&gt;output($this-&gt;data);\n        // +-\n        if (null !== $content &amp;&amp; !is_string($content) &amp;&amp; !is_numeric($content) &amp;&amp; !is_callable([\n            $content,\n            \'__toString\',\n        ])\n        ) {\n            throw new \\InvalidArgumentException(sprintf(\'variable type error： %s\', gettype($content)));\n        }\n\n        $this-&gt;content = (string) $content;\n    }\n    return $this-&gt;content;\n}\n</code></pre>\n\n<ul>\n<li>接着<code>output()</code></li>\n</ul>\n\n<pre><code>//path thinkphp_5.0.7_core/thinkphp/library/think/Response.php\n $content = $this-&gt;output($this-&gt;data); \n</code></pre>\n\n<ul>\n<li>这里需注意，虽然<code>think\\Response</code> 当前自身类中有<code>output()</code>方法，但是却不是执行自身的<code>output()</code>方法，而是由于在<code>run()</code>方法,映射类的时候<code>test</code>方法<code>view</code>时已经创建了实例，~~<code>如果控制器中未实例化view实例在是在通过 Response::create()</code>创建了<code>think\\response\\View</code>实例，~~后续操作的也是view实例，所以这里的<code>$this-&gt;output($this-&gt;data)</code> 自然操作的是<code>think\\response\\View</code>类的<code>putout()</code>方法^_^</li>\n<li>4.2.2.2 初始化视图 <code>ViewTemplate::instance</code></li>\n</ul>\n\n<pre><code>//path think\\View   instance()\nViewTemplate::instance(Config::get(\'template\'), Config::get(\'view_replace_str\'));// -&gt;fetch($data, $this-&gt;vars, $this-&gt;replace);\n</code></pre>\n\n<ul>\n<li>4.2.2.3 渲染模板文件 <code>fetch</code></li>\n</ul>\n\n<pre><code>//path think\\View   fetch()\n/**\n * 解析和获取模板内容 用于输出\n * @param string    $template 模板文件名或者内容\n * @param array     $vars     模板输出变量\n * @param array     $replace 替换内容\n * @param array     $config     模板参数\n * @param bool      $renderContent     是否渲染内容\n * @return string\n * @throws Exception\n */\npublic function fetch($template = \'\', $vars = [], $replace = [], $config = [], $renderContent = false)\n{\n    // 模板变量\n    $vars = array_merge(self::$var, $this-&gt;data, $vars);\n    // +-\n\n\n    // 页面缓存\n    ob_start();\n    ob_implicit_flush(0);\n\n    // 渲染输出\n    $method = $renderContent ? \'display\' : \'fetch\';\n    // +-\n    //var_dump($method); //fetch\n   $res = $this-&gt;engine-&gt;$method($template, $vars, $config);\n   // var_dump($this-&gt;engine); //thinkphp_5.0.7_core/thinkphp/library/think/View.php\n    // 获取并清空缓存\n    $content = ob_get_clean();\n    // 内容过滤标签\n    Hook::listen(\'view_filter\', $content);\n    // 允许用户自定义模板的字符串替换\n\n    $replace = array_merge($this-&gt;replace, $replace);\n    // +-\n    if (!empty($replace)) {\n        // +-\n        $content = strtr($content, $replace);\n    }\n    return $content;\n}\n</code></pre>\n\n<ul>\n<li><p>模板处理</p></li>\n<li><p><code>$res = $this-&gt;engine-&gt;$method($template, $vars, $config);</code>  这里<code>$method</code>为fetch</p></li>\n</ul>\n\n<pre><code> path think\\Template fetch() \n /**\n * 渲染模板文件\n * @access public\n * @param string    $template 模板文件\n * @param array     $vars 模板变量\n * @param array     $config 模板参数\n * @return void\n */\npublic function fetch($template, $vars = [], $config = [])\n{\n    //var_dump($template,$vars,$config);\n    // +-\n    if ($vars) {\n        $this-&gt;data = $vars;\n    }\n    if ($config) {\n        $this-&gt;config($config);\n    }\n\n    if (!empty($this-&gt;config[\'cache_id\']) &amp;&amp; $this-&gt;config[\'display_cache\']) {\n        // 读取渲染缓存\n        $cacheContent = Cache::get($this-&gt;config[\'cache_id\']);\n        if (false !== $cacheContent) {\n            echo $cacheContent;\n            return;\n        }\n    }\n    $template = $this-&gt;parseTemplateFile($template);\n    // +-\n\n    if ($template) {\n        $cacheFile = $this-&gt;config[\'cache_path\'] . $this-&gt;config[\'cache_prefix\'] . md5($template) . \'.\' . ltrim($this-&gt;config[\'cache_suffix\'], \'.\');\n        // +-\n        if (!$this-&gt;checkCache($cacheFile)) {\n            // 缓存无效 重新模板编译\n            // +-\n            $content = file_get_contents($template);\n            // +-\n            $this-&gt;compiler($content, $cacheFile);\n        }\n        // 页面缓存\n        ob_start();\n        ob_implicit_flush(0);\n        // 读取编译存储\n        $this-&gt;storage-&gt;read($cacheFile, $this-&gt;data);\n        // 获取并清空缓存\n        $content = ob_get_clean();\n        if (!empty($this-&gt;config[\'cache_id\']) &amp;&amp; $this-&gt;config[\'display_cache\']) {\n            // 缓存页面输出\n            Cache::set($this-&gt;config[\'cache_id\'], $content, $this-&gt;config[\'cache_time\']);\n        }\n        echo $content;\n    }\n}\n</code></pre>\n\n<ul>\n<li>编译视图文件 <code>$this-&gt;compiler($content, $cacheFile);</code></li>\n</ul>\n\n<pre><code>$this-&gt;compiler($content, $cacheFile);\npath think\\Template compiler()\n    /**\n     * 编译模板文件内容\n     * @access private\n     * @param string    $content 模板内容\n     * @param string    $cacheFile 缓存文件名\n     * @return void\n     */\n    private function compiler(&amp;$content, $cacheFile)\n    {\n        // 判断是否启用布局\n        if ($this-&gt;config[\'layout_on\']) {\n            if (false !== strpos($content, \'{__NOLAYOUT__}\')) {\n                // 可以单独定义不使用布局\n                $content = str_replace(\'{__NOLAYOUT__}\', \'\', $content);\n            } else {\n                // 读取布局模板\n                $layoutFile = $this-&gt;parseTemplateFile($this-&gt;config[\'layout_name\']);\n                if ($layoutFile) {\n                    // 替换布局的主体内容\n                    $content = str_replace($this-&gt;config[\'layout_item\'], $content, file_get_contents($layoutFile));\n                }\n            }\n        } else {\n            $content = str_replace(\'{__NOLAYOUT__}\', \'\', $content);\n        }\n\n        //var_dump($content); 解析前\n        // +-\n        // 模板解析\n        $this-&gt;parse($content);\n\n        /**\n        //var_dump($content); 解析后\n        // +-\n        */\n\n\n        if ($this-&gt;config[\'strip_space\']) {\n            /* 去除html空格与换行 */\n            $find    = [\'~&gt;\\s+&lt;~\', \'~&gt;(\\s+\\n|\\r)~\'];\n            $replace = [\'&gt;&lt;\', \'&gt;\'];\n            $content = preg_replace($find, $replace, $content);\n        }\n        // 优化生成的php代码\n        $content = preg_replace(\'/\\?&gt;\\s*&lt;\\?php\\s(?!echo\\b)/s\', \'\', $content);\n        // 模板过滤输出\n        $replace = $this-&gt;config[\'tpl_replace_string\'];\n        $content = str_replace(array_keys($replace), array_values($replace), $content);\n        // 添加安全代码及模板引用记录\n        $content = \'&lt;?php if (!defined(\\\'THINK_PATH\\\')) exit(); /*\' . serialize($this-&gt;includeFile) . \'*/ ?&gt;\' . \"\\n\" . $content;\n        // 编译存储\n        $this-&gt;storage-&gt;write($cacheFile, $content);\n        $this-&gt;includeFile = [];\n        return;\n    }\n</code></pre>\n\n<ul>\n<li>模板解析入口<code>parse</code></li>\n</ul>\n\n<pre><code>path think\\Template parse()\n    /**\n     * 模板解析入口\n     * 支持普通标签和TagLib解析 支持自定义标签库\n     * @access public\n     * @param string $content 要解析的模板内容\n     * @return void\n     */\n    public function parse(&amp;$content)\n    {\n        // 内容为空不解析\n        if (empty($content)) {\n            return;\n        }\n\n        // 替换literal标签内容\n        // +-\n        $this-&gt;parseLiteral($content);\n\n        // 解析继承\n        // +-\n        $this-&gt;parseExtend($content);\n\n\n        // 解析布局\n        // +-\n        $this-&gt;parseLayout($content);\n\n        // 检查include语法\n        // +-\n        $this-&gt;parseInclude($content);\n\n        // 替换包含文件中literal标签内容\n        $this-&gt;parseLiteral($content);\n\n        // 检查PHP语法\n        $this-&gt;parsePhp($content);\n\n        // 获取需要引入的标签库列表\n        // 标签库只需要定义一次，允许引入多个一次\n        // 一般放在文件的最前面\n        // 格式：&lt;taglib name=\"html,mytag...\" /&gt;\n        // 当TAGLIB_LOAD配置为true时才会进行检测\n        if ($this-&gt;config[\'taglib_load\']) {\n            $tagLibs = $this-&gt;getIncludeTagLib($content);\n            if (!empty($tagLibs)) {\n                // 对导入的TagLib进行解析\n                foreach ($tagLibs as $tagLibName) {\n                    $this-&gt;parseTagLib($tagLibName, $content);\n                }\n            }\n        }\n        // 预先加载的标签库 无需在每个模板中使用taglib标签加载 但必须使用标签库XML前缀\n        if ($this-&gt;config[\'taglib_pre_load\']) {\n            $tagLibs = explode(\',\', $this-&gt;config[\'taglib_pre_load\']);\n            foreach ($tagLibs as $tag) {\n                $this-&gt;parseTagLib($tag, $content);\n            }\n        }\n        // 内置标签库 无需使用taglib标签导入就可以使用 并且不需使用标签库XML前缀\n        $tagLibs = explode(\',\', $this-&gt;config[\'taglib_build_in\']);\n        foreach ($tagLibs as $tag) {\n            $this-&gt;parseTagLib($tag, $content, true);\n        }\n        // 解析普通模板标签 {$tagName}\n        $this-&gt;parseTag($content);\n\n        // 还原被替换的Literal标签\n        $this-&gt;parseLiteral($content, true);\n        return;\n    }\n\n</code></pre>\n\n<ul>\n<li>至此内容模板标签解析完成，接下来返回APP，继续执行send剩余代码，编辑header状态码、头信息->输出内容->执行响应->清空本次请求,整个响应用户操作结束。</li>\n</ul>','thinkphp源码浅析-3.视图层解析流程','','publish','closed','open','','thinkphp%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90-3-%e8%a7%86%e5%9b%be%e5%b1%82%e8%a7%a3%e6%9e%90%e6%b5%81%e7%a8%8b','','','2017-03-26 13:51:43','2017-03-26 05:51:43','# thinkphp源码浅析-3.视图层解析流程\n### 1、建立控制器方法\n- 路径 `thinkphp_5.0.7_core/application/index/controller/test.php`\n-   代码  建立一个测试方法\n```\n    public function test($name = &quot;&quot;)\n    {\n        $this-&gt;assign(&#039;name&#039;,$name);\n        $res =  view(&#039;test&#039;);\n        return $res;\n        //$this-&gt;display();\n    }\n```\n### 2、建立视图模板文件\n-  路径 `thinkphp_5.0.7_core/application/index/view/test/test.html`\n- 代码\n```\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;hr /&gt;\n项目更目录:__ROOT__\n&lt;h1&gt;{$name}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n```\n### 3、目标 : \n> -  同过test控制器test方法:接收参数name,并将变量`$name` 赋值给视图模板层输出，探究其中运行即解析流程。\n \n### 4、运行流程\n- 4.1 入口文件`index.php` \n```\n// 定义应用目录\ndefine(&#039;APP_PATH&#039;, __DIR__ . &#039;/../application/&#039;);\n// 加载框架引导文件\nrequire __DIR__ . &#039;/../thinkphp/start.php&#039;;\n```\n- **4.2 start.php**\n```\nrequire __DIR__ . &#039;/base.php&#039;;\n// 执行应用\nApp::run()-&gt;send();\n```\n- **4.2.1 App::run() 应用主体运行**\n- 4.2.1.1 实例化Request \n```\nis_null($request) &amp;&amp; $request = Request::instance();\n```\n- 4.2.1.2 初始化公共配置\n```\n$config = self::initCommon();\n```\n- 4.2.1.3 默认路由绑定\n```\nif (defined(&#039;BIND_MODULE&#039;)) {\n    // 模块/控制器绑定\n    BIND_MODULE &amp;&amp; Route::bind(BIND_MODULE);\n} elseif ($config[&#039;auto_bind_module&#039;]) {\n    // 入口自动绑定\n    $name = pathinfo($request-&gt;baseFile(), PATHINFO_FILENAME);\n    if ($name &amp;&amp; &#039;index&#039; != $name &amp;&amp; is_dir(APP_PATH . $name)) {\n        Route::bind($name);\n    }\n}\n```\n- 4.2.1.4 请求过滤 \n```\n$request-&gt;filter($config[&#039;default_filter&#039;]);\n```\n- 4.2.1.5 多语言设置与加载\n```\nif ($config[&#039;lang_switch_on&#039;]) {\n    // 开启多语言机制 检测当前语言\n    Lang::detect();\n} else {\n    // 读取默认语言\n    Lang::range($config[&#039;default_lang&#039;]);\n}\n$request-&gt;langset(Lang::range());\n// 加载系统语言包\nLang::load([\n    THINK_PATH . &#039;lang&#039; . DS . $request-&gt;langset() . EXT,\n    APP_PATH . &#039;lang&#039; . DS . $request-&gt;langset() . EXT,\n]);\n```\n- 4.2.1.6  应用调度路由解析\n```\n$dispatch = self::$dispatch;\nif (empty($dispatch)) {\n    // +-\n    // 进行URL路由检测\n    $dispatch = self::routeCheck($request, $config);\n}\n// 记录当前调度信息\n$request-&gt;dispatch($dispatch);\n// 记录路由和请求信息\nif (self::$debug) {\n    Log::record(&#039;[ ROUTE ] &#039; . var_export($dispatch, true), &#039;info&#039;);\n    Log::record(&#039;[ HEADER ] &#039; . var_export($request-&gt;header(), true), &#039;info&#039;);\n    Log::record(&#039;[ PARAM ] &#039; . var_export($request-&gt;param(), true), &#039;info&#039;);\n}\n```\n> - self::routeCheck($request, $config) 开始路由 thinkphp具体路由实现步骤存这里开始 [`源码浅析一、路由`](http://www.qipajun.com/php/166.html)\n\n\n- 4.2.1.7  监听app_begin\n```\nHook::listen(&#039;app_begin&#039;, $dispatch);\n```\n\n- 4.2.1.8 请求缓存检查\n```\n$request-&gt;cache($config[&#039;request_cache&#039;], $config[&#039;request_cache_expire&#039;], $config[&#039;request_cache_except&#039;]);\n```\n- 4.2.1.9 根据调度类型执行方法 跳转页面、控制器/方法加载等\n```\nswitch ($dispatch[&#039;type&#039;]) {\n    case &#039;redirect&#039;:\n        // 执行重定向跳转\n        $data = Response::create($dispatch[&#039;url&#039;], &#039;redirect&#039;)-&gt;code($dispatch[&#039;status&#039;]);\n        break;\n    case &#039;module&#039;:\n        // 模块/控制器/操作\n        $data = self::module($dispatch[&#039;module&#039;], $config, isset($dispatch[&#039;convert&#039;]) ? $dispatch[&#039;convert&#039;] : null);\n\n        break;\n    case &#039;controller&#039;:\n        // 执行控制器操作\n        $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#039;var&#039;]);\n        $data = Loader::action($dispatch[&#039;controller&#039;], $vars, $config[&#039;url_controller_layer&#039;], $config[&#039;controller_suffix&#039;]);\n        break;\n    case &#039;method&#039;:\n        // 执行回调方法\n        $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#039;var&#039;]);\n        $data = self::invokeMethod($dispatch[&#039;method&#039;], $vars);\n        break;\n    case &#039;function&#039;:\n        // 执行闭包\n        $data = self::invokeFunction($dispatch[&#039;function&#039;]);\n        break;\n    case &#039;response&#039;:\n        $data = $dispatch[&#039;response&#039;];\n        break;\n    default:\n        throw new \\InvalidArgumentException(&#039;dispatch type not support&#039;);\n}\n} catch (HttpResponseException $exception) {\n$data = $exception-&gt;getResponse();\n}\n```\n> -  这里类型为 `module`  执行对应映射控制器、方法返回方法执行内容\n> - 映射时 会初始化一个视图`instance` => 初始化构造方法->初始化模板引擎$this->engine((array) $engine);\n```\n//path thinkphp_5.0.7_core/thinkphp/library/think/View.php\n\n/**\n * 初始化视图\n * @access public\n * @param array $engine  模板引擎参数\n * @param array $replace  字符串替换参数\n * @return object\n */\npublic static function instance($engine = [], $replace = [])\n{\n    if (is_null(self::$instance)) {\n        self::$instance = new self($engine, $replace);\n    }\n    return self::$instance;\n}\n```\n\n> - 执行时 `$res =  view(\'test\');`  创建一个`Response`对象\n> 代码 路径`thinkphp_5.0.7_core/thinkphp/helper.php`\n```\nif (!function_exists(&#039;view&#039;)) {\n    /**\n     * 渲染模板输出\n     * @param string    $template 模板文件\n     * @param array     $vars 模板变量\n     * @param array     $replace 模板替换\n     * @param integer   $code 状态码\n     * @return \\think\\response\\View\n     */\n    function view($template = &#039;&#039;, $vars = [], $replace = [], $code = 200)\n    {\n        return Response::create($template, &#039;view&#039;, $code)-&gt;replace($replace)-&gt;assign($vars);\n    }\n}\n```\n- 4.2.1.10 清空类的实例化\n```\nLoader::clearInstance();\n```\n- 4.2.1.11 输出数据到客户端 \n```\nif ($data instanceof Response) {\n            $response = $data;\n        } elseif (!is_null($data)) {\n            // 默认自动识别响应输出类型\n            $isAjax   = $request-&gt;isAjax();\n            $type     = $isAjax ? Config::get(&#039;default_ajax_return&#039;) : Config::get(&#039;default_return_type&#039;);\n            $response = Response::create($data, $type);\n        } else {\n            $response = Response::create();\n        }\n```\n- 4.2.1.12 监听app_end\n```\nHook::listen(&#039;app_end&#039;, $response);\n```\n- 4.2.1.13 返回\n```\nreturn $response;\n```\n-  **4.2.2 `App::run()->send();` 发送数据到客户端**\n- 都数据返回给客户端了？那么内容标签解析呢？哪里执行的？这里说明下如果控制器使用的是`print`、`echo`等直接输出打印的，那么映射控制器方法的时候是会直接接收到内容，其它返回还需接收处理(模板标签替换也在这块执行)。接下来流程:接收处理数据->编辑header(状态码、信息头等) -> 输出内容->用户端接收响应。\n- **4.2.2.1 输出数据处理**\n```\n$data = $this-&gt;getContent();  // 返回html页面内容\n```\n- `getContent()`代码\n```\n/**\n * 获取输出数据\n * @return mixed\n */\npublic function getContent()\n{\n    if (null == $this-&gt;content) {\n        // +-\n\n        $content = $this-&gt;output($this-&gt;data);\n        // +-\n        if (null !== $content &amp;&amp; !is_string($content) &amp;&amp; !is_numeric($content) &amp;&amp; !is_callable([\n            $content,\n            &#039;__toString&#039;,\n        ])\n        ) {\n            throw new \\InvalidArgumentException(sprintf(&#039;variable type error： %s&#039;, gettype($content)));\n        }\n\n        $this-&gt;content = (string) $content;\n    }\n    return $this-&gt;content;\n}\n```\n- 接着`output()`\n```\n//path thinkphp_5.0.7_core/thinkphp/library/think/Response.php\n $content = $this-&gt;output($this-&gt;data); \n```\n- 这里需注意，虽然`think\\Response` 当前自身类中有`output()`方法，但是却不是执行自身的`output()`方法，而是由于在`run()`方法,映射类的时候`test`方法`view`时已经创建了实例，~~`如果控制器中未实例化view实例在是在通过 Response::create()`创建了`think\\response\\View`实例，~~后续操作的也是view实例，所以这里的`$this->output($this->data)` 自然操作的是`think\\response\\View`类的`putout()`方法^_^\n- 4.2.2.2 初始化视图 `ViewTemplate::instance`\n```\n//path think\\View   instance()\nViewTemplate::instance(Config::get(&#039;template&#039;), Config::get(&#039;view_replace_str&#039;));// -&gt;fetch($data, $this-&gt;vars, $this-&gt;replace);\n```\n- 4.2.2.3 渲染模板文件 `fetch`\n```\n//path think\\View   fetch()\n/**\n * 解析和获取模板内容 用于输出\n * @param string    $template 模板文件名或者内容\n * @param array     $vars     模板输出变量\n * @param array     $replace 替换内容\n * @param array     $config     模板参数\n * @param bool      $renderContent     是否渲染内容\n * @return string\n * @throws Exception\n */\npublic function fetch($template = &#039;&#039;, $vars = [], $replace = [], $config = [], $renderContent = false)\n{\n    // 模板变量\n    $vars = array_merge(self::$var, $this-&gt;data, $vars);\n    // +-\n\n\n    // 页面缓存\n    ob_start();\n    ob_implicit_flush(0);\n\n    // 渲染输出\n    $method = $renderContent ? &#039;display&#039; : &#039;fetch&#039;;\n    // +-\n    //var_dump($method); //fetch\n   $res = $this-&gt;engine-&gt;$method($template, $vars, $config);\n   // var_dump($this-&gt;engine); //thinkphp_5.0.7_core/thinkphp/library/think/View.php\n    // 获取并清空缓存\n    $content = ob_get_clean();\n    // 内容过滤标签\n    Hook::listen(&#039;view_filter&#039;, $content);\n    // 允许用户自定义模板的字符串替换\n\n    $replace = array_merge($this-&gt;replace, $replace);\n    // +-\n    if (!empty($replace)) {\n        // +-\n        $content = strtr($content, $replace);\n    }\n    return $content;\n}\n```\n\n- 模板处理\n\n\n- `$res = $this->engine->$method($template, $vars, $config);`  这里`$method`为fetch \n\n```\n path think\\Template fetch() \n /**\n * 渲染模板文件\n * @access public\n * @param string    $template 模板文件\n * @param array     $vars 模板变量\n * @param array     $config 模板参数\n * @return void\n */\npublic function fetch($template, $vars = [], $config = [])\n{\n    //var_dump($template,$vars,$config);\n    // +-\n    if ($vars) {\n        $this-&gt;data = $vars;\n    }\n    if ($config) {\n        $this-&gt;config($config);\n    }\n\n    if (!empty($this-&gt;config[&#039;cache_id&#039;]) &amp;&amp; $this-&gt;config[&#039;display_cache&#039;]) {\n        // 读取渲染缓存\n        $cacheContent = Cache::get($this-&gt;config[&#039;cache_id&#039;]);\n        if (false !== $cacheContent) {\n            echo $cacheContent;\n            return;\n        }\n    }\n    $template = $this-&gt;parseTemplateFile($template);\n    // +-\n\n    if ($template) {\n        $cacheFile = $this-&gt;config[&#039;cache_path&#039;] . $this-&gt;config[&#039;cache_prefix&#039;] . md5($template) . &#039;.&#039; . ltrim($this-&gt;config[&#039;cache_suffix&#039;], &#039;.&#039;);\n        // +-\n        if (!$this-&gt;checkCache($cacheFile)) {\n            // 缓存无效 重新模板编译\n            // +-\n            $content = file_get_contents($template);\n            // +-\n            $this-&gt;compiler($content, $cacheFile);\n        }\n        // 页面缓存\n        ob_start();\n        ob_implicit_flush(0);\n        // 读取编译存储\n        $this-&gt;storage-&gt;read($cacheFile, $this-&gt;data);\n        // 获取并清空缓存\n        $content = ob_get_clean();\n        if (!empty($this-&gt;config[&#039;cache_id&#039;]) &amp;&amp; $this-&gt;config[&#039;display_cache&#039;]) {\n            // 缓存页面输出\n            Cache::set($this-&gt;config[&#039;cache_id&#039;], $content, $this-&gt;config[&#039;cache_time&#039;]);\n        }\n        echo $content;\n    }\n}\n```\n\n\n-  编译视图文件 `$this->compiler($content, $cacheFile);`\n```\n$this->compiler($content, $cacheFile);\npath think\\Template compiler()\n    /**\n     * 编译模板文件内容\n     * @access private\n     * @param string    $content 模板内容\n     * @param string    $cacheFile 缓存文件名\n     * @return void\n     */\n    private function compiler(&$content, $cacheFile)\n    {\n        // 判断是否启用布局\n        if ($this->config[\'layout_on\']) {\n            if (false !== strpos($content, \'{__NOLAYOUT__}\')) {\n                // 可以单独定义不使用布局\n                $content = str_replace(\'{__NOLAYOUT__}\', \'\', $content);\n            } else {\n                // 读取布局模板\n                $layoutFile = $this->parseTemplateFile($this->config[\'layout_name\']);\n                if ($layoutFile) {\n                    // 替换布局的主体内容\n                    $content = str_replace($this->config[\'layout_item\'], $content, file_get_contents($layoutFile));\n                }\n            }\n        } else {\n            $content = str_replace(\'{__NOLAYOUT__}\', \'\', $content);\n        }\n\n        //var_dump($content); 解析前\n        // +-\n        // 模板解析\n        $this->parse($content);\n\n        /**\n        //var_dump($content); 解析后\n        // +-\n        */\n\n\n        if ($this->config[\'strip_space\']) {\n            /* 去除html空格与换行 */\n            $find    = [\'~>\\s+<~\', \'~>(\\s+\\n|\\r)~\'];\n            $replace = [\'><\', \'>\'];\n            $content = preg_replace($find, $replace, $content);\n        }\n        // 优化生成的php代码\n        $content = preg_replace(\'/\\?>\\s*<\\?php\\s(?!echo\\b)/s\', \'\', $content);\n        // 模板过滤输出\n        $replace = $this->config[\'tpl_replace_string\'];\n        $content = str_replace(array_keys($replace), array_values($replace), $content);\n        // 添加安全代码及模板引用记录\n        $content = \'<?php if (!defined(\\\'THINK_PATH\\\')) exit(); /*\' . serialize($this->includeFile) . \'*/ ?>\' . \"\\n\" . $content;\n        // 编译存储\n        $this->storage->write($cacheFile, $content);\n        $this->includeFile = [];\n        return;\n    }\n```\n\n\n\n- 模板解析入口`parse`\n```\npath think\\Template parse()\n    /**\n     * 模板解析入口\n     * 支持普通标签和TagLib解析 支持自定义标签库\n     * @access public\n     * @param string $content 要解析的模板内容\n     * @return void\n     */\n    public function parse(&amp;$content)\n    {\n        // 内容为空不解析\n        if (empty($content)) {\n            return;\n        }\n\n        // 替换literal标签内容\n        // +-\n        $this-&gt;parseLiteral($content);\n\n        // 解析继承\n        // +-\n        $this-&gt;parseExtend($content);\n\n\n        // 解析布局\n        // +-\n        $this-&gt;parseLayout($content);\n\n        // 检查include语法\n        // +-\n        $this-&gt;parseInclude($content);\n\n        // 替换包含文件中literal标签内容\n        $this-&gt;parseLiteral($content);\n\n        // 检查PHP语法\n        $this-&gt;parsePhp($content);\n\n        // 获取需要引入的标签库列表\n        // 标签库只需要定义一次，允许引入多个一次\n        // 一般放在文件的最前面\n        // 格式：&lt;taglib name=&quot;html,mytag...&quot; /&gt;\n        // 当TAGLIB_LOAD配置为true时才会进行检测\n        if ($this-&gt;config[&#039;taglib_load&#039;]) {\n            $tagLibs = $this-&gt;getIncludeTagLib($content);\n            if (!empty($tagLibs)) {\n                // 对导入的TagLib进行解析\n                foreach ($tagLibs as $tagLibName) {\n                    $this-&gt;parseTagLib($tagLibName, $content);\n                }\n            }\n        }\n        // 预先加载的标签库 无需在每个模板中使用taglib标签加载 但必须使用标签库XML前缀\n        if ($this-&gt;config[&#039;taglib_pre_load&#039;]) {\n            $tagLibs = explode(&#039;,&#039;, $this-&gt;config[&#039;taglib_pre_load&#039;]);\n            foreach ($tagLibs as $tag) {\n                $this-&gt;parseTagLib($tag, $content);\n            }\n        }\n        // 内置标签库 无需使用taglib标签导入就可以使用 并且不需使用标签库XML前缀\n        $tagLibs = explode(&#039;,&#039;, $this-&gt;config[&#039;taglib_build_in&#039;]);\n        foreach ($tagLibs as $tag) {\n            $this-&gt;parseTagLib($tag, $content, true);\n        }\n        // 解析普通模板标签 {$tagName}\n        $this-&gt;parseTag($content);\n\n        // 还原被替换的Literal标签\n        $this-&gt;parseLiteral($content, true);\n        return;\n    }\n\n```\n- 至此内容模板标签解析完成，接下来返回APP，继续执行send剩余代码，编辑header状态码、头信息->输出内容->执行响应->清空本次请求,整个响应用户操作结束。',0,'http://localhost/qipajun/?p=39',0,'post','',0),
	(41,1,'2017-03-26 13:51:43','2017-03-26 05:51:43','<h2>php 前++和后++区别  趣味题</h2>\n\n<ul>\n<li>前++  先自增在返回</li>\n</ul>\n\n<pre><code>$y = 0;\n$y = ++$y;\nvar_dump($y); //1\n\n$y = 0;\n$i=$y+1;$y=$i;\nvar_dump($y); //1\n</code></pre>\n\n<ul>\n<li>后++ 先返回再自增</li>\n</ul>\n\n<pre><code>$y = 0;\n$y = $y++;\nvar_dump($y); //0\n\n$i = 0;\n$y=$i;$i=$i+1;\nvar_dump($y); //0\n</code></pre>\n\n<ul>\n<li>趣味题</li>\n</ul>\n\n<pre><code>$count = 5;\nfunction get_count() {\n    static $count = 0;\n    $res = $count++;\n    return $res;\n}\n++$count;\nget_count();\necho get_count();   // 1 //原因 先返回后自增\n</code></pre>\n\n<ul>\n<li>自动类型转换判断</li>\n</ul>\n\n<pre><code>$arr = array(0=&gt;1,\"aa\"=&gt;2, 3, 4);\n\nforeach($arr as $key=&gt;$val){\n    print($key == \"aa\" ? 5 : $val);\n}\n//5534\nvar_dump(0 == \'aa\');    //bool(true)\nvar_dump(\'0\' == \'aa\');   //bool(false)\n</code></pre>\n\n<blockquote>\n  在PHP中两个值进行逻辑判断时，如果两个值的类型不一致PHP会自动把右边的值转换到左边的类型，然后再进行判断。因此\"aa\"转换整形等于0，自然也就等于左边的0了，相反如果将0换成字符串，就不会隐式转换类型了，比较自然不相同了。\n  - printf\n</blockquote>\n\n<pre><code>$i=\'11\';\nprintf(\"%d\\n\",printf(\"%d\",printf(\"%d\",$i))); //1121\n</code></pre>\n\n<blockquote>\n  printf不仅是打印函数,而且返回字符串长度\n</blockquote>\n\n<pre><code>$res = printf(\'%d\',11);\nvar_dump($res); //2\n$res = printf(\'%d\',1);\nvar_dump($res); //1\n</code></pre>\n\n<ul>\n<li>if语句</li>\n</ul>\n\n<pre><code>$a = 3;\n$b = 5;\nif($a = 5 || $b = 7) {\n    $a++;\n    $b++;\n}\necho $a . \" \" . $b; //1 6\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>1、注意<code>=</code>号赋值 非<code>==</code>判断 </li>\n  <li>2、 注意 if 语句这里 $a=5 ，这里的$a是bool类型</li>\n  <li>count</li>\n  </ul>\n</blockquote>\n\n<pre><code>$a = count (\"567\")  + count(null) + count(false);\necho $a; \n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>count 不同类型返回值，null为0，false为1</li>\n  </ul>\n</blockquote>\n\n<pre><code>var_dump(count(\"567\")); //1\nvar_dump(count(null));  //0\nvar_dump(count(false)); //1\n</code></pre>','php 前++和后++区别','','publish','closed','open','','php-%e5%89%8d%e5%92%8c%e5%90%8e%e5%8c%ba%e5%88%ab','','','2017-03-26 13:51:43','2017-03-26 05:51:43','## php 前++和后++区别  趣味题\n- 前++  先自增在返回\n```\n$y = 0;\n$y = ++$y;\nvar_dump($y); //1\n\n$y = 0;\n$i=$y+1;$y=$i;\nvar_dump($y); //1\n```\n- 后++ 先返回再自增\n```\n$y = 0;\n$y = $y++;\nvar_dump($y); //0\n\n$i = 0;\n$y=$i;$i=$i+1;\nvar_dump($y); //0\n```\n\n- 趣味题\n```\n$count = 5;\nfunction get_count() {\n    static $count = 0;\n    $res = $count++;\n    return $res;\n}\n++$count;\nget_count();\necho get_count();   // 1 //原因 先返回后自增\n```\n- 自动类型转换判断\n```\n$arr = array(0=&gt;1,&quot;aa&quot;=&gt;2, 3, 4);\n\nforeach($arr as $key=&gt;$val){\n    print($key == &quot;aa&quot; ? 5 : $val);\n}\n//5534\nvar_dump(0 == &#039;aa&#039;);    //bool(true)\nvar_dump(&#039;0&#039; == &#039;aa&#039;);   //bool(false)\n```\n>  在PHP中两个值进行逻辑判断时，如果两个值的类型不一致PHP会自动把右边的值转换到左边的类型，然后再进行判断。因此\"aa\"转换整形等于0，自然也就等于左边的0了，相反如果将0换成字符串，就不会隐式转换类型了，比较自然不相同了。\n- printf\n```\n$i=&#039;11&#039;;\nprintf(&quot;%d\\n&quot;,printf(&quot;%d&quot;,printf(&quot;%d&quot;,$i))); //1121\n```\n> printf不仅是打印函数,而且返回字符串长度\n```\n$res = printf(&#039;%d&#039;,11);\nvar_dump($res); //2\n$res = printf(&#039;%d&#039;,1);\nvar_dump($res); //1\n```\n- if语句\n```\n$a = 3;\n$b = 5;\nif($a = 5 || $b = 7) {\n    $a++;\n    $b++;\n}\necho $a . &quot; &quot; . $b; //1 6\n```\n> - 1、注意`=`号赋值 非`==`判断 \n> - 2、 注意 if 语句这里 $a=5 ，这里的$a是bool类型\n- count\n```\n$a = count (&quot;567&quot;)  + count(null) + count(false);\necho $a; \n```\n> - count 不同类型返回值，null为0，false为1\n```\nvar_dump(count(&quot;567&quot;)); //1\nvar_dump(count(null));  //0\nvar_dump(count(false)); //1\n```',0,'http://localhost/qipajun/?p=41',0,'post','',0),
	(43,1,'2017-03-26 13:51:44','2017-03-26 05:51:44','<h3>单例模式</h3>\n\n<ul>\n<li>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。</li>\n<li><strong>不适用单例模式时:</strong></li>\n</ul>\n\n<pre><code>class Database\n{\n    public $db = null;\n    public function __construct($config = array())\n    {\n        $dsn = sprintf(\'mysql:host=%s;dbname=%s\', $config[\'db_host\'], $config[\'db_name\']);\n        $this-&gt;db = new PDO($dsn, $config[\'db_user\'], $config[\'db_pass\']);\n    }\n}\n</code></pre>\n\n然后创建3个对象：\n\n<pre><code>$config = array(\n    \'db_name\' =&gt; \'test\',\n    \'db_host\' =&gt; \'localhost\',\n    \'db_user\' =&gt; \'root\',\n    \'db_pass\' =&gt; \'root\'\n);\n\n$db1 = new Database($config);\nvar_dump($db1);\n$db2 = new Database($config);\nvar_dump($db2);\n$db3 = new Database($config);\nvar_dump($db3);\n</code></pre>\n\n<ul>\n<li>输出信息:</li>\n</ul>\n\n<pre><code>object(Database)[1]\n  public \'db\' =&gt; object(PDO)[2]\nobject(Database)[3]\n  public \'db\' =&gt; object(PDO)[4]\nobject(Database)[5]\n  public \'db\' =&gt; object(PDO)[6]\n</code></pre>\n\n<ul>\n<li>每次new操作都会实例化一次类，就会增加一个数据库的连接，占用内存也在不断增大。</li>\n<li><strong>使用单例模式</strong></li>\n<li>基类上限制，只能实例化一次，如果实例化过，直接返回。</li>\n</ul>\n\n<pre><code>class Database\n{\n    // 声明$instance为私有静态类型，用于保存当前类实例化后的对象\n    private static $instance = null;\n    // 数据库连接句柄\n    private $db = null;\n\n    // 构造方法声明为私有方法，禁止外部程序使用new实例化，只能在内部new\n    private function __construct($config = array())\n    {\n        $dsn = sprintf(\'mysql:host=%s;dbname=%s\', $config[\'db_host\'], $config[\'db_name\']);\n        $this-&gt;db = new PDO($dsn, $config[\'db_user\'], $config[\'db_pass\']);\n    }\n\n    // 这是获取当前类对象的唯一方式\n    public static function getInstance($config = array())\n    {\n        // 检查对象是否已经存在，不存在则实例化后保存到$instance属性\n        if(self::$instance == null) {\n            self::$instance = new self($config);\n        }\n        return self::$instance;\n    }\n\n    // 获取数据库句柄方法\n    public function db()\n    {\n        return $this-&gt;db;\n    }\n\n    // 声明成私有方法，禁止克隆对象\n    private function __clone(){}\n    // 声明成私有方法，禁止重建对象\n    private function __wakeup(){}\n}\n</code></pre>\n\n<ul>\n<li>实例化使用单利模式</li>\n</ul>\n\n<pre><code>$config = array(\n    \'db_name\' =&gt; \'test\',\n    \'db_host\' =&gt; \'localhost\',\n    \'db_user\' =&gt; \'root\',\n    \'db_pass\' =&gt; \'root\'\n);\n\n$db1 = Database::getInstance($config);\nvar_dump($db1);\n$db2 = Database::getInstance($config);\nvar_dump($db2);\n$db3 = Database::getInstance($config);\nvar_dump($db3);\n</code></pre>\n\n<ul>\n<li>输出信息: 获取到的资源ID都是一样的</li>\n</ul>\n\n<pre><code>object(Database)[1]\n  private \'db\' =&gt; object(PDO)[2]\nobject(Database)[1]\n  private \'db\' =&gt; object(PDO)[2]\nobject(Database)[1]\n  private \'db\' =&gt; object(PDO)[2]\n</code></pre>\n\n<ul>\n<li>总结:\n\n<blockquote>\n  单例模式:单利模式在应用中最为常见。单利模式在运行时实例是唯一的，他们不允许被生成自身的副本。\n   所以 <code>__clone</code>、<code>__wakeup</code>等复制克隆对象的魔术方法建议声明为私有方法。\n   <code>单例模式</code>特点<strong>4私1公</strong>:\n</blockquote></li>\n<li>私有静态属性:</p></li>\n</ul>\n\n<ol>\n<li><code>private static $instance = null;</code> //用以保存类的实例化</li>\n<li><code>private function __construct(){}</code> // // 构造方法声明为私有方法，禁止外部程序使用new实例化，只能在内部new</li>\n<li><code>private function __clone(){}</code>// // 声明成私有方法，禁止克隆对象</li>\n<li><code>private function __wakeup(){}</code> // // 声明成私有方法，禁止重建对象</li>\n</ol>\n\n<ul>\n<li>公有属性:</li>\n</ul>\n\n<pre><code>//方法提供给外部本类的实例化对象\npublic static function getInstance()    \n    {\n        if(self::$instance == null) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n\n</code></pre>\n\n<p>构造方法私有，克隆方法私有，重建方法私有，一个公共静态方法。','单例模式','','publish','closed','open','','%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:44','2017-03-26 05:51:44','### 单例模式\n- 单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。\n- **不适用单例模式时:**\n```\nclass Database\n{\n    public $db = null;\n    public function __construct($config = array())\n    {\n        $dsn = sprintf(&#039;mysql:host=%s;dbname=%s&#039;, $config[&#039;db_host&#039;], $config[&#039;db_name&#039;]);\n        $this-&gt;db = new PDO($dsn, $config[&#039;db_user&#039;], $config[&#039;db_pass&#039;]);\n    }\n}\n```\n然后创建3个对象：\n```\n$config = array(\n    &#039;db_name&#039; =&gt; &#039;test&#039;,\n    &#039;db_host&#039; =&gt; &#039;localhost&#039;,\n    &#039;db_user&#039; =&gt; &#039;root&#039;,\n    &#039;db_pass&#039; =&gt; &#039;root&#039;\n);\n\n$db1 = new Database($config);\nvar_dump($db1);\n$db2 = new Database($config);\nvar_dump($db2);\n$db3 = new Database($config);\nvar_dump($db3);\n```\n- 输出信息:\n```\nobject(Database)[1]\n  public &#039;db&#039; =&gt; object(PDO)[2]\nobject(Database)[3]\n  public &#039;db&#039; =&gt; object(PDO)[4]\nobject(Database)[5]\n  public &#039;db&#039; =&gt; object(PDO)[6]\n```\n\n- 每次new操作都会实例化一次类，就会增加一个数据库的连接，占用内存也在不断增大。\n- **使用单例模式**\n- 基类上限制，只能实例化一次，如果实例化过，直接返回。\n```\nclass Database\n{\n    // 声明$instance为私有静态类型，用于保存当前类实例化后的对象\n    private static $instance = null;\n    // 数据库连接句柄\n    private $db = null;\n\n    // 构造方法声明为私有方法，禁止外部程序使用new实例化，只能在内部new\n    private function __construct($config = array())\n    {\n        $dsn = sprintf(&#039;mysql:host=%s;dbname=%s&#039;, $config[&#039;db_host&#039;], $config[&#039;db_name&#039;]);\n        $this-&gt;db = new PDO($dsn, $config[&#039;db_user&#039;], $config[&#039;db_pass&#039;]);\n    }\n\n    // 这是获取当前类对象的唯一方式\n    public static function getInstance($config = array())\n    {\n        // 检查对象是否已经存在，不存在则实例化后保存到$instance属性\n        if(self::$instance == null) {\n            self::$instance = new self($config);\n        }\n        return self::$instance;\n    }\n\n    // 获取数据库句柄方法\n    public function db()\n    {\n        return $this-&gt;db;\n    }\n\n    // 声明成私有方法，禁止克隆对象\n    private function __clone(){}\n    // 声明成私有方法，禁止重建对象\n    private function __wakeup(){}\n}\n```\n- 实例化使用单利模式\n```\n$config = array(\n    &#039;db_name&#039; =&gt; &#039;test&#039;,\n    &#039;db_host&#039; =&gt; &#039;localhost&#039;,\n    &#039;db_user&#039; =&gt; &#039;root&#039;,\n    &#039;db_pass&#039; =&gt; &#039;root&#039;\n);\n\n$db1 = Database::getInstance($config);\nvar_dump($db1);\n$db2 = Database::getInstance($config);\nvar_dump($db2);\n$db3 = Database::getInstance($config);\nvar_dump($db3);\n```\n\n- 输出信息: 获取到的资源ID都是一样的\n```\nobject(Database)[1]\n  private &#039;db&#039; =&gt; object(PDO)[2]\nobject(Database)[1]\n  private &#039;db&#039; =&gt; object(PDO)[2]\nobject(Database)[1]\n  private &#039;db&#039; =&gt; object(PDO)[2]\n```\n- 总结:\n> 单例模式:单利模式在应用中最为常见。单利模式在运行时实例是唯一的，他们不允许被生成自身的副本。\n>  所以 `__clone`、`__wakeup`等复制克隆对象的魔术方法建议声明为私有方法。\n>  `单例模式`特点**4私1公**: \n\n- 私有静态属性:\n\n\n1.  `private static $instance = null;` //用以保存类的实例化\n2. ` private function __construct(){} ` // // 构造方法声明为私有方法，禁止外部程序使用new实例化，只能在内部new\n3.  ` private function __clone(){}`// // 声明成私有方法，禁止克隆对象\n4. ` private function __wakeup(){}` // // 声明成私有方法，禁止重建对象\n\n\n- 公有属性:\n\n```\n//方法提供给外部本类的实例化对象\npublic static function getInstance()    \n    {\n        if(self::$instance == null) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n\n```\n构造方法私有，克隆方法私有，重建方法私有，一个公共静态方法。',0,'http://localhost/qipajun/?p=43',0,'post','',0),
	(45,1,'2017-03-26 13:51:44','2017-03-26 05:51:44','<h2>策略模式</h2>\n\n<ul>\n<li>定义一组相同类型的算法，算法之间独立封装，并且可以互相代替。</li>\n<li>这些算法是统一类型问题的多种处理方式，但是具体行为存在差别。</li>\n<li>每一个算法、或者说每一种处理方式称为一个策略。</li>\n<li>在应用中，就可以根据环境的不同，选择不同的策略来处理问题。\n> - 实例代码</li>\n</ul>\n\n<pre><code>&lt;?php\n//策略模式\n//cd类\nclass Cd {\n    protected $cdArr;\n\n    public function __construct($title, $info) {\n        $this-&gt;cdArr[\'title\'] = $title;\n        $this-&gt;cdArr[\'info\']  = $info;\n    }\n\n    public function getCd($typeObj) {\n        return $typeObj-&gt;get($this-&gt;cdArr);\n    }\n}\n\nclass json {\n    public function get($return_data) {\n        return json_encode($return_data);\n    }\n}\n\nclass xml {\n    public function get($return_data) {\n        $xml = \'&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\';\n        $xml .= \'&lt;return&gt;\';\n        $xml .= \'&lt;data&gt;\' .serialize($return_data). \'&lt;/data&gt;\';\n        $xml .= \'&lt;/return&gt;\';\n        return $xml;\n    }\n}\n\n$cd = new Cd(\'title = cd_1\', \'info = cd_1\');\necho $cd-&gt;getCd(new json);\necho $cd-&gt;getCd(new xml);\n\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>输出:</li>\n  </ul>\n</blockquote>\n\n<pre><code>{\"title\":\"title = cd_1\",\"info\":\"info = cd_1\"}\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;return&gt;\n    &lt;data&gt;\n    a:2:{s:5:\"title\";s:12:\"title = cd_1\";s:4:\"info\";s:11:\"info = cd_1\";}\n    &lt;/data&gt;\n&lt;/return&gt;\n</code></pre>\n\n<ul>\n<li>策略模式帮助构建的对象不必包含吱声逻辑，而是能够根据需要利用其它对象中的算法。</li>\n<li>策略设计模式详细说明了一个对象的构造，从而通过去除对象本省的复杂逻辑而使该对象简介。测试，这个对象不必再内部包含一组逻辑，而是可以在运行中调用其他类的算法。\n> - 不是用策略模式实现以上功能</li>\n</ul>\n\n<pre><code>//不使用策略模式实现\nclass Output\n{\n    public function render($array, $type = \'\')\n    {\n        if ($type === \'xml\') {\n            $xml = \'&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\';\n            $xml .= \'&lt;return&gt;\';\n            $xml .= \'&lt;data&gt;\' .serialize($array). \'&lt;/data&gt;\';\n            $xml .= \'&lt;/return&gt;\';\n            $xml .= \'&lt;/return&gt;\';\n            return $xml;\n        } elseif ($type === \'json\') {\n            return json_encode($array);\n        } else {\n            return $array;\n        }\n    }\n}\n\n$test = array(\'a\',\'b\',\'c\');\n$output = new Output();\n\n$data = $output-&gt;render($test, \'array\');\n\n$data = $output-&gt;render($test, \'xml\');\necho $data;\n$data = $output-&gt;render($test, \'json\');\necho \"\\n\";\necho $data;\n</code></pre>\n\n<ul>\n<li>虽然一样可以实现，但是如果是一个负责方案，包括大量的处理逻辑需要封装，或者处理方式变动较大，则咎显得混乱。</li>\n<li>所以使用策略模式将方案分离开来(一个类一个文件，新需求添加类即可)，让操作者根据具体的需求，动态的选择不同的策略方案。</li>\n</ul>','策略模式','','publish','closed','open','','%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:44','2017-03-26 05:51:44','## 策略模式\n- 定义一组相同类型的算法，算法之间独立封装，并且可以互相代替。\n- 这些算法是统一类型问题的多种处理方式，但是具体行为存在差别。\n- 每一个算法、或者说每一种处理方式称为一个策略。\n- 在应用中，就可以根据环境的不同，选择不同的策略来处理问题。\n> - 实例代码\n```\n&lt;?php\n//策略模式\n//cd类\nclass Cd {\n    protected $cdArr;\n\n    public function __construct($title, $info) {\n        $this-&gt;cdArr[&#039;title&#039;] = $title;\n        $this-&gt;cdArr[&#039;info&#039;]  = $info;\n    }\n\n    public function getCd($typeObj) {\n        return $typeObj-&gt;get($this-&gt;cdArr);\n    }\n}\n\nclass json {\n    public function get($return_data) {\n        return json_encode($return_data);\n    }\n}\n\nclass xml {\n    public function get($return_data) {\n        $xml = &#039;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#039;;\n        $xml .= &#039;&lt;return&gt;&#039;;\n        $xml .= &#039;&lt;data&gt;&#039; .serialize($return_data). &#039;&lt;/data&gt;&#039;;\n        $xml .= &#039;&lt;/return&gt;&#039;;\n        return $xml;\n    }\n}\n\n$cd = new Cd(&#039;title = cd_1&#039;, &#039;info = cd_1&#039;);\necho $cd-&gt;getCd(new json);\necho $cd-&gt;getCd(new xml);\n\n```\n\n> -  输出:\n```\n{&quot;title&quot;:&quot;title = cd_1&quot;,&quot;info&quot;:&quot;info = cd_1&quot;}\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;return&gt;\n    &lt;data&gt;\n    a:2:{s:5:&quot;title&quot;;s:12:&quot;title = cd_1&quot;;s:4:&quot;info&quot;;s:11:&quot;info = cd_1&quot;;}\n    &lt;/data&gt;\n&lt;/return&gt;\n```\n- 策略模式帮助构建的对象不必包含吱声逻辑，而是能够根据需要利用其它对象中的算法。\n- 策略设计模式详细说明了一个对象的构造，从而通过去除对象本省的复杂逻辑而使该对象简介。测试，这个对象不必再内部包含一组逻辑，而是可以在运行中调用其他类的算法。\n> - 不是用策略模式实现以上功能\n```\n//不使用策略模式实现\nclass Output\n{\n    public function render($array, $type = &#039;&#039;)\n    {\n        if ($type === &#039;xml&#039;) {\n            $xml = &#039;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#039;;\n            $xml .= &#039;&lt;return&gt;&#039;;\n            $xml .= &#039;&lt;data&gt;&#039; .serialize($array). &#039;&lt;/data&gt;&#039;;\n            $xml .= &#039;&lt;/return&gt;&#039;;\n            $xml .= &#039;&lt;/return&gt;&#039;;\n            return $xml;\n        } elseif ($type === &#039;json&#039;) {\n            return json_encode($array);\n        } else {\n            return $array;\n        }\n    }\n}\n\n$test = array(&#039;a&#039;,&#039;b&#039;,&#039;c&#039;);\n$output = new Output();\n\n$data = $output-&gt;render($test, &#039;array&#039;);\n\n$data = $output-&gt;render($test, &#039;xml&#039;);\necho $data;\n$data = $output-&gt;render($test, &#039;json&#039;);\necho &quot;\\n&quot;;\necho $data;\n```\n- 虽然一样可以实现，但是如果是一个负责方案，包括大量的处理逻辑需要封装，或者处理方式变动较大，则咎显得混乱。\n- 所以使用策略模式将方案分离开来(一个类一个文件，新需求添加类即可)，让操作者根据具体的需求，动态的选择不同的策略方案。',0,'http://localhost/qipajun/?p=45',0,'post','',0),
	(47,1,'2017-03-26 13:51:44','2017-03-26 05:51:44','<h1>1.面向对象思想：</h1>\n\nOOA(Object Oriented Analysis):面向对象分析\nOOD(Object Oriented Design):面向对象设计\nOOP(Object Oriented Programming):面向对象编程\n\n<h1>2.面向过程和面向对象的对比</h1>\n\n<h1>3.类和对象</h1>\n\n<h2>1》对象：一切事物皆对象，对象是系统中用来描述客观事物的一个实体，是构成系统的最基本的组成单位</h2>\n\n<pre><code>我--对象\n    特征：姓名、年龄、性别...(属性)\n    行为：吃饭、睡觉、打豆豆...(方法)\n电脑--对象\n    特征：名称、品牌、颜色、内存、硬盘...\n    行为：打游戏、看视频、敲代码...\n电话--对象\n每一类对象都拥有相同的属性和行为\n</code></pre>\n\n<h2>2》类：是一组相同属性和行为的对象的集合</h2>\n\n类是把具有相似特性的对象归纳到一个类中，类就是一组相同属性和行为的对象的集合\n\n<h2>3》类和对象的关系</h2>\n\n<pre><code>a.类是相似对象的描述\nb.先有类，再有对象\nc.类是对象的抽象\nd.对象是类的实例\n</code></pre>\n\n<h2>4.类的声明</h2>\n\n<h3>1》创建类</h3>\n\n通过class关键字 类名\n\n<pre><code>class Person{\n        //成员属性和方法\n    }\n</code></pre>\n\n<h3>2》成员属性</h3>\n\n<pre><code>在类中声明的变量\n一个类可以包含多个成员属性\n注意：成员属性可以有默认值，也可以没有默认值，如果有默认值的话，值不能是变量、表达式、函数和方法的调用，只能是一个值\n</code></pre>\n\n<h3>3》成员方法</h3>\n\n<pre><code>在类中声明的方法就是成员方法\n一个类可以包含多个成员方法\n</code></pre>\n\n<h1>4.实例化对象</h1>\n\n<pre><code><br />class Person{\n    //成员属性\n    public $username;\n    public $age;\n    public $email;\n    public $sex;\n    //成员方法\n    public function eat(){\n        echo \'eat...&lt;br/&gt;\';\n    }\n    public function sleep(){\n        echo \'sleep...&lt;br/&gt;\';\n    }\n    public function play(){\n        echo \'play...&lt;br/&gt;\';\n    }\n}\n</code></pre>\n\n//通过new关键字+类名实例化类，实例化类的结果产生对象\n\n<pre><code>$p1=new Person;\n$p2=new Person();\nvar_dump($p1,$p2);\n</code></pre>','1.面向对象简介','','publish','closed','open','','1-%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%ae%80%e4%bb%8b','','','2017-03-26 13:51:44','2017-03-26 05:51:44','# 1.面向对象思想：\nOOA(Object Oriented Analysis):面向对象分析\nOOD(Object Oriented Design):面向对象设计\nOOP(Object Oriented Programming):面向对象编程\n# 2.面向过程和面向对象的对比\n# 3.类和对象\n## 1》对象：一切事物皆对象，对象是系统中用来描述客观事物的一个实体，是构成系统的最基本的组成单位\n	我--对象\n		特征：姓名、年龄、性别...(属性)\n		行为：吃饭、睡觉、打豆豆...(方法)\n	电脑--对象\n		特征：名称、品牌、颜色、内存、硬盘...\n		行为：打游戏、看视频、敲代码...\n	电话--对象\n	每一类对象都拥有相同的属性和行为\n## 2》类：是一组相同属性和行为的对象的集合\n类是把具有相似特性的对象归纳到一个类中，类就是一组相同属性和行为的对象的集合\n## 3》类和对象的关系\n	a.类是相似对象的描述\n	b.先有类，再有对象\n	c.类是对象的抽象\n	d.对象是类的实例\n## 4.类的声明\n### 1》创建类\n通过class关键字 类名\n```\nclass Person{\n		//成员属性和方法\n	}\n```\n### 2》成员属性\n	在类中声明的变量\n	一个类可以包含多个成员属性\n	注意：成员属性可以有默认值，也可以没有默认值，如果有默认值的话，值不能是变量、表达式、函数和方法的调用，只能是一个值\n### 3》成员方法\n	在类中声明的方法就是成员方法\n	一个类可以包含多个成员方法\n# 4.实例化对象\n```\n\nclass Person{\n	//成员属性\n	public $username;\n	public $age;\n	public $email;\n	public $sex;\n	//成员方法\n	public function eat(){\n		echo &#039;eat...&lt;br/&gt;&#039;;\n	}\n	public function sleep(){\n		echo &#039;sleep...&lt;br/&gt;&#039;;\n	}\n	public function play(){\n		echo &#039;play...&lt;br/&gt;&#039;;\n	}\n}\n```\n//通过new关键字+类名实例化类，实例化类的结果产生对象\n```\n$p1=new Person;\n$p2=new Person();\nvar_dump($p1,$p2);\n```',0,'http://localhost/qipajun/?p=47',0,'post','',0),
	(49,1,'2017-03-26 13:51:45','2017-03-26 05:51:45','<h2>对象方法应用、属性赋值</h2>\n\n<pre><code>&lt;?php\nheader(\'content-type:text/html;charset=utf-8\');\nclass Person{\n    public $username=\'king\';\n    public $age=12;\n    public $email=\'382771946@qq.com\';\n    public $sex=\'男\';\n    //成员方法\n    public function eat(){\n        echo \'eat...&lt;br/&gt;\';\n    }\n    public function sleep(){\n        echo \'sleep...&lt;br/&gt;\';\n    }\n    public function play(){\n        echo \'play...&lt;br/&gt;\';\n    }\n}\n/*\n通过对象引用名-&gt;属性\n对象引用名-&gt;方法\n*/\n//实例化\n$p1=new Person;\n// var_dump($p1);\necho \'用户名：\'.$p1-&gt;username.\'&lt;br/&gt;\';\necho \'年龄：\'.$p1-&gt;age.\'&lt;br/&gt;\';\necho \'邮箱：\'.$p1-&gt;email.\'&lt;br/&gt;\';\necho \'性别：\'.$p1-&gt;sex.\'&lt;br/&gt;\';\necho \'&lt;hr/&gt;\';\n$p1-&gt;eat();\n$p1-&gt;sleep();\n$p1-&gt;play();\necho \'&lt;hr/&gt;\';\n$p1-&gt;age=13;\necho $p1-&gt;age.\'&lt;br/&gt;\';\n/*\n声明电话类 Phone\n成员属性：名称、品牌、颜色、内存...\n成员方法：打电话、发短信、打游戏、撩妹...\n实例化对象\n*/\n</code></pre>\n\n<code>栈</code>空间段：栈的特点是空间小，CPU访问的速度快，适合村村程序中临时创建的变量。栈后进先出\n<code>堆</code>空间段：堆是用于存放运行中被动态分配的内存段，它大小不固定，可以动态扩展或收缩，使用存放数据长度可变或内存比较大的数据，像字符串、数组、对象都是存放在堆空间段\n<code>代码段</code>：代码段是用来存放可执行文件的操作命令，可以想象成可执行程序的在内存中的镜像。像函数就是存放在代码段中\n<code>初始化静态段(数据段)</code>：存储程序静态分配的变量','2.对象方法应用、属性赋值','','publish','closed','open','','2-%e5%af%b9%e8%b1%a1%e6%96%b9%e6%b3%95%e5%ba%94%e7%94%a8%e3%80%81%e5%b1%9e%e6%80%a7%e8%b5%8b%e5%80%bc','','','2017-03-26 13:51:45','2017-03-26 05:51:45','## 对象方法应用、属性赋值\n```\n&lt;?php\nheader(&#039;content-type:text/html;charset=utf-8&#039;);\nclass Person{\n	public $username=&#039;king&#039;;\n	public $age=12;\n	public $email=&#039;382771946@qq.com&#039;;\n	public $sex=&#039;男&#039;;\n	//成员方法\n	public function eat(){\n		echo &#039;eat...&lt;br/&gt;&#039;;\n	}\n	public function sleep(){\n		echo &#039;sleep...&lt;br/&gt;&#039;;\n	}\n	public function play(){\n		echo &#039;play...&lt;br/&gt;&#039;;\n	}\n}\n/*\n通过对象引用名-&gt;属性\n对象引用名-&gt;方法\n*/\n//实例化\n$p1=new Person;\n// var_dump($p1);\necho &#039;用户名：&#039;.$p1-&gt;username.&#039;&lt;br/&gt;&#039;;\necho &#039;年龄：&#039;.$p1-&gt;age.&#039;&lt;br/&gt;&#039;;\necho &#039;邮箱：&#039;.$p1-&gt;email.&#039;&lt;br/&gt;&#039;;\necho &#039;性别：&#039;.$p1-&gt;sex.&#039;&lt;br/&gt;&#039;;\necho &#039;&lt;hr/&gt;&#039;;\n$p1-&gt;eat();\n$p1-&gt;sleep();\n$p1-&gt;play();\necho &#039;&lt;hr/&gt;&#039;;\n$p1-&gt;age=13;\necho $p1-&gt;age.&#039;&lt;br/&gt;&#039;;\n/*\n声明电话类 Phone\n成员属性：名称、品牌、颜色、内存...\n成员方法：打电话、发短信、打游戏、撩妹...\n实例化对象\n*/\n```\n\n\n`栈`空间段：栈的特点是空间小，CPU访问的速度快，适合村村程序中临时创建的变量。栈后进先出\n`堆`空间段：堆是用于存放运行中被动态分配的内存段，它大小不固定，可以动态扩展或收缩，使用存放数据长度可变或内存比较大的数据，像字符串、数组、对象都是存放在堆空间段\n`代码段`：代码段是用来存放可执行文件的操作命令，可以想象成可执行程序的在内存中的镜像。像函数就是存放在代码段中\n`初始化静态段(数据段)`：存储程序静态分配的变量',0,'http://localhost/qipajun/?p=49',0,'post','',0),
	(51,1,'2017-03-26 13:51:45','2017-03-26 05:51:45','<h2>构造函数<code>__construct()</code>析构函数<code>__destruct()</code></h2>\n\n<pre><code>&lt;?php\nclass Person{\n    public $username=\'king\';\n    public $age=12;\n    public $email=\'382771946@qq.com\';\n    public $sex=\'男\';\n    //构造函数，当创建对象的时候首先会调用构造函数，适合初始化数据操作\n    public function __construct($username,$age,$email,$sex){\n        echo \'当新建对象的时候我首先会被调用&lt;br/&gt;\';\n        $this-&gt;username=$username;\n        $this-&gt;age=$age;\n        $this-&gt;sex=$sex;\n        $this-&gt;email=$email;\n    }\n    //析构函数,不能带有参数，析构函数会在对象的所有引用被删除或显示的销毁之前会被调用\n    //可以通过析构函数释放资源、释放结果集\n    public function __destruct(){\n        echo \'say Goodbye to \'.$this-&gt;username.\'&lt;br/&gt;\';\n    }\n    //成员方法\n    public function eat(){\n        echo \'eat...&lt;br/&gt;\';\n    }\n    public function sleep(){\n        echo \'sleep...&lt;br/&gt;\';\n    }\n    public function play(){\n        echo \'play...&lt;br/&gt;\';\n    }\n    public function personInfo(){\n        echo \'用户名为：\'.$this-&gt;username.\'&lt;br/&gt;\';\n        echo \'年龄：\'.$this-&gt;age.\'&lt;br/&gt;\';\n        echo \'性别：\'.$this-&gt;sex.\'&lt;br/&gt;\';\n        echo \'邮箱：\'.$this-&gt;email.\'&lt;br/&gt;\';\n    }\n}\n// $p1=new Person;\n// var_dump($p1);\n// echo \'&lt;hr/&gt;\';\n// $p2=new Person;\n// $p2-&gt;username=\'queen\';\n// $p2-&gt;age=32;\n// $p2-&gt;email=\'maizi@qq.com\';\n// $p2-&gt;sex=\'女\';\n// var_dump($p2);\n$p1=new Person(\'king\',12,\'382771946@qq.com\',\'男\');\n// var_dump($p1);\n$p1-&gt;personInfo();\n// $p1=null;\nunset($p1);\necho \'销毁对象&lt;br/&gt;\';\n$p2=new Person(\'queen\',32,\'queen@qq.com\',\'女\');\n$p2-&gt;personInfo();\n</code></pre>','3.构造函数、析构函数','','publish','closed','open','','3-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e3%80%81%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0','','','2017-03-26 13:51:45','2017-03-26 05:51:45','## 构造函数`__construct() `析构函数`__destruct()`\n```\n&lt;?php\nclass Person{\n	public $username=&#039;king&#039;;\n	public $age=12;\n	public $email=&#039;382771946@qq.com&#039;;\n	public $sex=&#039;男&#039;;\n	//构造函数，当创建对象的时候首先会调用构造函数，适合初始化数据操作\n	public function __construct($username,$age,$email,$sex){\n		echo &#039;当新建对象的时候我首先会被调用&lt;br/&gt;&#039;;\n		$this-&gt;username=$username;\n		$this-&gt;age=$age;\n		$this-&gt;sex=$sex;\n		$this-&gt;email=$email;\n	}\n	//析构函数,不能带有参数，析构函数会在对象的所有引用被删除或显示的销毁之前会被调用\n	//可以通过析构函数释放资源、释放结果集\n	public function __destruct(){\n		echo &#039;say Goodbye to &#039;.$this-&gt;username.&#039;&lt;br/&gt;&#039;;\n	}\n	//成员方法\n	public function eat(){\n		echo &#039;eat...&lt;br/&gt;&#039;;\n	}\n	public function sleep(){\n		echo &#039;sleep...&lt;br/&gt;&#039;;\n	}\n	public function play(){\n		echo &#039;play...&lt;br/&gt;&#039;;\n	}\n	public function personInfo(){\n		echo &#039;用户名为：&#039;.$this-&gt;username.&#039;&lt;br/&gt;&#039;;\n		echo &#039;年龄：&#039;.$this-&gt;age.&#039;&lt;br/&gt;&#039;;\n		echo &#039;性别：&#039;.$this-&gt;sex.&#039;&lt;br/&gt;&#039;;\n		echo &#039;邮箱：&#039;.$this-&gt;email.&#039;&lt;br/&gt;&#039;;\n	}\n}\n// $p1=new Person;\n// var_dump($p1);\n// echo &#039;&lt;hr/&gt;&#039;;\n// $p2=new Person;\n// $p2-&gt;username=&#039;queen&#039;;\n// $p2-&gt;age=32;\n// $p2-&gt;email=&#039;maizi@qq.com&#039;;\n// $p2-&gt;sex=&#039;女&#039;;\n// var_dump($p2);\n$p1=new Person(&#039;king&#039;,12,&#039;382771946@qq.com&#039;,&#039;男&#039;);\n// var_dump($p1);\n$p1-&gt;personInfo();\n// $p1=null;\nunset($p1);\necho &#039;销毁对象&lt;br/&gt;&#039;;\n$p2=new Person(&#039;queen&#039;,32,&#039;queen@qq.com&#039;,&#039;女&#039;);\n$p2-&gt;personInfo();\n```',0,'http://localhost/qipajun/?p=51',0,'post','',0),
	(53,1,'2017-03-26 13:51:45','2017-03-26 05:51:45','<h2>访问修饰</h2>\n\n<pre><code>public:公有的 全局都能访问\nprotected：受保护的 只能自或父类、子类访问\nprivate:私有的 只能自己内部访问 外部不能访问\n</code></pre>\n\n<h2>魔术方法：</h2>\n\n<pre><code>(必须设置成pulbic ,而且参数不能通过引用来传递)\n__construct()/__destruct():\n__set()/__get()/__isset()/__unset():\n__set():在类外部对私有的或者受保护的或者未定义的成员进行赋值的时候会自动调用\n__get():在类外部对私有的或者受保护的或者未定义的成员进行读取的时候回自动调用\n</code></pre>\n\n<pre><code>&lt;?php\nheader(\'content-type:text/html;charset=utf-8\');\n/*\n封装性：\n1.访问修饰符\nvar\npublic:公有的 全局都能访问\nprotected：受保护的 只能自或父类、子类访问\nprivate:私有的 只能自己内部访问 外部不能访问\n*/\nclass Person{\n    public $username=\'king\';\n    protected $age=12;\n    private $salary=12345678.9;\n    public function say(){\n        echo \'hello world...&lt;br/&gt;\';\n    }\n    protected function makeMoney(){\n        echo \'赚大钱...&lt;br/&gt;\';\n    }\n    private function papapa(){\n        echo \'papapa...&lt;br/&gt;\';\n    }\n    public function test(){\n        echo \'this is a test&lt;br/&gt;\';\n        echo $this-&gt;age.\'&lt;br/&gt;\';\n        echo $this-&gt;salary.\'&lt;br/&gt;\';\n    }\n}\n$p1=new Person;\necho \'用户名：\'.$p1-&gt;username.\'&lt;br/&gt;\';\n$p1-&gt;test();\n// echo \'年龄为：\'.$p1-&gt;age.\'&lt;br/&gt;\';\n// echo \'薪水：\'.$p1-&gt;salary.\'&lt;br/&gt;\';\n\n</code></pre>\n\n###final关键词\n -    final 关键字代表的是最终，不能被重写或者重载\n\n<ul>\n<li>PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</li>\n</ul>\n\n<pre><code>&lt;?php\nheader(\'content-type:text/html;charset=utf-8\');\nclass Person{\n    public $username;\n    public $age;\n    public function __construct($username,$age){\n        $this-&gt;username=$username;\n        $this-&gt;age=$age;\n        echo \'Person类的构造函数&lt;br/&gt;\';\n    }\n    public function getInfo(){\n        return \'用户名：\'.$this-&gt;username.\'--年龄：\'.$this-&gt;age;\n    }\n    //final 关键字代表的是最终，不能被重写或者重载\n    // PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。\n    final public function test(){\n        echo \'我才是最帅的人...&lt;br/&gt;\';\n    }\n}\nclass Student extends Person{\n    // public $username;\n    // public $age;\n    public $school;\n    public function __construct($username,$age,$school){\n        // $this-&gt;username=$username;\n        // $this-&gt;age=$age;\n        parent::__construct($username,$age);\n        $this-&gt;school=$school;\n        echo \'Student的构造函数...&lt;br/&gt;\';\n    }\n    public function study(){\n        return $this-&gt;username.\'在\'.$this-&gt;school.\'上学&lt;br/&gt;\';\n    }\n    public function getInfo(){\n        // return \'用户名：\'.$this-&gt;username.\'--年龄：\'.$this-&gt;age.\'--学校：\'.$this-&gt;school;\n        $info=parent::getInfo();\n        $info.=\'--学校：\'.$this-&gt;school;\n        return $info;\n    }\n}\nclass Teacher extends Person{\n    public $course;\n    public function __construct($username,$age,$course){\n        parent::__construct($username,$age);\n        $this-&gt;course=$course;\n    }\n    public function teach(){\n        return $this-&gt;username.\'教\'.$this-&gt;course.\'&lt;br/&gt;\';\n    }\n    public function getInfo(){\n        $info=parent::getInfo();\n        $info.=\'所教课程：\'.$this-&gt;course;\n        return $info;\n    }\n    public function test(){\n        echo \'i am the smart boy...&lt;br/&gt;\';\n    }\n}\n// $stu1=new Student(\'king\',12,\'北大\');\n// echo $stu1-&gt;study();\n// echo $stu1-&gt;getInfo();\n$teacher1=new Teacher(\'queen\',33,\'PHP\');\necho $teacher1-&gt;teach();\necho $teacher1-&gt;getInfo();\necho \'&lt;br/&gt;\';\n    //final 关键字代表的是最终，不能被重写或者重载\n    // PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。\n$teacher1-&gt;test();\n\n</code></pre>\n\n<h2>static、const 、self关键字 静态方法 、静态变量</h2>\n\n<ul>\n<li>类内部声明const 常量 </li>\n<li>在类内部:使用self::常量访问 </li>\n<li>类外部使用:类名::常量</li>\n</ul>\n\n<pre><code>&lt;?php\nheader(\'content-type:text/html;charset=utf-8\');\nclass Test{\n    const PI=3.14;\n    const COUNTY=\'中国\';\n    public function testConst(){\n        echo self::PI.\'&lt;br/&gt;\';\n        echo self::COUNTY.\'&lt;br/&gt;\';\n        echo static::PI.\'&lt;br/&gt;\';\n    }\n\n}\necho Test::PI;\necho \'&lt;br/&gt;\';\necho Test::COUNTY;\necho \'&lt;br/&gt;\';\n$t1=new Test;\n$t1-&gt;testConst();\necho \'&lt;br/&gt;\';\n// echo $t1-&gt;PI;\n</code></pre>\n\n<code>is_a($obj,\'OBJ\')</code>; //$obj是否属于OBJ类或者父类\n<code>($a instanceof A)</code>；//instanceof 用于确定一个 PHP 变量是否属于某一类 class 的实例：\n<code>get_class($a)</code>; //返回$a所属对象类名\n <code>get_parent_class()</code>:返回类或者对象的父类名','4.访问修饰','','publish','closed','open','','4-%e8%ae%bf%e9%97%ae%e4%bf%ae%e9%a5%b0','','','2017-03-26 13:51:45','2017-03-26 05:51:45','## 访问修饰\n    public:公有的 全局都能访问\n    protected：受保护的 只能自或父类、子类访问\n    private:私有的 只能自己内部访问 外部不能访问\n## 魔术方法：\n    (必须设置成pulbic ,而且参数不能通过引用来传递)\n    __construct()/__destruct():\n    __set()/__get()/__isset()/__unset():\n    __set():在类外部对私有的或者受保护的或者未定义的成员进行赋值的时候会自动调用\n    __get():在类外部对私有的或者受保护的或者未定义的成员进行读取的时候回自动调用\n\n```\n&lt;?php\nheader(&#039;content-type:text/html;charset=utf-8&#039;);\n/*\n封装性：\n1.访问修饰符\nvar\npublic:公有的 全局都能访问\nprotected：受保护的 只能自或父类、子类访问\nprivate:私有的 只能自己内部访问 外部不能访问\n*/\nclass Person{\n	public $username=&#039;king&#039;;\n	protected $age=12;\n	private $salary=12345678.9;\n	public function say(){\n		echo &#039;hello world...&lt;br/&gt;&#039;;\n	}\n	protected function makeMoney(){\n		echo &#039;赚大钱...&lt;br/&gt;&#039;;\n	}\n	private function papapa(){\n		echo &#039;papapa...&lt;br/&gt;&#039;;\n	}\n	public function test(){\n		echo &#039;this is a test&lt;br/&gt;&#039;;\n		echo $this-&gt;age.&#039;&lt;br/&gt;&#039;;\n		echo $this-&gt;salary.&#039;&lt;br/&gt;&#039;;\n	}\n}\n$p1=new Person;\necho &#039;用户名：&#039;.$p1-&gt;username.&#039;&lt;br/&gt;&#039;;\n$p1-&gt;test();\n// echo &#039;年龄为：&#039;.$p1-&gt;age.&#039;&lt;br/&gt;&#039;;\n// echo &#039;薪水：&#039;.$p1-&gt;salary.&#039;&lt;br/&gt;&#039;;\n\n```\n###final关键词\n -    final 关键字代表的是最终，不能被重写或者重载\n\n- 	 PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。\n\n```\n&lt;?php\nheader(&#039;content-type:text/html;charset=utf-8&#039;);\nclass Person{\n	public $username;\n	public $age;\n	public function __construct($username,$age){\n		$this-&gt;username=$username;\n		$this-&gt;age=$age;\n		echo &#039;Person类的构造函数&lt;br/&gt;&#039;;\n	}\n	public function getInfo(){\n		return &#039;用户名：&#039;.$this-&gt;username.&#039;--年龄：&#039;.$this-&gt;age;\n	}\n	//final 关键字代表的是最终，不能被重写或者重载\n	// PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。\n	final public function test(){\n		echo &#039;我才是最帅的人...&lt;br/&gt;&#039;;\n	}\n}\nclass Student extends Person{\n	// public $username;\n	// public $age;\n	public $school;\n	public function __construct($username,$age,$school){\n		// $this-&gt;username=$username;\n		// $this-&gt;age=$age;\n		parent::__construct($username,$age);\n		$this-&gt;school=$school;\n		echo &#039;Student的构造函数...&lt;br/&gt;&#039;;\n	}\n	public function study(){\n		return $this-&gt;username.&#039;在&#039;.$this-&gt;school.&#039;上学&lt;br/&gt;&#039;;\n	}\n	public function getInfo(){\n		// return &#039;用户名：&#039;.$this-&gt;username.&#039;--年龄：&#039;.$this-&gt;age.&#039;--学校：&#039;.$this-&gt;school;\n		$info=parent::getInfo();\n		$info.=&#039;--学校：&#039;.$this-&gt;school;\n		return $info;\n	}\n}\nclass Teacher extends Person{\n	public $course;\n	public function __construct($username,$age,$course){\n		parent::__construct($username,$age);\n		$this-&gt;course=$course;\n	}\n	public function teach(){\n		return $this-&gt;username.&#039;教&#039;.$this-&gt;course.&#039;&lt;br/&gt;&#039;;\n	}\n	public function getInfo(){\n		$info=parent::getInfo();\n		$info.=&#039;所教课程：&#039;.$this-&gt;course;\n		return $info;\n	}\n	public function test(){\n		echo &#039;i am the smart boy...&lt;br/&gt;&#039;;\n	}\n}\n// $stu1=new Student(&#039;king&#039;,12,&#039;北大&#039;);\n// echo $stu1-&gt;study();\n// echo $stu1-&gt;getInfo();\n$teacher1=new Teacher(&#039;queen&#039;,33,&#039;PHP&#039;);\necho $teacher1-&gt;teach();\necho $teacher1-&gt;getInfo();\necho &#039;&lt;br/&gt;&#039;;\n	//final 关键字代表的是最终，不能被重写或者重载\n	// PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。\n$teacher1-&gt;test();\n\n```\n## static、const 、self关键字 静态方法 、静态变量\n- 类内部声明const 常量 \n- 在类内部:使用self::常量访问 \n- 类外部使用:类名::常量\n```\n&lt;?php\nheader(&#039;content-type:text/html;charset=utf-8&#039;);\nclass Test{\n	const PI=3.14;\n	const COUNTY=&#039;中国&#039;;\n	public function testConst(){\n		echo self::PI.&#039;&lt;br/&gt;&#039;;\n		echo self::COUNTY.&#039;&lt;br/&gt;&#039;;\n		echo static::PI.&#039;&lt;br/&gt;&#039;;\n	}\n\n}\necho Test::PI;\necho &#039;&lt;br/&gt;&#039;;\necho Test::COUNTY;\necho &#039;&lt;br/&gt;&#039;;\n$t1=new Test;\n$t1-&gt;testConst();\necho &#039;&lt;br/&gt;&#039;;\n// echo $t1-&gt;PI;\n```\n`is_a($obj,\'OBJ\')`; //$obj是否属于OBJ类或者父类\n`($a instanceof A)`；//instanceof 用于确定一个 PHP 变量是否属于某一类 class 的实例：\n`get_class($a)`; //返回$a所属对象类名\n `get_parent_class()`:返回类或者对象的父类名',0,'http://localhost/qipajun/?p=53',0,'post','',0),
	(55,1,'2017-03-26 13:51:46','2017-03-26 05:51:46','<h1>抽象类 abstract</h1>\n\n<pre><code>通过abstract关键字定义抽象类，只要类中有一个抽象类方法，该类就必须定义为抽象类\n\n抽象类不能直接被实例化，只相当于定义了调用的方式，并没有具体的实现\n子类的继承的时候必须实现所有的抽象方法\n子类在实现抽象方法的时候，可见性可以和父类相同或者宽松\n</code></pre>\n\n<pre><code>&lt;?php\nheader(\'content-type:text/html;charset=utf-8\');\n/*\n通过abstract关键字定义抽象类，当类中至少有一个方法为抽象方法的时候，这个类就必须定义成抽象类\n抽象类不能直接被实例化，只相当于定义了调用的方式，并没有具体的实现\n子类的继承的时候必须实现所有的抽象方法\n子类在实现抽象方法的时候，可见性可以和父类相同或者宽松\n*/\nabstract class Pet{\n    public $name;\n    abstract public function eat();\n    abstract public function sleep();\n    public function breath(){\n        echo \'呼吸新鲜空气...&lt;br/&gt;\';\n    }\n}\nclass Cat extends Pet{\n    public function __construct($name){\n        $this-&gt;name=$name;\n    }\n    public function eat(){\n        echo $this-&gt;name.\' is eating...&lt;br/&gt;\';\n    }\n    public function sleep(){\n        echo $this-&gt;name.\' is sleeping...&lt;br/&gt;\';\n    }\n\n}\nclass Dog extends Pet{\n    public function __construct($name){\n        $this-&gt;name=$name;\n    }\n    public function eat(){\n        echo $this-&gt;name.\' is eating...&lt;br/&gt;\';\n    }\n    public function sleep(){\n        echo $this-&gt;name.\' is sleeping...&lt;br/&gt;\';\n    }\n}\n</code></pre>','5、抽象类','','publish','closed','open','','5%e3%80%81%e6%8a%bd%e8%b1%a1%e7%b1%bb','','','2017-03-26 13:51:46','2017-03-26 05:51:46','# 抽象类 abstract\n    通过abstract关键字定义抽象类，只要类中有一个抽象类方法，该类就必须定义为抽象类\n\n    抽象类不能直接被实例化，只相当于定义了调用的方式，并没有具体的实现\n    子类的继承的时候必须实现所有的抽象方法\n    子类在实现抽象方法的时候，可见性可以和父类相同或者宽松\n\n```\n&lt;?php\nheader(&#039;content-type:text/html;charset=utf-8&#039;);\n/*\n通过abstract关键字定义抽象类，当类中至少有一个方法为抽象方法的时候，这个类就必须定义成抽象类\n抽象类不能直接被实例化，只相当于定义了调用的方式，并没有具体的实现\n子类的继承的时候必须实现所有的抽象方法\n子类在实现抽象方法的时候，可见性可以和父类相同或者宽松\n*/\nabstract class Pet{\n	public $name;\n	abstract public function eat();\n	abstract public function sleep();\n	public function breath(){\n		echo &#039;呼吸新鲜空气...&lt;br/&gt;&#039;;\n	}\n}\nclass Cat extends Pet{\n	public function __construct($name){\n		$this-&gt;name=$name;\n	}\n	public function eat(){\n		echo $this-&gt;name.&#039; is eating...&lt;br/&gt;&#039;;\n	}\n	public function sleep(){\n		echo $this-&gt;name.&#039; is sleeping...&lt;br/&gt;&#039;;\n	}\n\n}\nclass Dog extends Pet{\n	public function __construct($name){\n		$this-&gt;name=$name;\n	}\n	public function eat(){\n		echo $this-&gt;name.&#039; is eating...&lt;br/&gt;&#039;;\n	}\n	public function sleep(){\n		echo $this-&gt;name.&#039; is sleeping...&lt;br/&gt;&#039;;\n	}\n}\n```',0,'http://localhost/qipajun/?p=55',0,'post','',0),
	(57,1,'2017-03-26 13:51:47','2017-03-26 05:51:47','<h1>interface 接口</h1>\n\n<pre><code>使用接口(interface)，可以指定继承类必须实现那些方法，方法必须都是共有，且不需要定义这些方法的具体内容\n</code></pre>\n\n<pre><code>//声明接口\ninterface iTest{\n    public function test(); //定义方法无需实现\n    public function sayHi($username);\n}\n//实现接口\nclass Test1 implements iTest{\n    //实现方法\n    public function test(){\n        echo \'this is a test&lt;br/&gt;\';\n    }\n    public function sayHi($username){\n        echo \'Say Hi to \'.$username.\'&lt;br/&gt;\';\n    }\n}\n</code></pre>\n\n<h3>实现多个接口</h3>\n\n<pre><code>interface iA{\n    public function test00();\n}\ninterface iB{\n    public function test11();\n}\ninterface iC{\n    public function test22();\n}\n//集成多个接口\nclass Test2 implements iA,iB,iC{\n    public function test00(){\n        echo \'00000&lt;br/&gt;\';\n    }\n    public function test11(){\n        echo \'11111&lt;br/&gt;\';\n    }\n    public function test22(){\n        echo \'22222&lt;br/&gt;\';\n    }\n}\n</code></pre>\n\n###也可以一个类集成另外一个类，再集成多个接口\n\n<pre><code>class Parent1{\n    public function hello(){\n        echo \'hello parent&lt;br/&gt;\';\n    }\n}\nclass Child1 extends Parent1 implements iA,iB{\n    public function test00(){\n        echo \'qqqq&lt;br/&gt;\';\n    }\n    public function test11(){\n        echo \'wwwww&lt;br/&gt;\';\n    }\n}\n\n\n//接口可以继承另外的接口，可以继承多个接口\ninterface iD extends iA,iB,iC{\n    const PI=3.14;\n    const COUNTY=\'China\';\n    public function test33();\n}\nclass Test3 implements iD{\n    public function test33(){\n        echo \'this is a test33...&lt;br/&gt;\';\n    }\n    public function test00(){\n        echo \'00000a&lt;br/&gt;\';\n    }\n    public function test11(){\n        echo \'11111b&lt;br/&gt;\';\n    }\n    public function test22(){\n        echo \'22222c&lt;br/&gt;\';\n    }\n}\n\n</code></pre>','6.interface定义接口','','publish','closed','open','','6-interface%e5%ae%9a%e4%b9%89%e6%8e%a5%e5%8f%a3','','','2017-03-26 13:51:47','2017-03-26 05:51:47','# interface 接口\n    使用接口(interface)，可以指定继承类必须实现那些方法，方法必须都是共有，且不需要定义这些方法的具体内容\n    \n```\n//声明接口\ninterface iTest{\n	public function test(); //定义方法无需实现\n	public function sayHi($username);\n}\n//实现接口\nclass Test1 implements iTest{\n    //实现方法\n	public function test(){\n		echo &#039;this is a test&lt;br/&gt;&#039;;\n	}\n	public function sayHi($username){\n		echo &#039;Say Hi to &#039;.$username.&#039;&lt;br/&gt;&#039;;\n	}\n}\n```\n\n### 实现多个接口\n```\ninterface iA{\n	public function test00();\n}\ninterface iB{\n	public function test11();\n}\ninterface iC{\n	public function test22();\n}\n//集成多个接口\nclass Test2 implements iA,iB,iC{\n	public function test00(){\n		echo &#039;00000&lt;br/&gt;&#039;;\n	}\n	public function test11(){\n		echo &#039;11111&lt;br/&gt;&#039;;\n	}\n	public function test22(){\n		echo &#039;22222&lt;br/&gt;&#039;;\n	}\n}\n```\n\n###也可以一个类集成另外一个类，再集成多个接口\n```\nclass Parent1{\n	public function hello(){\n		echo &#039;hello parent&lt;br/&gt;&#039;;\n	}\n}\nclass Child1 extends Parent1 implements iA,iB{\n	public function test00(){\n		echo &#039;qqqq&lt;br/&gt;&#039;;\n	}\n	public function test11(){\n		echo &#039;wwwww&lt;br/&gt;&#039;;\n	}\n}\n\n\n//接口可以继承另外的接口，可以继承多个接口\ninterface iD extends iA,iB,iC{\n	const PI=3.14;\n	const COUNTY=&#039;China&#039;;\n	public function test33();\n}\nclass Test3 implements iD{\n	public function test33(){\n		echo &#039;this is a test33...&lt;br/&gt;&#039;;\n	}\n	public function test00(){\n		echo &#039;00000a&lt;br/&gt;&#039;;\n	}\n	public function test11(){\n		echo &#039;11111b&lt;br/&gt;&#039;;\n	}\n	public function test22(){\n		echo &#039;22222c&lt;br/&gt;&#039;;\n	}\n}\n\n```',0,'http://localhost/qipajun/?p=57',0,'post','',0),
	(59,1,'2017-03-26 13:51:48','2017-03-26 05:51:48','<h1>多态</h1>\n\n<pre><code>多态是指在面向对象中能够根据使用类的上下文来重新定义或改变类的性质和行为\n\nphp不支持重载实现多态，单是php可以变相的实现多态效果。\n</code></pre>\n\n<pre><code>//接口实现多态\ninterface USB{\n    public function run();\n}\nclass Mouse implements USB{\n    public function run(){\n        echo \'鼠标可以使用...&lt;br/&gt;\';\n    }\n}\nclass Micro implements USB{\n    public function run(){\n        echo \'麦克风可以使用...&lt;br/&gt;\';\n    }\n}\nclass Computer{\n    public function useUSB($usbObj){\n        $usbObj-&gt;run();\n    }\n}\n$computer1=new Computer;\n$computer1-&gt;useUSB(new Mouse);\n$computer1-&gt;useUSB(new Micro);\n</code></pre>','7、多态','','publish','closed','open','','7%e3%80%81%e5%a4%9a%e6%80%81','','','2017-03-26 13:51:48','2017-03-26 05:51:48','# 多态\n    多态是指在面向对象中能够根据使用类的上下文来重新定义或改变类的性质和行为\n\n    php不支持重载实现多态，单是php可以变相的实现多态效果。\n\n```\n//接口实现多态\ninterface USB{\n	public function run();\n}\nclass Mouse implements USB{\n	public function run(){\n		echo &#039;鼠标可以使用...&lt;br/&gt;&#039;;\n	}\n}\nclass Micro implements USB{\n	public function run(){\n		echo &#039;麦克风可以使用...&lt;br/&gt;&#039;;\n	}\n}\nclass Computer{\n	public function useUSB($usbObj){\n		$usbObj-&gt;run();\n	}\n}\n$computer1=new Computer;\n$computer1-&gt;useUSB(new Mouse);\n$computer1-&gt;useUSB(new Micro);\n```',0,'http://localhost/qipajun/?p=59',0,'post','',0),
	(61,1,'2017-03-26 13:51:48','2017-03-26 05:51:48','<h1>魔术方法</h1>\n\n<h2>常见魔术方法：</h2>\n\n__construct():\n__destruct():\n__set():\n__get():\n__toString():输出对象的时候会被自动调用,返回字符串\n__invoke():当以调用函数的方式调用对象的时候，会自动触发这个方法\n__call():当对象调用一个不可或者不存在访问的方法的时候，自动调用\n__callStatic():用静态的方式调用一个不可访问的或者不存在的方法，会自动调用\n__clone():克隆对象的时候自动调用\n__wakeup():反序列化对象的时候会自动调用\n__sleep():序列化对象的时候会自动调用\n\n<pre><code>class Test{\n    public $username=\'king\';\n    protected $money=123456.89;\n    private $age=12;\n    public $test1=\'this is a test1\';\n    public function __toString(){\n        echo \'当输出对象的时候...我才自动调用&lt;br/&gt;\';\n        return \'hello object\';\n    }\n    private function testPrivate(){\n        echo \'this is private func&lt;br/&gt;\';\n    }\n    public function __invoke(){\n        print_r(func_get_args());\n        echo \'当以调用函数的方式调用对象的时候，会自动触发这个方法...&lt;br/&gt;\';\n    }\n    public function __call($methodName,$args){\n        echo \'__call methodName:\'.$methodName.\'&lt;br/&gt;\';\n        print_r($args);\n    }\n    private static function testPrivateStatic(){\n        echo \'this is a private Static function...&lt;br/&gt;\';\n    }\n    public static function __callStatic($methodName,$args){\n        echo \'__callStatic StaticMethodName:\'.$methodName.\'&lt;br/&gt;\';\n        print_r($args);\n    }\n    public function __sleep(){\n        echo \'对象被序列化了...&lt;br/&gt;\';\n        return array(\'username\',\'age\');\n    }\n    public function __wakeup(){\n        echo \'反序列化得时候自动调用...&lt;br/&gt;\';\n        $this-&gt;username=\'queen\';\n        echo $this-&gt;username.\'&lt;br/&gt;\';\n    }\n}\n$test=new Test;\n// echo $test;\n//$test(10,20,30,\'test\');\n//echo \'&lt;br/&gt;\';\n//$test-&gt;noExists(1,2,3,4,5);\n//echo \'&lt;hr/&gt;\';\n//$test-&gt;testPrivate();\n//echo \'&lt;hr/&gt;\';\n//Test::testPrivateStatic(123123);\n//echo \'&lt;hr/&gt;\';\n//Test::noExistsStatic();\n</code></pre>','8、魔术方法','','publish','closed','open','','8%e3%80%81%e9%ad%94%e6%9c%af%e6%96%b9%e6%b3%95','','','2017-03-26 13:51:48','2017-03-26 05:51:48','# 魔术方法\n## 常见魔术方法：\n__construct():\n__destruct():\n__set():\n__get():\n__toString():输出对象的时候会被自动调用,返回字符串\n__invoke():当以调用函数的方式调用对象的时候，会自动触发这个方法\n__call():当对象调用一个不可或者不存在访问的方法的时候，自动调用\n__callStatic():用静态的方式调用一个不可访问的或者不存在的方法，会自动调用\n__clone():克隆对象的时候自动调用\n__wakeup():反序列化对象的时候会自动调用\n__sleep():序列化对象的时候会自动调用\n\n\n```\nclass Test{\n	public $username=&#039;king&#039;;\n	protected $money=123456.89;\n	private $age=12;\n	public $test1=&#039;this is a test1&#039;;\n	public function __toString(){\n		echo &#039;当输出对象的时候...我才自动调用&lt;br/&gt;&#039;;\n		return &#039;hello object&#039;;\n	}\n	private function testPrivate(){\n		echo &#039;this is private func&lt;br/&gt;&#039;;\n	}\n	public function __invoke(){\n		print_r(func_get_args());\n		echo &#039;当以调用函数的方式调用对象的时候，会自动触发这个方法...&lt;br/&gt;&#039;;\n	}\n	public function __call($methodName,$args){\n		echo &#039;__call methodName:&#039;.$methodName.&#039;&lt;br/&gt;&#039;;\n		print_r($args);\n	}\n	private static function testPrivateStatic(){\n		echo &#039;this is a private Static function...&lt;br/&gt;&#039;;\n	}\n	public static function __callStatic($methodName,$args){\n		echo &#039;__callStatic StaticMethodName:&#039;.$methodName.&#039;&lt;br/&gt;&#039;;\n		print_r($args);\n	}\n	public function __sleep(){\n		echo &#039;对象被序列化了...&lt;br/&gt;&#039;;\n		return array(&#039;username&#039;,&#039;age&#039;);\n	}\n	public function __wakeup(){\n		echo &#039;反序列化得时候自动调用...&lt;br/&gt;&#039;;\n		$this-&gt;username=&#039;queen&#039;;\n		echo $this-&gt;username.&#039;&lt;br/&gt;&#039;;\n	}\n}\n$test=new Test;\n// echo $test;\n//$test(10,20,30,&#039;test&#039;);\n//echo &#039;&lt;br/&gt;&#039;;\n//$test-&gt;noExists(1,2,3,4,5);\n//echo &#039;&lt;hr/&gt;&#039;;\n//$test-&gt;testPrivate();\n//echo &#039;&lt;hr/&gt;&#039;;\n//Test::testPrivateStatic(123123);\n//echo &#039;&lt;hr/&gt;&#039;;\n//Test::noExistsStatic();\n```',0,'http://localhost/qipajun/?p=61',0,'post','',0),
	(63,1,'2017-03-26 13:51:48','2017-03-26 05:51:48','<h2>php工厂模式</h2>\n\n<ul>\n<li>工厂模式: 就是负责生成其他对象的类或方法。</li>\n<li>代码 : 实现交通工具接口的类</li>\n</ul>\n\n<pre><code>interface Vehicle\n{\n    public function drive();\n}\n\nclass Car implements Vehicle\n{\n    public function drive()\n    {\n        echo \'汽车靠四个轮子滚动行走。\';\n    }\n}\n\nclass Ship implements Vehicle\n{\n    public function drive()\n    {\n        echo \'轮船靠螺旋桨划水前进。\';\n    }\n}\n\nclass Aircraft implements Vehicle\n{\n    public function drive()\n    {\n        echo \'飞机靠螺旋桨和机翼的升力飞行。\';\n    }\n}\n</code></pre>\n\n<ul>\n<li>代码: 创建工厂类，转码用作类的创建</li>\n</ul>\n\n<pre><code>class VehicleFactory\n{\n    public static function build($className = null)\n    {\n        $className = ucfirst($className);\n        if ($className &amp;&amp; class_exists($className)) {\n            return new $className();\n        }\n        return null;\n    }\n}\n</code></pre>\n\n<ul>\n<li>使用:</li>\n</ul>\n\n<pre><code>VehicleFactory::build(\'Car\')-&gt;drive();\nVehicleFactory::build(\'Ship\')-&gt;drive();\nVehicleFactory::build(\'Aircraft\')-&gt;drive();\n</code></pre>\n\n<ul>\n<li>工厂模式实际就是建立一个统一的类实例化接口，统一调用，统一控制。</li>\n<li>工厂模式是PHP项目开发中，最常用的设计模式，一般会配合单例模式一起使用，来加载php类库中的类。</li>\n<li>例二</li>\n</ul>\n\n<pre><code>//工厂模式 提供获取某个对象实例的一个接口，同时使调用代码避免确定实例化基类的步骤  \n//字符串类  \nclass String {  \n    public function write() {}  \n}  \n//Json类  \nclass Json {  \n    public function getJsonData() {}  \n}  \n//xml类  \nclass Xml {  \n    public function buildXml() {}  \n}  \n//工厂类  \nclass Factory {  \n    public static function create($class) {  \n        return new $class;  \n    }  \n}  \nFactory::create(\"Json\"); //获取Json对象  \n</code></pre>','工厂模式','','publish','closed','open','','%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:48','2017-03-26 05:51:48','## php工厂模式\n- 工厂模式: 就是负责生成其他对象的类或方法。\n- 代码 : 实现交通工具接口的类\n```\ninterface Vehicle\n{\n    public function drive();\n}\n\nclass Car implements Vehicle\n{\n    public function drive()\n    {\n        echo &#039;汽车靠四个轮子滚动行走。&#039;;\n    }\n}\n\nclass Ship implements Vehicle\n{\n    public function drive()\n    {\n        echo &#039;轮船靠螺旋桨划水前进。&#039;;\n    }\n}\n\nclass Aircraft implements Vehicle\n{\n    public function drive()\n    {\n        echo &#039;飞机靠螺旋桨和机翼的升力飞行。&#039;;\n    }\n}\n```\n- 代码: 创建工厂类，转码用作类的创建\n```\nclass VehicleFactory\n{\n    public static function build($className = null)\n    {\n        $className = ucfirst($className);\n        if ($className &amp;&amp; class_exists($className)) {\n            return new $className();\n        }\n        return null;\n    }\n}\n```\n- 使用:\n```\nVehicleFactory::build(&#039;Car&#039;)-&gt;drive();\nVehicleFactory::build(&#039;Ship&#039;)-&gt;drive();\nVehicleFactory::build(&#039;Aircraft&#039;)-&gt;drive();\n```\n- 工厂模式实际就是建立一个统一的类实例化接口，统一调用，统一控制。\n- 工厂模式是PHP项目开发中，最常用的设计模式，一般会配合单例模式一起使用，来加载php类库中的类。\n- 例二\n```\n//工厂模式 提供获取某个对象实例的一个接口，同时使调用代码避免确定实例化基类的步骤  \n//字符串类  \nclass String {  \n    public function write() {}  \n}  \n//Json类  \nclass Json {  \n    public function getJsonData() {}  \n}  \n//xml类  \nclass Xml {  \n    public function buildXml() {}  \n}  \n//工厂类  \nclass Factory {  \n    public static function create($class) {  \n        return new $class;  \n    }  \n}  \nFactory::create(&quot;Json&quot;); //获取Json对象  \n```',0,'http://localhost/qipajun/?p=63',0,'post','',0),
	(65,1,'2017-03-26 13:51:49','2017-03-26 05:51:49','<h2>中介者模式</h2>\n\n<ul>\n<li>中介者设计模式用于开发一个对象，这个对象能够在类似对象相互之间不直接交互的情况下传送或调解对这些对象的集合的修改。</li>\n<li>代码</li>\n</ul>\n\n<pre><code>class CD {\n    public $band  = \'\';\n    public $title = \'\';\n    protected $_mediator;\n\n    public function __construct(MusicContainerMediator $mediator = NULL) {\n        $this-&gt;_mediator = $mediator;\n    }\n\n    public function save() {\n        //具体实现待定\n        var_dump($this);\n    }\n\n    public function changeBandName($bandname) {\n        if ( ! is_null($this-&gt;_mediator)) {\n            $this-&gt;_mediator-&gt;change($this, array(\"band\" =&gt; $bandname));\n        }\n        $this-&gt;band = $bandname;\n        $this-&gt;save();\n    }\n}\n//MP3Archive类\nclass MP3Archive {\n    protected $_mediator;\n\n    public function __construct(MusicContainerMediator $mediator = NULL) {\n        $this-&gt;_mediator = $mediator;\n    }\n\n    public function save() {\n        //具体实现待定\n        var_dump($this);\n    }\n\n    public function changeBandName($bandname) {\n        if ( ! is_null($this-&gt;_mediator)) {\n            $this-&gt;_mediator-&gt;change($this, array(\"band\" =&gt; $bandname));\n        }\n        $this-&gt;band = $bandname;\n        $this-&gt;save();\n    }\n\n}\n\n//中介者类\nclass MusicContainerMediator {\n    protected $_containers = array();\n\n    public function __construct() {\n        $this-&gt;_containers[] = \"CD\";\n        $this-&gt;_containers[] = \"MP3Archive\";\n    }\n\n    public function change($originalObject, $newValue) {\n        $title = $originalObject-&gt;title;\n        $band  = $originalObject-&gt;band;\n        foreach ($this-&gt;_containers as $container) {\n            if ( ! ($originalObject instanceof $container)) {\n                $object = new $container;\n                $object-&gt;title = $title;\n                $object-&gt;band  = $band;\n                foreach ($newValue as $key =&gt; $val) {\n                    $object-&gt;$key = $val;\n                }\n                $object-&gt;save();\n            }\n        }\n    }\n}\n\n//测试实例\n$titleFromDB = \"Waste of a Rib\";\n$bandFromDB  = \"Never Again\";\n$mediator = new MusicContainerMediator();\n$cd = new CD($mediator);\n$cd-&gt;title = $titleFromDB;\n$cd-&gt;band  = $bandFromDB;\n$cd-&gt;changeBandName(\"Maybe Once More\");\n</code></pre>','中介者模式','','publish','closed','open','','%e4%b8%ad%e4%bb%8b%e8%80%85%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:49','2017-03-26 05:51:49','## 中介者模式\n- 中介者设计模式用于开发一个对象，这个对象能够在类似对象相互之间不直接交互的情况下传送或调解对这些对象的集合的修改。\n- 代码\n```\nclass CD {\n    public $band  = &#039;&#039;;\n    public $title = &#039;&#039;;\n    protected $_mediator;\n\n    public function __construct(MusicContainerMediator $mediator = NULL) {\n        $this-&gt;_mediator = $mediator;\n    }\n\n    public function save() {\n        //具体实现待定\n        var_dump($this);\n    }\n\n    public function changeBandName($bandname) {\n        if ( ! is_null($this-&gt;_mediator)) {\n            $this-&gt;_mediator-&gt;change($this, array(&quot;band&quot; =&gt; $bandname));\n        }\n        $this-&gt;band = $bandname;\n        $this-&gt;save();\n    }\n}\n//MP3Archive类\nclass MP3Archive {\n    protected $_mediator;\n\n    public function __construct(MusicContainerMediator $mediator = NULL) {\n        $this-&gt;_mediator = $mediator;\n    }\n\n    public function save() {\n        //具体实现待定\n        var_dump($this);\n    }\n\n    public function changeBandName($bandname) {\n        if ( ! is_null($this-&gt;_mediator)) {\n            $this-&gt;_mediator-&gt;change($this, array(&quot;band&quot; =&gt; $bandname));\n        }\n        $this-&gt;band = $bandname;\n        $this-&gt;save();\n    }\n\n}\n\n//中介者类\nclass MusicContainerMediator {\n    protected $_containers = array();\n\n    public function __construct() {\n        $this-&gt;_containers[] = &quot;CD&quot;;\n        $this-&gt;_containers[] = &quot;MP3Archive&quot;;\n    }\n\n    public function change($originalObject, $newValue) {\n        $title = $originalObject-&gt;title;\n        $band  = $originalObject-&gt;band;\n        foreach ($this-&gt;_containers as $container) {\n            if ( ! ($originalObject instanceof $container)) {\n                $object = new $container;\n                $object-&gt;title = $title;\n                $object-&gt;band  = $band;\n                foreach ($newValue as $key =&gt; $val) {\n                    $object-&gt;$key = $val;\n                }\n                $object-&gt;save();\n            }\n        }\n    }\n}\n\n//测试实例\n$titleFromDB = &quot;Waste of a Rib&quot;;\n$bandFromDB  = &quot;Never Again&quot;;\n$mediator = new MusicContainerMediator();\n$cd = new CD($mediator);\n$cd-&gt;title = $titleFromDB;\n$cd-&gt;band  = $bandFromDB;\n$cd-&gt;changeBandName(&quot;Maybe Once More&quot;);\n```',0,'http://localhost/qipajun/?p=65',0,'post','',0),
	(67,1,'2017-03-26 13:51:49','2017-03-26 05:51:49','<blockquote>\n  <ul>\n  <li>设计模式概述</li>\n  </ul>\n</blockquote>\n\n<ul>\n<li><code>什么是设计模式？</code>  设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</li>\n<li>项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。\n\n<blockquote>\n  <ul>\n  <li>设计模式的特点</li>\n  </ul>\n</blockquote>\n\n<ol>\n<li><strong>复用解决方案</strong>: 设计模式本身就是对某一类问题的通用解决方案，是更高级别的服用，已经超出了代码复用。</li>\n<li><strong>确定通用术语</strong>: 开发中的交流和协作都需要共同的词汇其础和对问题的共识. 当你有想表达却又表达不清楚的设计思路，即使表达出来也会被同事误解的时候，设计模式就显出沟通的优势了。</li>\n<li><strong>代码更易于修改与维护</strong>:因为设计模式都是久经考验的解决方案,它们的结构都是经过长期的发展形成的，善于应对变化，设计模式本身也是对变化点的封装。</li>\n<li><strong>模式有助于提高思考层次</strong>:  学习模式后,就算不用模式中的方法，也会更好的采取策略去解决问题。\n> - php 设计模式原则</li>\n</ol></li>\n</ul>\n\n<ol>\n<li>**单一职责  **:不要存在多于一个导致类变更的原因。通俗的说，即<code>一个类只负责一项职责</code></li>\n<li><strong>里氏替换原则</strong>:所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类可以扩展父类的功能，但不能改变父类原有的功能。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</li>\n<li><strong>依赖倒置原则</strong>: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n    一般会在项目框架的搭建的时候用到，例如，业务逻辑层相对于数据层是高层模块，因为业务逻辑层需要调用数据层去连接数据库，但是要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口。</li>\n<li><strong>接口隔离原则</strong>: 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li>\n<li><strong>迪米特法则</strong>: 一个对象应该对其他对象保持最少的了解。\n\n<ol>\n<li>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</li>\n<li>简单的理解就是高内聚，一个类尽量减少对其他对象的依赖，并且这个类的方法和属性能用私有的就尽量私有化。</li>\n<li>注意：\n    1.  只与直接的朋友通信，不要和陌生人说话。\n    2. 过分的使用该原则，将导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</li>\n</ol></li>\n<li><strong>开闭原则</strong>: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n<ol>\n<li>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</li>\n<li>当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li>\n</ol></li>\n</ol>','什么是设计模式？','','publish','closed','open','','%e4%bb%80%e4%b9%88%e6%98%af%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%9f','','','2017-03-26 13:51:49','2017-03-26 05:51:49','> -   设计模式概述\n\n-  `什么是设计模式？`  设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。\n- 项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。\n> -  设计模式的特点\n\n   1. **复用解决方案**: 设计模式本身就是对某一类问题的通用解决方案，是更高级别的服用，已经超出了代码复用。\n   2.  **确定通用术语**: 开发中的交流和协作都需要共同的词汇其础和对问题的共识. 当你有想表达却又表达不清楚的设计思路，即使表达出来也会被同事误解的时候，设计模式就显出沟通的优势了。\n   3.  **代码更易于修改与维护**:因为设计模式都是久经考验的解决方案,它们的结构都是经过长期的发展形成的，善于应对变化，设计模式本身也是对变化点的封装。\n   4. **模式有助于提高思考层次**:  学习模式后,就算不用模式中的方法，也会更好的采取策略去解决问题。\n> - php 设计模式原则\n\n1.  **单一职责  **:不要存在多于一个导致类变更的原因。通俗的说，即`一个类只负责一项职责`\n2. **里氏替换原则**:所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类可以扩展父类的功能，但不能改变父类原有的功能。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。\n3. **依赖倒置原则**: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n        一般会在项目框架的搭建的时候用到，例如，业务逻辑层相对于数据层是高层模块，因为业务逻辑层需要调用数据层去连接数据库，但是要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口。\n4. **接口隔离原则**: 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。\n5. **迪米特法则**: 一个对象应该对其他对象保持最少的了解。\n    1. 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n    2.  简单的理解就是高内聚，一个类尽量减少对其他对象的依赖，并且这个类的方法和属性能用私有的就尽量私有化。\n    3. 注意：\n            1.  只与直接的朋友通信，不要和陌生人说话。\n            2. 过分的使用该原则，将导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。\n6. **开闭原则**: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n    1.  在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。\n    2.  当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。',0,'http://localhost/qipajun/?p=67',0,'post','',0),
	(69,1,'2017-03-26 13:51:49','2017-03-26 05:51:49','<h2>php观察者模式</h2>\n\n<ul>\n<li><code>观察者模式</code>也称之为<code>发布-订阅模式</code>。</li>\n<li>观察者设计模式能够更便利创建和查看目标对象状态的对象，并且提供和核心对象非耦合的置顶功能性。</li>\n<li>观察者设计模式非常常用，在一般复杂的WEB系统中，观察者模式可以帮你减轻代码设计的压力，降低代码耦合。</li>\n<li>以一个购物流程为例子</li>\n</ul>\n\n<pre><code>class order {\n\n    protected $observers = array(); // 存放观察容器\n\n    //观察者新增\n    public function addObServer($type, $observer) {\n        $this-&gt;observers[$type][] = $observer;\n    }\n\n    //运行观察者\n    public function obServer($type) {\n        if (isset($this-&gt;observers[$type])) {\n            foreach ($this-&gt;observers[$type] as $obser) {\n                $a = new $obser;\n                $a-&gt;update($this); //公用方法\n            }\n        }\n    }\n\n    //下单购买流程\n    public function create() {\n        echo \'购买成功\' .\"\\n\";\n        $this-&gt;obServer(\'buy\'); // buy动作\n    }\n}\nclass orderEmail {\n    public static function update($order) {\n        echo \'发送购买成功一个邮件\' .\"\\n\";\n    }\n}\nclass orderStatus {\n    public static function update($order) {\n        echo \'改变订单状态\' .\"\\n\";\n    }\n}\n$ob = new order;\n$ob-&gt;addObServer(\'buy\', \'orderEmail\');\n$ob-&gt;addObServer(\'buy\', \'orderStatus\');\n$ob-&gt;create();\n</code></pre>\n\n<ul>\n<li>输出</li>\n</ul>\n\n<pre><code>购买成功\n发送购买成功一个邮件\n改变订单状态\n</code></pre>\n\n<ul>\n<li>观察者设计模式能够更便利创建和查看目标对象状态的对象，并且提供和核心对象非耦合的置顶功能性。观察者设计模式非常常用，在一般复杂的WEB系统中，观察者模式可以帮你减轻代码设计的压力，降低代码耦合。</li>\n</ul>','观察者模式','','publish','closed','open','','%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:49','2017-03-26 05:51:49','## php观察者模式\n- `观察者模式`也称之为`发布-订阅模式`。\n- 观察者设计模式能够更便利创建和查看目标对象状态的对象，并且提供和核心对象非耦合的置顶功能性。\n- 观察者设计模式非常常用，在一般复杂的WEB系统中，观察者模式可以帮你减轻代码设计的压力，降低代码耦合。\n- 以一个购物流程为例子\n```\nclass order {\n\n    protected $observers = array(); // 存放观察容器\n\n    //观察者新增\n    public function addObServer($type, $observer) {\n        $this-&gt;observers[$type][] = $observer;\n    }\n\n    //运行观察者\n    public function obServer($type) {\n        if (isset($this-&gt;observers[$type])) {\n            foreach ($this-&gt;observers[$type] as $obser) {\n                $a = new $obser;\n                $a-&gt;update($this); //公用方法\n            }\n        }\n    }\n\n    //下单购买流程\n    public function create() {\n        echo &#039;购买成功&#039; .&quot;\\n&quot;;\n        $this-&gt;obServer(&#039;buy&#039;); // buy动作\n    }\n}\nclass orderEmail {\n    public static function update($order) {\n        echo &#039;发送购买成功一个邮件&#039; .&quot;\\n&quot;;\n    }\n}\nclass orderStatus {\n    public static function update($order) {\n        echo &#039;改变订单状态&#039; .&quot;\\n&quot;;\n    }\n}\n$ob = new order;\n$ob-&gt;addObServer(&#039;buy&#039;, &#039;orderEmail&#039;);\n$ob-&gt;addObServer(&#039;buy&#039;, &#039;orderStatus&#039;);\n$ob-&gt;create();\n```\n- 输出\n```\n购买成功\n发送购买成功一个邮件\n改变订单状态\n```\n\n- 观察者设计模式能够更便利创建和查看目标对象状态的对象，并且提供和核心对象非耦合的置顶功能性。观察者设计模式非常常用，在一般复杂的WEB系统中，观察者模式可以帮你减轻代码设计的压力，降低代码耦合。',0,'http://localhost/qipajun/?p=69',0,'post','',0),
	(71,1,'2017-03-26 13:51:50','2017-03-26 05:51:50','<h2>外观模式</h2>\n\n<blockquote>\n  <ul>\n  <li>通过在必须的逻辑和方法的集合前创建简单的外观接口，外观设计模式隐藏了来自调用对象的复杂性。</li>\n  </ul>\n</blockquote>\n\n<ul>\n<li>设计一个User类</li>\n</ul>\n\n<pre><code class=\"php\">class User {\n\n    protected $userName;\n    protected $userAge;\n\n    public function setUserName($userName) {\n        return $this-&gt;userName = $userName;\n    }\n\n    public function setUserAge($userAge) {\n        return $this-&gt;userAge = $userAge;\n    }\n\n    public function getUser() {\n        echo \'用户姓名：\' . $this-&gt;userName . \'； 用户年龄：\' . $this-&gt;userAge;\n    }\n\n}\n</code></pre>\n\n<ul>\n<li>设计用户类的外观接口</li>\n</ul>\n\n<pre><code class=\"php\">class UserFacade {\n    public static function getUserCall($userInfo) {\n        $User = new User;\n        $User-&gt;setUserName($userInfo[\'username\']);\n        $User-&gt;setUserAge($userInfo[\'userAge\']);\n        return $User-&gt;getUser();\n    }\n}\n</code></pre>\n\n<ul>\n<li>调用执行代码</li>\n</ul>\n\n<pre><code class=\"php\">$userInfo = array(\'username\' =&gt; \'initphp\', \'userAge\' =&gt; 12);\nUserFacade::getUserCall($userInfo); //只要一个函数就能将调用类简化\n</code></pre>\n\n<ul>\n<li>输出</li>\n</ul>\n\n<pre><code>用户姓名：initphp； 用户年龄：12\n</code></pre>','外观模式','','publish','closed','open','','%e5%a4%96%e8%a7%82%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:50','2017-03-26 05:51:50','## 外观模式\n> -  通过在必须的逻辑和方法的集合前创建简单的外观接口，外观设计模式隐藏了来自调用对象的复杂性。\n\n-  设计一个User类\n```php\nclass User {\n\n    protected $userName;\n    protected $userAge;\n\n    public function setUserName($userName) {\n        return $this-&gt;userName = $userName;\n    }\n\n    public function setUserAge($userAge) {\n        return $this-&gt;userAge = $userAge;\n    }\n\n    public function getUser() {\n        echo &#039;用户姓名：&#039; . $this-&gt;userName . &#039;； 用户年龄：&#039; . $this-&gt;userAge;\n    }\n\n}\n```\n- 设计用户类的外观接口\n```php\nclass UserFacade {\n    public static function getUserCall($userInfo) {\n        $User = new User;\n        $User-&gt;setUserName($userInfo[&#039;username&#039;]);\n        $User-&gt;setUserAge($userInfo[&#039;userAge&#039;]);\n        return $User-&gt;getUser();\n    }\n}\n```\n- 调用执行代码\n```php\n$userInfo = array(&#039;username&#039; =&gt; &#039;initphp&#039;, &#039;userAge&#039; =&gt; 12);\nUserFacade::getUserCall($userInfo); //只要一个函数就能将调用类简化\n```\n- 输出\n```\n用户姓名：initphp； 用户年龄：12\n```',0,'http://localhost/qipajun/?p=71',0,'post','',0),
	(73,1,'2017-03-26 13:51:50','2017-03-26 05:51:50','<h2>委托模式</h2>\n\n<ul>\n<li>通过分配或委托至其他对象，委托设计模式能够去除核心对象的判决和复杂的功能性。</li>\n<li>为其他对象提供一种代理以控制这个对象的访问。</li>\n<li>代码</li>\n</ul>\n\n<pre><code>class Bank{\n    protected $info;\n\n    public function updateBrankInfo($type,$money){\n        $this-&gt;info[$type]=$money;\n    }\n\n    public function brankWithdraw($branktype){\n        $obj=new $branktype;\n        return $obj-&gt;brankMain($this-&gt;info);\n    }\n}\n\n/*\n委托接口\n*/\ninterface Delegate{\n    public function brankMain($info);\n}\n\n/*\n存款操作类\n*/\nclass brankDeposit implements Delegate{\n\n    public function brankMain($info){\n        echo $info[\'deposit\'];\n    }\n}\n\n/*\n取款操作类\n*/\nclass brankWithdraw implements Delegate{\n    public function brankMain($info){\n        echo $info[\'withdraw\'];\n    }\n}\n\n\n$bank=new Bank();\n$bank-&gt;updateBrankInfo(\"deposit\",\"4000\");\n$bank-&gt;updateBrankInfo(\"withdraw\",\"2000\");\n$bank-&gt;brankWithdraw(\"brankDeposit\");\necho \"&lt;br&gt;\";\n$bank-&gt;brankWithdraw(\"brankWithdraw\");\n</code></pre>','委托模式','','publish','closed','open','','%e5%a7%94%e6%89%98%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:50','2017-03-26 05:51:50','## 委托模式\n- 通过分配或委托至其他对象，委托设计模式能够去除核心对象的判决和复杂的功能性。\n- 为其他对象提供一种代理以控制这个对象的访问。\n- 代码\n```\nclass Bank{\n    protected $info;\n    \n    public function updateBrankInfo($type,$money){\n        $this-&gt;info[$type]=$money;\n    }\n    \n    public function brankWithdraw($branktype){\n        $obj=new $branktype;\n        return $obj-&gt;brankMain($this-&gt;info);\n    }\n}\n\n/*\n委托接口\n*/\ninterface Delegate{\n    public function brankMain($info);\n}\n\n/*\n存款操作类\n*/\nclass brankDeposit implements Delegate{\n    \n    public function brankMain($info){\n        echo $info[&#039;deposit&#039;];\n    }\n}\n\n/*\n取款操作类\n*/\nclass brankWithdraw implements Delegate{\n    public function brankMain($info){\n        echo $info[&#039;withdraw&#039;];\n    }\n}\n\n\n$bank=new Bank();\n$bank-&gt;updateBrankInfo(&quot;deposit&quot;,&quot;4000&quot;);\n$bank-&gt;updateBrankInfo(&quot;withdraw&quot;,&quot;2000&quot;);\n$bank-&gt;brankWithdraw(&quot;brankDeposit&quot;);\necho &quot;&lt;br&gt;&quot;;\n$bank-&gt;brankWithdraw(&quot;brankWithdraw&quot;);\n```',0,'http://localhost/qipajun/?p=73',0,'post','',0),
	(75,1,'2017-03-26 13:51:51','2017-03-26 05:51:51','<h2>建造者模式</h2>\n\n<ul>\n<li>建造者模式主要是为了消除其它对象复杂的创建过程。</li>\n<li>建造者设计模式定义了处理其他对象的复杂构建的对象设计。</li>\n<li>普通构建类</li>\n</ul>\n\n<pre><code>/* 描述一个用户的类，包含用户姓名，年龄，金钱 */\nclass UserInfo {\n\n    protected $userName = \'\';\n    protected $userAge = \'\';\n    protected $userMoney = \'\';\n\n    public function setUserName($userName) {\n        $this-&gt;userName = $userName;\n    }\n\n    public function setUserAge($userAge) {\n        $this-&gt;userAge = $userAge;\n    }\n\n    public function setUserMoney($userMoney) {\n        $this-&gt;userMoney = $userMoney;\n    }\n\n    public function getPeople() {\n        echo \"这个人的姓名是：\" . $this-&gt;userName . \',年龄是：\'  . $this-&gt;userAge . \', 金钱：\' . $this-&gt;userMoney;\n    }\n}\n/* 实例化，并且创建这个用户的时候，是很痛苦的，需要设置用户名，年龄和金钱*/\n$peopleInfo = array(\n    \'userName\' =&gt; \'initphp\',\n    \'userAge\' =&gt; 28,\n    \'userMoney\' =&gt; \'100元\'\n);\n$UserInfo = new UserInfo;\n//下面需要一步步的设置用户信息，才能得到用户详细信息，过程纠结而痛苦\n$UserInfo-&gt;setUserName($peopleInfo[\'userName\']);\n$UserInfo-&gt;setUserAge($peopleInfo[\'userAge\']);\n$UserInfo-&gt;setUserMoney($peopleInfo[\'userMoney\']);\n$UserInfo-&gt;getPeople();\n</code></pre>\n\n<ul>\n<li>建造者模式实现</li>\n</ul>\n\n<pre><code>//建造者模式，目的是消除其它对象复杂的创建过程\nclass UserInfoBuilder {\n    protected $obj;\n\n    public function __construct() {\n        $this-&gt;obj = new UserInfo;\n    }\n\n    public function buildPeople($peopleInfo) {\n        foreach ($peopleInfo as $k=&gt; $v) {\n            $method = sprintf(\'set%s\',ucfirst($k));\n            $this-&gt;obj-&gt;$method($v);\n        }\n    }\n\n    public function getPeople() {\n        $this-&gt;obj-&gt;getPeople();\n    }\n}\n\n/* 创建过程被封装了，用户使用简单了 */\n$peopleInfo = array(\n    \'userName\' =&gt; \'initphp\',\n    \'userAge\' =&gt; 28,\n    \'userMoney\' =&gt; \'100元\'\n);\n$UserInfoBuilder = new UserInfoBuilder;\n$UserInfoBuilder-&gt;buildPeople($peopleInfo); //直接一个build\n$UserInfoBuilder-&gt;getPeople();\n</code></pre>\n\n<ul>\n<li>基于建造者设计模式创建一个新的对象。这个对象负责解释来自业务逻辑的结果，并且只调用构建完整小配件所需的功能性。即使必要的信息或业务规则发生变化，主流代码仍然采用相同的处理方式Builder对象。我们只需要修改Builder对象(只在一个位置修改)。这个解决方案不仅节省了时间，而且降低了主代码库的复杂性。</li>\n</ul>','建造者模式','','publish','closed','open','','%e5%bb%ba%e9%80%a0%e8%80%85%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:51','2017-03-26 05:51:51','## 建造者模式\n- 建造者模式主要是为了消除其它对象复杂的创建过程。\n- 建造者设计模式定义了处理其他对象的复杂构建的对象设计。\n- 普通构建类\n```\n/* 描述一个用户的类，包含用户姓名，年龄，金钱 */\nclass UserInfo {\n\n    protected $userName = &#039;&#039;;\n    protected $userAge = &#039;&#039;;\n    protected $userMoney = &#039;&#039;;\n\n    public function setUserName($userName) {\n        $this-&gt;userName = $userName;\n    }\n\n    public function setUserAge($userAge) {\n        $this-&gt;userAge = $userAge;\n    }\n\n    public function setUserMoney($userMoney) {\n        $this-&gt;userMoney = $userMoney;\n    }\n\n    public function getPeople() {\n        echo &quot;这个人的姓名是：&quot; . $this-&gt;userName . &#039;,年龄是：&#039;  . $this-&gt;userAge . &#039;, 金钱：&#039; . $this-&gt;userMoney;\n    }\n}\n/* 实例化，并且创建这个用户的时候，是很痛苦的，需要设置用户名，年龄和金钱*/\n$peopleInfo = array(\n    &#039;userName&#039; =&gt; &#039;initphp&#039;,\n    &#039;userAge&#039; =&gt; 28,\n    &#039;userMoney&#039; =&gt; &#039;100元&#039;\n);\n$UserInfo = new UserInfo;\n//下面需要一步步的设置用户信息，才能得到用户详细信息，过程纠结而痛苦\n$UserInfo-&gt;setUserName($peopleInfo[&#039;userName&#039;]);\n$UserInfo-&gt;setUserAge($peopleInfo[&#039;userAge&#039;]);\n$UserInfo-&gt;setUserMoney($peopleInfo[&#039;userMoney&#039;]);\n$UserInfo-&gt;getPeople();\n```\n- 建造者模式实现\n```\n//建造者模式，目的是消除其它对象复杂的创建过程\nclass UserInfoBuilder {\n    protected $obj;\n\n    public function __construct() {\n        $this-&gt;obj = new UserInfo;\n    }\n\n    public function buildPeople($peopleInfo) {\n        foreach ($peopleInfo as $k=&gt; $v) {\n            $method = sprintf(&#039;set%s&#039;,ucfirst($k));\n            $this-&gt;obj-&gt;$method($v);\n        }\n    }\n\n    public function getPeople() {\n        $this-&gt;obj-&gt;getPeople();\n    }\n}\n\n/* 创建过程被封装了，用户使用简单了 */\n$peopleInfo = array(\n    &#039;userName&#039; =&gt; &#039;initphp&#039;,\n    &#039;userAge&#039; =&gt; 28,\n    &#039;userMoney&#039; =&gt; &#039;100元&#039;\n);\n$UserInfoBuilder = new UserInfoBuilder;\n$UserInfoBuilder-&gt;buildPeople($peopleInfo); //直接一个build\n$UserInfoBuilder-&gt;getPeople();\n```\n- 基于建造者设计模式创建一个新的对象。这个对象负责解释来自业务逻辑的结果，并且只调用构建完整小配件所需的功能性。即使必要的信息或业务规则发生变化，主流代码仍然采用相同的处理方式Builder对象。我们只需要修改Builder对象(只在一个位置修改)。这个解决方案不仅节省了时间，而且降低了主代码库的复杂性。',0,'http://localhost/qipajun/?p=75',0,'post','',0),
	(77,1,'2017-03-26 13:51:51','2017-03-26 05:51:51','<h2>数据访问对象模式</h2>\n\n<ul>\n<li>数据访问对象设计模式描述了如何创建提供透明访问任何数据源的对象。</li>\n<li>示例代码</li>\n</ul>\n\n<pre><code>class Db_Mysql\n{\n\n    //数据库连接对象\n    protected $_conn;\n\n    //初始化数据库连接\n    public function __construct($host, $user, $pass, $dbName)\n    {\n        $dsn = \"mysql:host={$host};dbname={$dbName}\";\n        $option =  array(PDO::MYSQL_ATTR_INIT_COMMAND =&gt; \'SET NAMES \\\'UTF8\\\'\');\n        $this-&gt;_conn = new PDO($dsn, \'root\', \'\',$option);\n    }\n\n    //插入操作\n    public function insert($data)\n    {\n        //传入一个数组，可以插入数据\n    }\n\n    //修改操作\n    public function update($data, $where)\n    {\n        //根据查询条件，修改数据\n    }\n\n    //删除操作\n    public function delete($where)\n    {\n        //根据查询条件，删除数据\n    }\n\n    //执行sql操作\n    public function exec($sql)\n    {\n        $this-&gt;getConnection()-&gt;exec($sql);\n    }\n\n    //查询操作\n    public function query($sql)\n    {\n        $data = $this-&gt;getConnection()-&gt;query($sql);\n        $data-&gt;setFetchMode(PDO::FETCH_ASSOC);\n        $res = $data-&gt;fetchAll();\n        return $res;\n    }\n\n    //获取连接\n    public function getConnection()\n    {\n        return $this-&gt;_conn;\n    }\n}\n\n\nclass Test extends Db_Mysql\n{\n\n    //初始化\n    public function __construct($host, $user, $tableName, $pass)\n    {\n        parent::__construct($host, $user, $pass, $tableName);\n    }\n}\n\n//查询\n$test = new Test(\'127.0.0.1\', \'root\',\'test\',\'\');\n$sql  = \"select * from user limit 1\";\n$res = $test-&gt;query($sql);\nvar_dump($res);\n//执行\n$sql = \"SET NAMES utf8\";\n$res = $test-&gt;exec($sql);\nvar_dump($res);\n</code></pre>\n\n<ul>\n<li>将数据库访问层脱离出来 作为公用的访问接口，方便用户开放，是php中常用的一种设计模式。</li>\n</ul>','数据访问对象模式','','publish','closed','open','','%e6%95%b0%e6%8d%ae%e8%ae%bf%e9%97%ae%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:51','2017-03-26 05:51:51','## 数据访问对象模式\n- 数据访问对象设计模式描述了如何创建提供透明访问任何数据源的对象。\n- 示例代码\n```\nclass Db_Mysql\n{\n\n    //数据库连接对象\n    protected $_conn;\n\n    //初始化数据库连接\n    public function __construct($host, $user, $pass, $dbName)\n    {\n        $dsn = &quot;mysql:host={$host};dbname={$dbName}&quot;;\n        $option =  array(PDO::MYSQL_ATTR_INIT_COMMAND =&gt; &#039;SET NAMES \\&#039;UTF8\\&#039;&#039;);\n        $this-&gt;_conn = new PDO($dsn, &#039;root&#039;, &#039;&#039;,$option);\n    }\n\n    //插入操作\n    public function insert($data)\n    {\n        //传入一个数组，可以插入数据\n    }\n\n    //修改操作\n    public function update($data, $where)\n    {\n        //根据查询条件，修改数据\n    }\n\n    //删除操作\n    public function delete($where)\n    {\n        //根据查询条件，删除数据\n    }\n\n    //执行sql操作\n    public function exec($sql)\n    {\n        $this-&gt;getConnection()-&gt;exec($sql);\n    }\n    \n    //查询操作\n    public function query($sql)\n    {\n        $data = $this-&gt;getConnection()-&gt;query($sql);\n        $data-&gt;setFetchMode(PDO::FETCH_ASSOC);\n        $res = $data-&gt;fetchAll();\n        return $res;\n    }\n\n    //获取连接\n    public function getConnection()\n    {\n        return $this-&gt;_conn;\n    }\n}\n\n\nclass Test extends Db_Mysql\n{\n\n    //初始化\n    public function __construct($host, $user, $tableName, $pass)\n    {\n        parent::__construct($host, $user, $pass, $tableName);\n    }\n}\n\n//查询\n$test = new Test(&#039;127.0.0.1&#039;, &#039;root&#039;,&#039;test&#039;,&#039;&#039;);\n$sql  = &quot;select * from user limit 1&quot;;\n$res = $test-&gt;query($sql);\nvar_dump($res);\n//执行\n$sql = &quot;SET NAMES utf8&quot;;\n$res = $test-&gt;exec($sql);\nvar_dump($res);\n```\n- 将数据库访问层脱离出来 作为公用的访问接口，方便用户开放，是php中常用的一种设计模式。',0,'http://localhost/qipajun/?p=77',0,'post','',0),
	(79,1,'2017-03-26 13:51:51','2017-03-26 05:51:51','<h2>装饰器模式</h2>\n\n<ul>\n<li>对已有对象的部分内容或者功能进行调整，但是不需要修改原始对象结构，可以使用<code>装饰器设计模式</code>。\n\n<ul>\n<li>装饰器主要是不改变现有对象数据结构的前提</li>\n</ul></li>\n<li>装饰器模式（Decorator），可以动态地添加修改类的功能</li>\n<li>一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重新实现类的方法</li>\n<li>使用装饰器模式，仅需在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性</li>\n<li>代码</li>\n</ul>\n\n<pre><code>class UserInfo {\n\n    public $userInfo = array();\n\n    public function addUser($userInfo) {\n        $this-&gt;userInfo[] = $userInfo;\n    }\n\n    public function getUserList() {\n        print_r($this-&gt;userInfo);\n    }\n}\n\n\nclass UserInfoDecorate {\n\n    public function makeCaps($UserInfo) {\n        foreach ($UserInfo-&gt;userInfo as &amp;$val) {\n            $val = strtoupper($val);\n        }\n    }\n\n}\n\n$UserInfo = new UserInfo;\n$UserInfo-&gt;addUser(\'zhu\');\n$UserInfo-&gt;addUser(\'initphp\');\n$UserInfoDecorate = new UserInfoDecorate;\n$UserInfoDecorate-&gt;makeCaps($UserInfo);\n$UserInfo-&gt;getUserList();\n\n</code></pre>','装饰器模式','','publish','closed','open','','%e8%a3%85%e9%a5%b0%e5%99%a8%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:51','2017-03-26 05:51:51','## 装饰器模式\n- 对已有对象的部分内容或者功能进行调整，但是不需要修改原始对象结构，可以使用`装饰器设计模式`。\n    - 装饰器主要是不改变现有对象数据结构的前提\n- 装饰器模式（Decorator），可以动态地添加修改类的功能\n- 一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重新实现类的方法\n- 使用装饰器模式，仅需在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性\n- 代码\n```\nclass UserInfo {\n\n    public $userInfo = array();\n\n    public function addUser($userInfo) {\n        $this-&gt;userInfo[] = $userInfo;\n    }\n\n    public function getUserList() {\n        print_r($this-&gt;userInfo);\n    }\n}\n\n\nclass UserInfoDecorate {\n\n    public function makeCaps($UserInfo) {\n        foreach ($UserInfo-&gt;userInfo as &amp;$val) {\n            $val = strtoupper($val);\n        }\n    }\n\n}\n\n$UserInfo = new UserInfo;\n$UserInfo-&gt;addUser(&#039;zhu&#039;);\n$UserInfo-&gt;addUser(&#039;initphp&#039;);\n$UserInfoDecorate = new UserInfoDecorate;\n$UserInfoDecorate-&gt;makeCaps($UserInfo);\n$UserInfo-&gt;getUserList();\n\n```',0,'http://localhost/qipajun/?p=79',0,'post','',0),
	(81,1,'2017-03-26 13:51:52','2017-03-26 05:51:52','<h2>解释器模式</h2>\n\n<blockquote>\n  <ul>\n  <li>解释器模式:用于分析一个实体的关键元素，并且针对每个元素提供自己的解释或相应动作。</li>\n  <li>解释器模式最常用于PHP/HTML模板系统中。</li>\n  <li>代码</li>\n  </ul>\n</blockquote>\n\n<pre><code>class template {\n\n    private $left  = \'&lt;!--{\';\n    private $right = \'}--&gt;\';\n\n    public function run($str) {\n        return $this-&gt;init($str, $this-&gt;left, $this-&gt;right);\n    }\n\n    /**\n     * 模板驱动-默认的驱动\n     * @param  string $str 模板文件数据\n     * @return string\n     */\n    private function init($str, $left, $right) {\n        $pattern = array(\'/\'.$left.\'/\', \'/\'.$right.\'/\');\n        $replacement = array(\'\', \'\');\n        return preg_replace($pattern, $replacement, $str);\n    }\n}\n$str = \"这是一个模板类，简单的模板类，标题为：&lt;!--{Hello World}--&gt;\";\n$template = new template;\necho $template-&gt;run($str);\n</code></pre>\n\n<ul>\n<li>输出</li>\n</ul>\n\n<pre><code>这是一个模板类，简单的模板类，标题为：Hello World\n</code></pre>','解释器模式','','publish','closed','open','','%e8%a7%a3%e9%87%8a%e5%99%a8%e6%a8%a1%e5%bc%8f','','','2017-03-26 13:51:52','2017-03-26 05:51:52','## 解释器模式\n> -  解释器模式:用于分析一个实体的关键元素，并且针对每个元素提供自己的解释或相应动作。\n> - 解释器模式最常用于PHP/HTML模板系统中。\n- 代码\n```\nclass template {\n\n    private $left  = &#039;&lt;!--{&#039;;\n    private $right = &#039;}--&gt;&#039;;\n\n    public function run($str) {\n        return $this-&gt;init($str, $this-&gt;left, $this-&gt;right);\n    }\n\n    /**\n     * 模板驱动-默认的驱动\n     * @param  string $str 模板文件数据\n     * @return string\n     */\n    private function init($str, $left, $right) {\n        $pattern = array(&#039;/&#039;.$left.&#039;/&#039;, &#039;/&#039;.$right.&#039;/&#039;);\n        $replacement = array(&#039;&#039;, &#039;&#039;);\n        return preg_replace($pattern, $replacement, $str);\n    }\n}\n$str = &quot;这是一个模板类，简单的模板类，标题为：&lt;!--{Hello World}--&gt;&quot;;\n$template = new template;\necho $template-&gt;run($str);\n```\n- 输出\n```\n这是一个模板类，简单的模板类，标题为：Hello World\n```',0,'http://localhost/qipajun/?p=81',0,'post','',0),
	(83,1,'2017-03-26 13:51:52','2017-03-26 05:51:52','<h2>迭代器</h2>\n\n<ul>\n<li>迭代器设计模式可以帮助构建特定对象，那些对象能够提供单一标准接口循环或代任何类型的可计数数据。</li>\n</ul>\n\n<pre><code>class MyIterator implements Iterator {\n\n    private $var = array();\n\n    public function __construct($array) {\n        $this-&gt;var = $array;\n    }\n\n    public function rewind() {\n        reset($this-&gt;var);\n    }\n\n    public function current() {\n        $var = current($this-&gt;var);\n        return $var;\n    }\n\n    public function valid() {\n        $var = $this-&gt;current() !== false;\n        return $var;\n    }\n\n    public function next() {\n        $var = next($this-&gt;var);\n        return $var;\n    }\n\n    public function key() {\n        $var = key($this-&gt;var);\n        return $var;\n    }\n}\n$values = array(\'a\', \'b\', \'c\');\n$it = new MyIterator($values);\nforeach ($it as $a =&gt; $b) {\n    print \"$a: $b&lt;br&gt;\";\n}\n</code></pre>','迭代器','','publish','closed','open','','%e8%bf%ad%e4%bb%a3%e5%99%a8','','','2017-03-26 13:51:52','2017-03-26 05:51:52','## 迭代器\n- 迭代器设计模式可以帮助构建特定对象，那些对象能够提供单一标准接口循环或代任何类型的可计数数据。\n```\nclass MyIterator implements Iterator {\n\n    private $var = array();\n\n    public function __construct($array) {\n        $this-&gt;var = $array;\n    }\n\n    public function rewind() {\n        reset($this-&gt;var);\n    }\n\n    public function current() {\n        $var = current($this-&gt;var);\n        return $var;\n    }\n\n    public function valid() {\n        $var = $this-&gt;current() !== false;\n        return $var;\n    }\n\n    public function next() {\n        $var = next($this-&gt;var);\n        return $var;\n    }\n\n    public function key() {\n        $var = key($this-&gt;var);\n        return $var;\n    }\n}\n$values = array(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;);\n$it = new MyIterator($values);\nforeach ($it as $a =&gt; $b) {\n    print &quot;$a: $b&lt;br&gt;&quot;;\n}\n```',0,'http://localhost/qipajun/?p=83',0,'post','',0),
	(85,1,'2017-03-26 13:51:52','2017-03-26 05:51:52','<h2>适配器</h2>\n\n<ul>\n<li>适配器设计模式只是将某个对象的接口适配为另一个对象所期望的几口。</li>\n<li>通过适配器设计模式(Adapter Design Pattern)，编程人员能够使用新的代码和功能性来帮助更新原有的系统。</li>\n<li><strong>设计情景：</strong></li>\n</ul>\n\n<ol>\n<li>假如我们原始的有一个UserInfo的类，提供用户信息的类，早起设计该类的时候，只实现了一个getUserName获取用户名的方法。</li>\n<li>我们的MyOldObject类中，将从UserInfo这个类中获取用户信息，并且输出用户名</li>\n<li>随着时间的推移，我们旧的UserInfo这个类只提供的获取用户名的方法，已经没法满足需求，我们同时需要获取用户的年龄等信息。</li>\n<li>为了不改变原本UserInfo这个类，我们就继承UserInfo，建立一个UserInfoAdapter类，实现getAge获取年龄这样的方法。</li>\n<li>在我们的MyNewObject新的类中，我们实例化UserInfoAdapter，打印出用户姓名和年龄。</li>\n<li>这样，随着我们的扩展，我们没有改变原先UserInfo这个类和使用这个类的接口，我们通过适配的方法，将UserInfo类扩展出来</li>\n</ol>\n\n<ul>\n<li>代码：UserInfo类，实现getUserName方法</li>\n</ul>\n\n<pre><code>&lt;?php   \n//早期的一个用户类，只实现获取用户名的方法  \nclass UserInfo {  \n\n    public function getUserName() {  \n        return \'qipajun\';  \n    }  \n}  \n</code></pre>\n\n<ul>\n<li>代码：MyOldObject类，从UserInfo类中获取信息，输出用户名</li>\n</ul>\n\n<pre><code>&lt;?php  \ninclude_once(\"UserInfo.php\");  \nclass MyOldObject {  \n    public function write() {  \n        $UserInfo = new UserInfo;  \n        echo $UserInfo-&gt;getUserName();  \n    }  \n}  \n$a = new MyOldObject;  \n$a-&gt;write();  \n</code></pre>\n\n<ul>\n<li>代码：UserInfoAdapter类，随着时间推移，项目需求在变化，UserInfo类无法满足需求，我们做了UserInfo类的适配器，满足新功能的需求</li>\n</ul>\n\n<pre><code>&lt;?php   \ninclude_once(\"UserInfo.php\");   \nclass UserInfoAdapter extends UserInfo{  \n\n    public function getUserAge() {  \n        return 28;  \n    }  \n\n    public function getUser() {   \n        return array(  \n            \'username\' =&gt; $this-&gt;getUserName(),  \n            \'age\' =&gt; $this-&gt;getUserAge()  \n        );  \n    }  \n}  \n</code></pre>\n\n<ul>\n<li>代码：MyNewObject类，新功能的类，需要打印出用户年龄和姓名，UserInfo类无法满足需求，需要调用UserInfoAdapter适配器这个类</li>\n</ul>\n\n<pre><code>&lt;?php  \ninclude_once(\"UserInfoAdapter.php\");  \nclass MyNewObject {   \n    public function write() {  \n        $UserInfoAdapter = new UserInfoAdapter;  \n        print_r($UserInfoAdapter-&gt;getUser());   \n    }  \n}  \n$a = new MyNewObject;  \n$a-&gt;write();  \n</code></pre>\n\n<ul>\n<li>在需要转化一个对象的接口用于另一个对象时，实现Adapter对象不仅是最佳做法，而且也能够减少很多麻烦。</li>\n<li><p>基本上，只要存在要求主平台持续稳定并且不使现有应用程序混乱的问题，在开发解决方案时就可以使用适配器设计模式。</p></li>\n<li><p><a href=\"http://blog.csdn.net/initphp/article/details/7676129\">原文参考地址</a></p></li>\n</ul>','适配器','','publish','closed','open','','%e9%80%82%e9%85%8d%e5%99%a8','','','2017-03-26 13:51:52','2017-03-26 05:51:52','## 适配器\n- 适配器设计模式只是将某个对象的接口适配为另一个对象所期望的几口。\n- 通过适配器设计模式(Adapter Design Pattern)，编程人员能够使用新的代码和功能性来帮助更新原有的系统。\n- **设计情景：**\n\n1.  假如我们原始的有一个UserInfo的类，提供用户信息的类，早起设计该类的时候，只实现了一个getUserName获取用户名的方法。\n2.  我们的MyOldObject类中，将从UserInfo这个类中获取用户信息，并且输出用户名\n3.  随着时间的推移，我们旧的UserInfo这个类只提供的获取用户名的方法，已经没法满足需求，我们同时需要获取用户的年龄等信息。\n4.  为了不改变原本UserInfo这个类，我们就继承UserInfo，建立一个UserInfoAdapter类，实现getAge获取年龄这样的方法。\n5.  在我们的MyNewObject新的类中，我们实例化UserInfoAdapter，打印出用户姓名和年龄。\n6.  这样，随着我们的扩展，我们没有改变原先UserInfo这个类和使用这个类的接口，我们通过适配的方法，将UserInfo类扩展出来\n\n- 代码：UserInfo类，实现getUserName方法\n```\n&lt;?php   \n//早期的一个用户类，只实现获取用户名的方法  \nclass UserInfo {  \n  \n    public function getUserName() {  \n        return &#039;qipajun&#039;;  \n    }  \n}  \n```\n- 代码：MyOldObject类，从UserInfo类中获取信息，输出用户名\n```\n&lt;?php  \ninclude_once(&quot;UserInfo.php&quot;);  \nclass MyOldObject {  \n    public function write() {  \n        $UserInfo = new UserInfo;  \n        echo $UserInfo-&gt;getUserName();  \n    }  \n}  \n$a = new MyOldObject;  \n$a-&gt;write();  \n```\n- 代码：UserInfoAdapter类，随着时间推移，项目需求在变化，UserInfo类无法满足需求，我们做了UserInfo类的适配器，满足新功能的需求\n```\n&lt;?php   \ninclude_once(&quot;UserInfo.php&quot;);   \nclass UserInfoAdapter extends UserInfo{  \n  \n    public function getUserAge() {  \n        return 28;  \n    }  \n      \n    public function getUser() {   \n        return array(  \n            &#039;username&#039; =&gt; $this-&gt;getUserName(),  \n            &#039;age&#039; =&gt; $this-&gt;getUserAge()  \n        );  \n    }  \n}  \n```\n- 代码：MyNewObject类，新功能的类，需要打印出用户年龄和姓名，UserInfo类无法满足需求，需要调用UserInfoAdapter适配器这个类\n```\n&lt;?php  \ninclude_once(&quot;UserInfoAdapter.php&quot;);  \nclass MyNewObject {   \n    public function write() {  \n        $UserInfoAdapter = new UserInfoAdapter;  \n        print_r($UserInfoAdapter-&gt;getUser());   \n    }  \n}  \n$a = new MyNewObject;  \n$a-&gt;write();  \n```\n- 在需要转化一个对象的接口用于另一个对象时，实现Adapter对象不仅是最佳做法，而且也能够减少很多麻烦。\n- 基本上，只要存在要求主平台持续稳定并且不使现有应用程序混乱的问题，在开发解决方案时就可以使用适配器设计模式。\n\n- [原文参考地址](http://blog.csdn.net/initphp/article/details/7676129)',0,'http://localhost/qipajun/?p=85',0,'post','',0);

/*!40000 ALTER TABLE `duosutewp_posts` ENABLE KEYS */;
UNLOCK TABLES;



/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
